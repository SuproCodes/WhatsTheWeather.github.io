var $0 = Object.defineProperty; var V0 = (t, e, n) => e in t ? $0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var z = (t, e, n) => (V0(t, typeof e != "symbol" ? e + "" : e, n), n); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerpolicy && (s.referrerPolicy = r.referrerpolicy), r.crossorigin === "use-credentials" ? s.credentials = "include" : r.crossorigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = n(r); fetch(r.href, s) } })(); function U0(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Ru = { exports: {} }, la = {}, J = { exports: {} }, B = {}; var rs = Symbol.for("react.element"), Y0 = Symbol.for("react.portal"), X0 = Symbol.for("react.fragment"), K0 = Symbol.for("react.strict_mode"), Q0 = Symbol.for("react.profiler"), G0 = Symbol.for("react.provider"), Z0 = Symbol.for("react.context"), q0 = Symbol.for("react.forward_ref"), J0 = Symbol.for("react.suspense"), tv = Symbol.for("react.memo"), ev = Symbol.for("react.lazy"), af = Symbol.iterator; function nv(t) { return t === null || typeof t != "object" ? null : (t = af && t[af] || t["@@iterator"], typeof t == "function" ? t : null) } var op = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, ap = Object.assign, lp = {}; function Ui(t, e, n) { this.props = t, this.context = e, this.refs = lp, this.updater = n || op } Ui.prototype.isReactComponent = {}; Ui.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Ui.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function up() { } up.prototype = Ui.prototype; function Fu(t, e, n) { this.props = t, this.context = e, this.refs = lp, this.updater = n || op } var ju = Fu.prototype = new up; ju.constructor = Fu; ap(ju, Ui.prototype); ju.isPureReactComponent = !0; var lf = Array.isArray, cp = Object.prototype.hasOwnProperty, Bu = { current: null }, fp = { key: !0, ref: !0, __self: !0, __source: !0 }; function dp(t, e, n) { var i, r = {}, s = null, o = null; if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) cp.call(e, i) && !fp.hasOwnProperty(i) && (r[i] = e[i]); var a = arguments.length - 2; if (a === 1) r.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; r.children = l } if (t && t.defaultProps) for (i in a = t.defaultProps, a) r[i] === void 0 && (r[i] = a[i]); return { $$typeof: rs, type: t, key: s, ref: o, props: r, _owner: Bu.current } } function iv(t, e) { return { $$typeof: rs, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function Hu(t) { return typeof t == "object" && t !== null && t.$$typeof === rs } function rv(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var uf = /\/+/g; function Da(t, e) { return typeof t == "object" && t !== null && t.key != null ? rv("" + t.key) : e.toString(36) } function no(t, e, n, i, r) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var o = !1; if (t === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (t.$$typeof) { case rs: case Y0: o = !0 } }if (o) return o = t, r = r(o), t = i === "" ? "." + Da(o, 0) : i, lf(r) ? (n = "", t != null && (n = t.replace(uf, "$&/") + "/"), no(r, e, n, "", function (u) { return u })) : r != null && (Hu(r) && (r = iv(r, n + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(uf, "$&/") + "/") + t)), e.push(r)), 1; if (o = 0, i = i === "" ? "." : i + ":", lf(t)) for (var a = 0; a < t.length; a++) { s = t[a]; var l = i + Da(s, a); o += no(s, e, n, l, r) } else if (l = nv(t), typeof l == "function") for (t = l.call(t), a = 0; !(s = t.next()).done;)s = s.value, l = i + Da(s, a++), o += no(s, e, n, l, r); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function gs(t, e, n) { if (t == null) return t; var i = [], r = 0; return no(t, i, "", "", function (s) { return e.call(n, s, r++) }), i } function sv(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var zt = { current: null }, io = { transition: null }, ov = { ReactCurrentDispatcher: zt, ReactCurrentBatchConfig: io, ReactCurrentOwner: Bu }; B.Children = { map: gs, forEach: function (t, e, n) { gs(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return gs(t, function () { e++ }), e }, toArray: function (t) { return gs(t, function (e) { return e }) || [] }, only: function (t) { if (!Hu(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; B.Component = Ui; B.Fragment = X0; B.Profiler = Q0; B.PureComponent = Fu; B.StrictMode = K0; B.Suspense = J0; B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ov; B.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var i = ap({}, t.props), r = t.key, s = t.ref, o = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = Bu.current), e.key !== void 0 && (r = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps; for (l in e) cp.call(e, l) && !fp.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) i.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; i.children = a } return { $$typeof: rs, type: t.type, key: r, ref: s, props: i, _owner: o } }; B.createContext = function (t) { return t = { $$typeof: Z0, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: G0, _context: t }, t.Consumer = t }; B.createElement = dp; B.createFactory = function (t) { var e = dp.bind(null, t); return e.type = t, e }; B.createRef = function () { return { current: null } }; B.forwardRef = function (t) { return { $$typeof: q0, render: t } }; B.isValidElement = Hu; B.lazy = function (t) { return { $$typeof: ev, _payload: { _status: -1, _result: t }, _init: sv } }; B.memo = function (t, e) { return { $$typeof: tv, type: t, compare: e === void 0 ? null : e } }; B.startTransition = function (t) { var e = io.transition; io.transition = {}; try { t() } finally { io.transition = e } }; B.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; B.useCallback = function (t, e) { return zt.current.useCallback(t, e) }; B.useContext = function (t) { return zt.current.useContext(t) }; B.useDebugValue = function () { }; B.useDeferredValue = function (t) { return zt.current.useDeferredValue(t) }; B.useEffect = function (t, e) { return zt.current.useEffect(t, e) }; B.useId = function () { return zt.current.useId() }; B.useImperativeHandle = function (t, e, n) { return zt.current.useImperativeHandle(t, e, n) }; B.useInsertionEffect = function (t, e) { return zt.current.useInsertionEffect(t, e) }; B.useLayoutEffect = function (t, e) { return zt.current.useLayoutEffect(t, e) }; B.useMemo = function (t, e) { return zt.current.useMemo(t, e) }; B.useReducer = function (t, e, n) { return zt.current.useReducer(t, e, n) }; B.useRef = function (t) { return zt.current.useRef(t) }; B.useState = function (t) { return zt.current.useState(t) }; B.useSyncExternalStore = function (t, e, n) { return zt.current.useSyncExternalStore(t, e, n) }; B.useTransition = function () { return zt.current.useTransition() }; B.version = "18.2.0"; (function (t) { t.exports = B })(J); const ss = U0(J.exports); var av = J.exports, lv = Symbol.for("react.element"), uv = Symbol.for("react.fragment"), cv = Object.prototype.hasOwnProperty, fv = av.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, dv = { key: !0, ref: !0, __self: !0, __source: !0 }; function hp(t, e, n) { var i, r = {}, s = null, o = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (i in e) cv.call(e, i) && !dv.hasOwnProperty(i) && (r[i] = e[i]); if (t && t.defaultProps) for (i in e = t.defaultProps, e) r[i] === void 0 && (r[i] = e[i]); return { $$typeof: lv, type: t, key: s, ref: o, props: r, _owner: fv.current } } la.Fragment = uv; la.jsx = hp; la.jsxs = hp; (function (t) { t.exports = la })(Ru); const H = Ru.exports.jsx, dt = Ru.exports.jsxs; var xl = {}, pp = { exports: {} }, ee = {}, mp = { exports: {} }, gp = {}; (function (t) { function e(E, N) { var I = E.length; E.push(N); t: for (; 0 < I;) { var K = I - 1 >>> 1, Z = E[K]; if (0 < r(Z, N)) E[K] = N, E[I] = Z, I = K; else break t } } function n(E) { return E.length === 0 ? null : E[0] } function i(E) { if (E.length === 0) return null; var N = E[0], I = E.pop(); if (I !== N) { E[0] = I; t: for (var K = 0, Z = E.length, we = Z >>> 1; K < we;) { var Yt = 2 * (K + 1) - 1, Ae = E[Yt], Xt = Yt + 1, ms = E[Xt]; if (0 > r(Ae, I)) Xt < Z && 0 > r(ms, Ae) ? (E[K] = ms, E[Xt] = I, K = Xt) : (E[K] = Ae, E[Yt] = I, K = Yt); else if (Xt < Z && 0 > r(ms, I)) E[K] = ms, E[Xt] = I, K = Xt; else break t } } return N } function r(E, N) { var I = E.sortIndex - N.sortIndex; return I !== 0 ? I : E.id - N.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); t.unstable_now = function () { return o.now() - a } } var l = [], u = [], c = 1, f = null, d = 3, h = !1, g = !1, v = !1, x = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, p = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function y(E) { for (var N = n(u); N !== null;) { if (N.callback === null) i(u); else if (N.startTime <= E) i(u), N.sortIndex = N.expirationTime, e(l, N); else break; N = n(u) } } function _(E) { if (v = !1, y(E), !g) if (n(l) !== null) g = !0, X(b); else { var N = n(u); N !== null && Mt(_, N.startTime - E) } } function b(E, N) { g = !1, v && (v = !1, m(S), S = -1), h = !0; var I = d; try { for (y(N), f = n(l); f !== null && (!(f.expirationTime > N) || E && !D());) { var K = f.callback; if (typeof K == "function") { f.callback = null, d = f.priorityLevel; var Z = K(f.expirationTime <= N); N = t.unstable_now(), typeof Z == "function" ? f.callback = Z : f === n(l) && i(l), y(N) } else i(l); f = n(l) } if (f !== null) var we = !0; else { var Yt = n(u); Yt !== null && Mt(_, Yt.startTime - N), we = !1 } return we } finally { f = null, d = I, h = !1 } } var w = !1, k = null, S = -1, P = 5, M = -1; function D() { return !(t.unstable_now() - M < P) } function F() { if (k !== null) { var E = t.unstable_now(); M = E; var N = !0; try { N = k(!0, E) } finally { N ? A() : (w = !1, k = null) } } else w = !1 } var A; if (typeof p == "function") A = function () { p(F) }; else if (typeof MessageChannel < "u") { var ut = new MessageChannel, Y = ut.port2; ut.port1.onmessage = F, A = function () { Y.postMessage(null) } } else A = function () { x(F, 0) }; function X(E) { k = E, w || (w = !0, A()) } function Mt(E, N) { S = x(function () { E(t.unstable_now()) }, N) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (E) { E.callback = null }, t.unstable_continueExecution = function () { g || h || (g = !0, X(b)) }, t.unstable_forceFrameRate = function (E) { 0 > E || 125 < E ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < E ? Math.floor(1e3 / E) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return d }, t.unstable_getFirstCallbackNode = function () { return n(l) }, t.unstable_next = function (E) { switch (d) { case 1: case 2: case 3: var N = 3; break; default: N = d }var I = d; d = N; try { return E() } finally { d = I } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (E, N) { switch (E) { case 1: case 2: case 3: case 4: case 5: break; default: E = 3 }var I = d; d = E; try { return N() } finally { d = I } }, t.unstable_scheduleCallback = function (E, N, I) { var K = t.unstable_now(); switch (typeof I == "object" && I !== null ? (I = I.delay, I = typeof I == "number" && 0 < I ? K + I : K) : I = K, E) { case 1: var Z = -1; break; case 2: Z = 250; break; case 5: Z = 1073741823; break; case 4: Z = 1e4; break; default: Z = 5e3 }return Z = I + Z, E = { id: c++, callback: N, priorityLevel: E, startTime: I, expirationTime: Z, sortIndex: -1 }, I > K ? (E.sortIndex = I, e(u, E), n(l) === null && E === n(u) && (v ? (m(S), S = -1) : v = !0, Mt(_, I - K))) : (E.sortIndex = Z, e(l, E), g || h || (g = !0, X(b))), E }, t.unstable_shouldYield = D, t.unstable_wrapCallback = function (E) { var N = d; return function () { var I = d; d = N; try { return E.apply(this, arguments) } finally { d = I } } } })(gp); (function (t) { t.exports = gp })(mp); var vp = J.exports, te = mp.exports; function C(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var yp = new Set, Lr = {}; function ri(t, e) { Ni(t, e), Ni(t + "Capture", e) } function Ni(t, e) { for (Lr[t] = e, t = 0; t < e.length; t++)yp.add(e[t]) } var We = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), _l = Object.prototype.hasOwnProperty, hv = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, cf = {}, ff = {}; function pv(t) { return _l.call(ff, t) ? !0 : _l.call(cf, t) ? !1 : hv.test(t) ? ff[t] = !0 : (cf[t] = !0, !1) } function mv(t, e, n, i) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function gv(t, e, n, i) { if (e === null || typeof e > "u" || mv(t, e, n, i)) return !0; if (i) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Rt(t, e, n, i, r, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var Pt = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { Pt[t] = new Rt(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; Pt[e] = new Rt(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { Pt[t] = new Rt(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { Pt[t] = new Rt(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { Pt[t] = new Rt(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { Pt[t] = new Rt(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { Pt[t] = new Rt(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { Pt[t] = new Rt(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { Pt[t] = new Rt(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Wu = /[\-:]([a-z])/g; function $u(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Wu, $u); Pt[e] = new Rt(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Wu, $u); Pt[e] = new Rt(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Wu, $u); Pt[e] = new Rt(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { Pt[t] = new Rt(t, 1, !1, t.toLowerCase(), null, !1, !1) }); Pt.xlinkHref = new Rt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { Pt[t] = new Rt(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Vu(t, e, n, i) { var r = Pt.hasOwnProperty(e) ? Pt[e] : null; (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (gv(e, n, r, i) && (n = null), i || r === null ? pv(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : r.mustUseProperty ? t[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (e = r.attributeName, i = r.attributeNamespace, n === null ? t.removeAttribute(e) : (r = r.type, n = r === 3 || r === 4 && n === !0 ? "" : "" + n, i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n)))) } var Ge = vp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, vs = Symbol.for("react.element"), ui = Symbol.for("react.portal"), ci = Symbol.for("react.fragment"), Uu = Symbol.for("react.strict_mode"), bl = Symbol.for("react.profiler"), xp = Symbol.for("react.provider"), _p = Symbol.for("react.context"), Yu = Symbol.for("react.forward_ref"), wl = Symbol.for("react.suspense"), kl = Symbol.for("react.suspense_list"), Xu = Symbol.for("react.memo"), en = Symbol.for("react.lazy"), bp = Symbol.for("react.offscreen"), df = Symbol.iterator; function Qi(t) { return t === null || typeof t != "object" ? null : (t = df && t[df] || t["@@iterator"], typeof t == "function" ? t : null) } var lt = Object.assign, Na; function lr(t) {
  if (Na === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); Na = e && e[1] || "" } return `
`+ Na + t
} var Ia = !1; function za(t, e) {
  if (!t || Ia) return ""; Ia = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var i = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { i = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { i = u } t() } } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (var r = u.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
          var l = `
`+ r[o].replace(" at new ", " at "); return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { Ia = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? lr(t) : ""
} function vv(t) { switch (t.tag) { case 5: return lr(t.type); case 16: return lr("Lazy"); case 13: return lr("Suspense"); case 19: return lr("SuspenseList"); case 0: case 2: case 15: return t = za(t.type, !1), t; case 11: return t = za(t.type.render, !1), t; case 1: return t = za(t.type, !0), t; default: return "" } } function Sl(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case ci: return "Fragment"; case ui: return "Portal"; case bl: return "Profiler"; case Uu: return "StrictMode"; case wl: return "Suspense"; case kl: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case _p: return (t.displayName || "Context") + ".Consumer"; case xp: return (t._context.displayName || "Context") + ".Provider"; case Yu: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Xu: return e = t.displayName || null, e !== null ? e : Sl(t.type) || "Memo"; case en: e = t._payload, t = t._init; try { return Sl(t(e)) } catch { } }return null } function yv(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Sl(e); case 8: return e === Uu ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function wn(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function wp(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function xv(t) { var e = wp(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), i = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { i = "" + o, s.call(this, o) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = "" + o }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function ys(t) { t._valueTracker || (t._valueTracker = xv(t)) } function kp(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), i = ""; return t && (i = wp(t) ? t.checked ? "true" : "false" : t.value), t = i, t !== n ? (e.setValue(t), !0) : !1 } function wo(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function Cl(t, e) { var n = e.checked; return lt({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function hf(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked; n = wn(e.value != null ? e.value : n), t._wrapperState = { initialChecked: i, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Sp(t, e) { e = e.checked, e != null && Vu(t, "checked", e, !1) } function Pl(t, e) { Sp(t, e); var n = wn(e.value), i = e.type; if (n != null) i === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (i === "submit" || i === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Ml(t, e.type, n) : e.hasOwnProperty("defaultValue") && Ml(t, e.type, wn(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function pf(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var i = e.type; if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function Ml(t, e, n) { (e !== "number" || wo(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var ur = Array.isArray; function Ci(t, e, n, i) { if (t = t.options, e) { e = {}; for (var r = 0; r < n.length; r++)e["$" + n[r]] = !0; for (n = 0; n < t.length; n++)r = e.hasOwnProperty("$" + t[n].value), t[n].selected !== r && (t[n].selected = r), r && i && (t[n].defaultSelected = !0) } else { for (n = "" + wn(n), e = null, r = 0; r < t.length; r++) { if (t[r].value === n) { t[r].selected = !0, i && (t[r].defaultSelected = !0); return } e !== null || t[r].disabled || (e = t[r]) } e !== null && (e.selected = !0) } } function El(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(C(91)); return lt({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function mf(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(C(92)); if (ur(n)) { if (1 < n.length) throw Error(C(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: wn(n) } } function Cp(t, e) { var n = wn(e.value), i = wn(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), i != null && (t.defaultValue = "" + i) } function gf(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Pp(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Ol(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Pp(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var xs, Mp = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, i, r) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, i, r) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (xs = xs || document.createElement("div"), xs.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = xs.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function Ar(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var gr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, _v = ["Webkit", "ms", "Moz", "O"]; Object.keys(gr).forEach(function (t) { _v.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), gr[e] = gr[t] }) }); function Ep(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || gr.hasOwnProperty(t) && gr[t] ? ("" + e).trim() : e + "px" } function Op(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var i = n.indexOf("--") === 0, r = Ep(n, e[n], i); n === "float" && (n = "cssFloat"), i ? t.setProperty(n, r) : t[n] = r } } var bv = lt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Tl(t, e) { if (e) { if (bv[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(C(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(C(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(C(61)) } if (e.style != null && typeof e.style != "object") throw Error(C(62)) } } function Ll(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Al = null; function Ku(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Dl = null, Pi = null, Mi = null; function vf(t) { if (t = ls(t)) { if (typeof Dl != "function") throw Error(C(280)); var e = t.stateNode; e && (e = ha(e), Dl(t.stateNode, t.type, e)) } } function Tp(t) { Pi ? Mi ? Mi.push(t) : Mi = [t] : Pi = t } function Lp() { if (Pi) { var t = Pi, e = Mi; if (Mi = Pi = null, vf(t), e) for (t = 0; t < e.length; t++)vf(e[t]) } } function Ap(t, e) { return t(e) } function Dp() { } var Ra = !1; function Np(t, e, n) { if (Ra) return t(e, n); Ra = !0; try { return Ap(t, e, n) } finally { Ra = !1, (Pi !== null || Mi !== null) && (Dp(), Lp()) } } function Dr(t, e) { var n = t.stateNode; if (n === null) return null; var i = ha(n); if (i === null) return null; n = i[e]; t: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (t = t.type, i = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !i; break t; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(C(231, e, typeof n)); return n } var Nl = !1; if (We) try { var Gi = {}; Object.defineProperty(Gi, "passive", { get: function () { Nl = !0 } }), window.addEventListener("test", Gi, Gi), window.removeEventListener("test", Gi, Gi) } catch { Nl = !1 } function wv(t, e, n, i, r, s, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(n, u) } catch (c) { this.onError(c) } } var vr = !1, ko = null, So = !1, Il = null, kv = { onError: function (t) { vr = !0, ko = t } }; function Sv(t, e, n, i, r, s, o, a, l) { vr = !1, ko = null, wv.apply(kv, arguments) } function Cv(t, e, n, i, r, s, o, a, l) { if (Sv.apply(this, arguments), vr) { if (vr) { var u = ko; vr = !1, ko = null } else throw Error(C(198)); So || (So = !0, Il = u) } } function si(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, (e.flags & 4098) !== 0 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function Ip(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function yf(t) { if (si(t) !== t) throw Error(C(188)) } function Pv(t) { var e = t.alternate; if (!e) { if (e = si(t), e === null) throw Error(C(188)); return e !== t ? null : t } for (var n = t, i = e; ;) { var r = n.return; if (r === null) break; var s = r.alternate; if (s === null) { if (i = r.return, i !== null) { n = i; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === n) return yf(r), t; if (s === i) return yf(r), e; s = s.sibling } throw Error(C(188)) } if (n.return !== i.return) n = r, i = s; else { for (var o = !1, a = r.child; a;) { if (a === n) { o = !0, n = r, i = s; break } if (a === i) { o = !0, i = r, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, i = r; break } if (a === i) { o = !0, i = s, n = r; break } a = a.sibling } if (!o) throw Error(C(189)) } } if (n.alternate !== i) throw Error(C(190)) } if (n.tag !== 3) throw Error(C(188)); return n.stateNode.current === n ? t : e } function zp(t) { return t = Pv(t), t !== null ? Rp(t) : null } function Rp(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = Rp(t); if (e !== null) return e; t = t.sibling } return null } var Fp = te.unstable_scheduleCallback, xf = te.unstable_cancelCallback, Mv = te.unstable_shouldYield, Ev = te.unstable_requestPaint, pt = te.unstable_now, Ov = te.unstable_getCurrentPriorityLevel, Qu = te.unstable_ImmediatePriority, jp = te.unstable_UserBlockingPriority, Co = te.unstable_NormalPriority, Tv = te.unstable_LowPriority, Bp = te.unstable_IdlePriority, ua = null, Oe = null; function Lv(t) { if (Oe && typeof Oe.onCommitFiberRoot == "function") try { Oe.onCommitFiberRoot(ua, t, void 0, (t.current.flags & 128) === 128) } catch { } } var ye = Math.clz32 ? Math.clz32 : Nv, Av = Math.log, Dv = Math.LN2; function Nv(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Av(t) / Dv | 0) | 0 } var _s = 64, bs = 4194304; function cr(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function Po(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var i = 0, r = t.suspendedLanes, s = t.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? i = cr(a) : (s &= o, s !== 0 && (i = cr(s))) } else o = n & ~r, o !== 0 ? i = cr(o) : s !== 0 && (i = cr(s)); if (i === 0) return 0; if (e !== 0 && e !== i && (e & r) === 0 && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e; if ((i & 4) !== 0 && (i |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= i; 0 < e;)n = 31 - ye(e), r = 1 << n, i |= t[n], e &= ~r; return i } function Iv(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function zv(t, e) { for (var n = t.suspendedLanes, i = t.pingedLanes, r = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var o = 31 - ye(s), a = 1 << o, l = r[o]; l === -1 ? ((a & n) === 0 || (a & i) !== 0) && (r[o] = Iv(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a } } function zl(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function Hp() { var t = _s; return _s <<= 1, (_s & 4194240) === 0 && (_s = 64), t } function Fa(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function os(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - ye(e), t[e] = n } function Rv(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var i = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var r = 31 - ye(n), s = 1 << r; e[r] = 0, i[r] = -1, t[r] = -1, n &= ~s } } function Gu(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var i = 31 - ye(n), r = 1 << i; r & e | t[i] & e && (t[i] |= e), n &= ~r } } var U = 0; function Wp(t) { return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var $p, Zu, Vp, Up, Yp, Rl = !1, ws = [], hn = null, pn = null, mn = null, Nr = new Map, Ir = new Map, rn = [], Fv = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function _f(t, e) { switch (t) { case "focusin": case "focusout": hn = null; break; case "dragenter": case "dragleave": pn = null; break; case "mouseover": case "mouseout": mn = null; break; case "pointerover": case "pointerout": Nr.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ir.delete(e.pointerId) } } function Zi(t, e, n, i, r, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = ls(e), e !== null && Zu(e)), t) : (t.eventSystemFlags |= i, e = t.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), t) } function jv(t, e, n, i, r) { switch (e) { case "focusin": return hn = Zi(hn, t, e, n, i, r), !0; case "dragenter": return pn = Zi(pn, t, e, n, i, r), !0; case "mouseover": return mn = Zi(mn, t, e, n, i, r), !0; case "pointerover": var s = r.pointerId; return Nr.set(s, Zi(Nr.get(s) || null, t, e, n, i, r)), !0; case "gotpointercapture": return s = r.pointerId, Ir.set(s, Zi(Ir.get(s) || null, t, e, n, i, r)), !0 }return !1 } function Xp(t) { var e = Bn(t.target); if (e !== null) { var n = si(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = Ip(n), e !== null) { t.blockedOn = e, Yp(t.priority, function () { Vp(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function ro(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = Fl(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var i = new n.constructor(n.type, n); Al = i, n.target.dispatchEvent(i), Al = null } else return e = ls(n), e !== null && Zu(e), t.blockedOn = n, !1; e.shift() } return !0 } function bf(t, e, n) { ro(t) && n.delete(e) } function Bv() { Rl = !1, hn !== null && ro(hn) && (hn = null), pn !== null && ro(pn) && (pn = null), mn !== null && ro(mn) && (mn = null), Nr.forEach(bf), Ir.forEach(bf) } function qi(t, e) { t.blockedOn === e && (t.blockedOn = null, Rl || (Rl = !0, te.unstable_scheduleCallback(te.unstable_NormalPriority, Bv))) } function zr(t) { function e(r) { return qi(r, t) } if (0 < ws.length) { qi(ws[0], t); for (var n = 1; n < ws.length; n++) { var i = ws[n]; i.blockedOn === t && (i.blockedOn = null) } } for (hn !== null && qi(hn, t), pn !== null && qi(pn, t), mn !== null && qi(mn, t), Nr.forEach(e), Ir.forEach(e), n = 0; n < rn.length; n++)i = rn[n], i.blockedOn === t && (i.blockedOn = null); for (; 0 < rn.length && (n = rn[0], n.blockedOn === null);)Xp(n), n.blockedOn === null && rn.shift() } var Ei = Ge.ReactCurrentBatchConfig, Mo = !0; function Hv(t, e, n, i) { var r = U, s = Ei.transition; Ei.transition = null; try { U = 1, qu(t, e, n, i) } finally { U = r, Ei.transition = s } } function Wv(t, e, n, i) { var r = U, s = Ei.transition; Ei.transition = null; try { U = 4, qu(t, e, n, i) } finally { U = r, Ei.transition = s } } function qu(t, e, n, i) { if (Mo) { var r = Fl(t, e, n, i); if (r === null) Ka(t, e, i, Eo, n), _f(t, i); else if (jv(r, t, e, n, i)) i.stopPropagation(); else if (_f(t, i), e & 4 && -1 < Fv.indexOf(t)) { for (; r !== null;) { var s = ls(r); if (s !== null && $p(s), s = Fl(t, e, n, i), s === null && Ka(t, e, i, Eo, n), s === r) break; r = s } r !== null && i.stopPropagation() } else Ka(t, e, i, null, n) } } var Eo = null; function Fl(t, e, n, i) { if (Eo = null, t = Ku(i), t = Bn(t), t !== null) if (e = si(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = Ip(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Eo = t, null } function Kp(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Ov()) { case Qu: return 1; case jp: return 4; case Co: case Tv: return 16; case Bp: return 536870912; default: return 16 }default: return 16 } } var on = null, Ju = null, so = null; function Qp() { if (so) return so; var t, e = Ju, n = e.length, i, r = "value" in on ? on.value : on.textContent, s = r.length; for (t = 0; t < n && e[t] === r[t]; t++); var o = n - t; for (i = 1; i <= o && e[n - i] === r[s - i]; i++); return so = r.slice(t, 1 < i ? 1 - i : void 0) } function oo(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function ks() { return !0 } function wf() { return !1 } function ne(t) { function e(n, i, r, s, o) { this._reactName = n, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ks : wf, this.isPropagationStopped = wf, this } return lt(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ks) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ks) }, persist: function () { }, isPersistent: ks }), e } var Yi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, tc = ne(Yi), as = lt({}, Yi, { view: 0, detail: 0 }), $v = ne(as), ja, Ba, Ji, ca = lt({}, as, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ec, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Ji && (Ji && t.type === "mousemove" ? (ja = t.screenX - Ji.screenX, Ba = t.screenY - Ji.screenY) : Ba = ja = 0, Ji = t), ja) }, movementY: function (t) { return "movementY" in t ? t.movementY : Ba } }), kf = ne(ca), Vv = lt({}, ca, { dataTransfer: 0 }), Uv = ne(Vv), Yv = lt({}, as, { relatedTarget: 0 }), Ha = ne(Yv), Xv = lt({}, Yi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Kv = ne(Xv), Qv = lt({}, Yi, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), Gv = ne(Qv), Zv = lt({}, Yi, { data: 0 }), Sf = ne(Zv), qv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Jv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, ty = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function ey(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = ty[t]) ? !!e[t] : !1 } function ec() { return ey } var ny = lt({}, as, { key: function (t) { if (t.key) { var e = qv[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = oo(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Jv[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ec, charCode: function (t) { return t.type === "keypress" ? oo(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? oo(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), iy = ne(ny), ry = lt({}, ca, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Cf = ne(ry), sy = lt({}, as, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ec }), oy = ne(sy), ay = lt({}, Yi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), ly = ne(ay), uy = lt({}, ca, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), cy = ne(uy), fy = [9, 13, 27, 32], nc = We && "CompositionEvent" in window, yr = null; We && "documentMode" in document && (yr = document.documentMode); var dy = We && "TextEvent" in window && !yr, Gp = We && (!nc || yr && 8 < yr && 11 >= yr), Pf = String.fromCharCode(32), Mf = !1; function Zp(t, e) { switch (t) { case "keyup": return fy.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function qp(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var fi = !1; function hy(t, e) { switch (t) { case "compositionend": return qp(e); case "keypress": return e.which !== 32 ? null : (Mf = !0, Pf); case "textInput": return t = e.data, t === Pf && Mf ? null : t; default: return null } } function py(t, e) { if (fi) return t === "compositionend" || !nc && Zp(t, e) ? (t = Qp(), so = Ju = on = null, fi = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return Gp && e.locale !== "ko" ? null : e.data; default: return null } } var my = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Ef(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!my[t.type] : e === "textarea" } function Jp(t, e, n, i) { Tp(i), e = Oo(e, "onChange"), 0 < e.length && (n = new tc("onChange", "change", null, n, i), t.push({ event: n, listeners: e })) } var xr = null, Rr = null; function gy(t) { cm(t, 0) } function fa(t) { var e = pi(t); if (kp(e)) return t } function vy(t, e) { if (t === "change") return e } var tm = !1; if (We) { var Wa; if (We) { var $a = "oninput" in document; if (!$a) { var Of = document.createElement("div"); Of.setAttribute("oninput", "return;"), $a = typeof Of.oninput == "function" } Wa = $a } else Wa = !1; tm = Wa && (!document.documentMode || 9 < document.documentMode) } function Tf() { xr && (xr.detachEvent("onpropertychange", em), Rr = xr = null) } function em(t) { if (t.propertyName === "value" && fa(Rr)) { var e = []; Jp(e, Rr, t, Ku(t)), Np(gy, e) } } function yy(t, e, n) { t === "focusin" ? (Tf(), xr = e, Rr = n, xr.attachEvent("onpropertychange", em)) : t === "focusout" && Tf() } function xy(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return fa(Rr) } function _y(t, e) { if (t === "click") return fa(e) } function by(t, e) { if (t === "input" || t === "change") return fa(e) } function wy(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var _e = typeof Object.is == "function" ? Object.is : wy; function Fr(t, e) { if (_e(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), i = Object.keys(e); if (n.length !== i.length) return !1; for (i = 0; i < n.length; i++) { var r = n[i]; if (!_l.call(e, r) || !_e(t[r], e[r])) return !1 } return !0 } function Lf(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function Af(t, e) { var n = Lf(t); t = 0; for (var i; n;) { if (n.nodeType === 3) { if (i = t + n.textContent.length, t <= e && i >= e) return { node: n, offset: e - t }; t = i } t: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break t } n = n.parentNode } n = void 0 } n = Lf(n) } } function nm(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? nm(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function im() { for (var t = window, e = wo(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = wo(t.document) } return e } function ic(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function ky(t) { var e = im(), n = t.focusedElem, i = t.selectionRange; if (e !== n && n && n.ownerDocument && nm(n.ownerDocument.documentElement, n)) { if (i !== null && ic(n)) { if (e = i.start, t = i.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var r = n.textContent.length, s = Math.min(i.start, r); i = i.end === void 0 ? s : Math.min(i.end, r), !t.extend && s > i && (r = i, i = s, s = r), r = Af(n, s); var o = Af(n, i); r && o && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), t.removeAllRanges(), s > i ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var Sy = We && "documentMode" in document && 11 >= document.documentMode, di = null, jl = null, _r = null, Bl = !1; function Df(t, e, n) { var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Bl || di == null || di !== wo(i) || (i = di, "selectionStart" in i && ic(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), _r && Fr(_r, i) || (_r = i, i = Oo(jl, "onSelect"), 0 < i.length && (e = new tc("onSelect", "select", null, e, n), t.push({ event: e, listeners: i }), e.target = di))) } function Ss(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var hi = { animationend: Ss("Animation", "AnimationEnd"), animationiteration: Ss("Animation", "AnimationIteration"), animationstart: Ss("Animation", "AnimationStart"), transitionend: Ss("Transition", "TransitionEnd") }, Va = {}, rm = {}; We && (rm = document.createElement("div").style, "AnimationEvent" in window || (delete hi.animationend.animation, delete hi.animationiteration.animation, delete hi.animationstart.animation), "TransitionEvent" in window || delete hi.transitionend.transition); function da(t) { if (Va[t]) return Va[t]; if (!hi[t]) return t; var e = hi[t], n; for (n in e) if (e.hasOwnProperty(n) && n in rm) return Va[t] = e[n]; return t } var sm = da("animationend"), om = da("animationiteration"), am = da("animationstart"), lm = da("transitionend"), um = new Map, Nf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function En(t, e) { um.set(t, e), ri(e, [t]) } for (var Ua = 0; Ua < Nf.length; Ua++) { var Ya = Nf[Ua], Cy = Ya.toLowerCase(), Py = Ya[0].toUpperCase() + Ya.slice(1); En(Cy, "on" + Py) } En(sm, "onAnimationEnd"); En(om, "onAnimationIteration"); En(am, "onAnimationStart"); En("dblclick", "onDoubleClick"); En("focusin", "onFocus"); En("focusout", "onBlur"); En(lm, "onTransitionEnd"); Ni("onMouseEnter", ["mouseout", "mouseover"]); Ni("onMouseLeave", ["mouseout", "mouseover"]); Ni("onPointerEnter", ["pointerout", "pointerover"]); Ni("onPointerLeave", ["pointerout", "pointerover"]); ri("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); ri("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); ri("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); ri("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); ri("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); ri("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var fr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), My = new Set("cancel close invalid load scroll toggle".split(" ").concat(fr)); function If(t, e, n) { var i = t.type || "unknown-event"; t.currentTarget = n, Cv(i, e, void 0, t), t.currentTarget = null } function cm(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var i = t[n], r = i.event; i = i.listeners; t: { var s = void 0; if (e) for (var o = i.length - 1; 0 <= o; o--) { var a = i[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break t; If(r, a, u), s = l } else for (o = 0; o < i.length; o++) { if (a = i[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break t; If(r, a, u), s = l } } } if (So) throw t = Il, So = !1, Il = null, t } function q(t, e) { var n = e[Ul]; n === void 0 && (n = e[Ul] = new Set); var i = t + "__bubble"; n.has(i) || (fm(e, t, 2, !1), n.add(i)) } function Xa(t, e, n) { var i = 0; e && (i |= 4), fm(n, t, i, e) } var Cs = "_reactListening" + Math.random().toString(36).slice(2); function jr(t) { if (!t[Cs]) { t[Cs] = !0, yp.forEach(function (n) { n !== "selectionchange" && (My.has(n) || Xa(n, !1, t), Xa(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Cs] || (e[Cs] = !0, Xa("selectionchange", !1, e)) } } function fm(t, e, n, i) { switch (Kp(e)) { case 1: var r = Hv; break; case 4: r = Wv; break; default: r = qu }n = r.bind(null, e, n, t), r = void 0, !Nl || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: r }) : t.addEventListener(e, n, !0) : r !== void 0 ? t.addEventListener(e, n, { passive: r }) : t.addEventListener(e, n, !1) } function Ka(t, e, n, i, r) { var s = i; if ((e & 1) === 0 && (e & 2) === 0 && i !== null) t: for (; ;) { if (i === null) return; var o = i.tag; if (o === 3 || o === 4) { var a = i.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = i.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = Bn(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { i = s = o; continue t } a = a.parentNode } } i = i.return } Np(function () { var u = s, c = Ku(n), f = []; t: { var d = um.get(t); if (d !== void 0) { var h = tc, g = t; switch (t) { case "keypress": if (oo(n) === 0) break t; case "keydown": case "keyup": h = iy; break; case "focusin": g = "focus", h = Ha; break; case "focusout": g = "blur", h = Ha; break; case "beforeblur": case "afterblur": h = Ha; break; case "click": if (n.button === 2) break t; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": h = kf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": h = Uv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": h = oy; break; case sm: case om: case am: h = Kv; break; case lm: h = ly; break; case "scroll": h = $v; break; case "wheel": h = cy; break; case "copy": case "cut": case "paste": h = Gv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": h = Cf }var v = (e & 4) !== 0, x = !v && t === "scroll", m = v ? d !== null ? d + "Capture" : null : d; v = []; for (var p = u, y; p !== null;) { y = p; var _ = y.stateNode; if (y.tag === 5 && _ !== null && (y = _, m !== null && (_ = Dr(p, m), _ != null && v.push(Br(p, _, y)))), x) break; p = p.return } 0 < v.length && (d = new h(d, g, null, n, c), f.push({ event: d, listeners: v })) } } if ((e & 7) === 0) { t: { if (d = t === "mouseover" || t === "pointerover", h = t === "mouseout" || t === "pointerout", d && n !== Al && (g = n.relatedTarget || n.fromElement) && (Bn(g) || g[$e])) break t; if ((h || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, h ? (g = n.relatedTarget || n.toElement, h = u, g = g ? Bn(g) : null, g !== null && (x = si(g), g !== x || g.tag !== 5 && g.tag !== 6) && (g = null)) : (h = null, g = u), h !== g)) { if (v = kf, _ = "onMouseLeave", m = "onMouseEnter", p = "mouse", (t === "pointerout" || t === "pointerover") && (v = Cf, _ = "onPointerLeave", m = "onPointerEnter", p = "pointer"), x = h == null ? d : pi(h), y = g == null ? d : pi(g), d = new v(_, p + "leave", h, n, c), d.target = x, d.relatedTarget = y, _ = null, Bn(c) === u && (v = new v(m, p + "enter", g, n, c), v.target = y, v.relatedTarget = x, _ = v), x = _, h && g) e: { for (v = h, m = g, p = 0, y = v; y; y = ai(y))p++; for (y = 0, _ = m; _; _ = ai(_))y++; for (; 0 < p - y;)v = ai(v), p--; for (; 0 < y - p;)m = ai(m), y--; for (; p--;) { if (v === m || m !== null && v === m.alternate) break e; v = ai(v), m = ai(m) } v = null } else v = null; h !== null && zf(f, d, h, v, !1), g !== null && x !== null && zf(f, x, g, v, !0) } } t: { if (d = u ? pi(u) : window, h = d.nodeName && d.nodeName.toLowerCase(), h === "select" || h === "input" && d.type === "file") var b = vy; else if (Ef(d)) if (tm) b = by; else { b = xy; var w = yy } else (h = d.nodeName) && h.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (b = _y); if (b && (b = b(t, u))) { Jp(f, b, n, c); break t } w && w(t, d, u), t === "focusout" && (w = d._wrapperState) && w.controlled && d.type === "number" && Ml(d, "number", d.value) } switch (w = u ? pi(u) : window, t) { case "focusin": (Ef(w) || w.contentEditable === "true") && (di = w, jl = u, _r = null); break; case "focusout": _r = jl = di = null; break; case "mousedown": Bl = !0; break; case "contextmenu": case "mouseup": case "dragend": Bl = !1, Df(f, n, c); break; case "selectionchange": if (Sy) break; case "keydown": case "keyup": Df(f, n, c) }var k; if (nc) t: { switch (t) { case "compositionstart": var S = "onCompositionStart"; break t; case "compositionend": S = "onCompositionEnd"; break t; case "compositionupdate": S = "onCompositionUpdate"; break t }S = void 0 } else fi ? Zp(t, n) && (S = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (S = "onCompositionStart"); S && (Gp && n.locale !== "ko" && (fi || S !== "onCompositionStart" ? S === "onCompositionEnd" && fi && (k = Qp()) : (on = c, Ju = "value" in on ? on.value : on.textContent, fi = !0)), w = Oo(u, S), 0 < w.length && (S = new Sf(S, t, null, n, c), f.push({ event: S, listeners: w }), k ? S.data = k : (k = qp(n), k !== null && (S.data = k)))), (k = dy ? hy(t, n) : py(t, n)) && (u = Oo(u, "onBeforeInput"), 0 < u.length && (c = new Sf("onBeforeInput", "beforeinput", null, n, c), f.push({ event: c, listeners: u }), c.data = k)) } cm(f, e) }) } function Br(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Oo(t, e) { for (var n = e + "Capture", i = []; t !== null;) { var r = t, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = Dr(t, n), s != null && i.unshift(Br(t, s, r)), s = Dr(t, e), s != null && i.push(Br(t, s, r))), t = t.return } return i } function ai(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function zf(t, e, n, i, r) { for (var s = e._reactName, o = []; n !== null && n !== i;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === i) break; a.tag === 5 && u !== null && (a = u, r ? (l = Dr(n, s), l != null && o.unshift(Br(n, l, a))) : r || (l = Dr(n, s), l != null && o.push(Br(n, l, a)))), n = n.return } o.length !== 0 && t.push({ event: e, listeners: o }) } var Ey = /\r\n?/g, Oy = /\u0000|\uFFFD/g; function Rf(t) {
  return (typeof t == "string" ? t : "" + t).replace(Ey, `
`).replace(Oy, "")
} function Ps(t, e, n) { if (e = Rf(e), Rf(t) !== e && n) throw Error(C(425)) } function To() { } var Hl = null, Wl = null; function $l(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var Vl = typeof setTimeout == "function" ? setTimeout : void 0, Ty = typeof clearTimeout == "function" ? clearTimeout : void 0, Ff = typeof Promise == "function" ? Promise : void 0, Ly = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ff < "u" ? function (t) { return Ff.resolve(null).then(t).catch(Ay) } : Vl; function Ay(t) { setTimeout(function () { throw t }) } function Qa(t, e) { var n = e, i = 0; do { var r = n.nextSibling; if (t.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (i === 0) { t.removeChild(r), zr(e); return } i-- } else n !== "$" && n !== "$?" && n !== "$!" || i++; n = r } while (n); zr(e) } function gn(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function jf(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var Xi = Math.random().toString(36).slice(2), Me = "__reactFiber$" + Xi, Hr = "__reactProps$" + Xi, $e = "__reactContainer$" + Xi, Ul = "__reactEvents$" + Xi, Dy = "__reactListeners$" + Xi, Ny = "__reactHandles$" + Xi; function Bn(t) { var e = t[Me]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[$e] || n[Me]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = jf(t); t !== null;) { if (n = t[Me]) return n; t = jf(t) } return e } t = n, n = t.parentNode } return null } function ls(t) { return t = t[Me] || t[$e], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function pi(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(C(33)) } function ha(t) { return t[Hr] || null } var Yl = [], mi = -1; function On(t) { return { current: t } } function nt(t) { 0 > mi || (t.current = Yl[mi], Yl[mi] = null, mi--) } function G(t, e) { mi++, Yl[mi] = t.current, t.current = e } var kn = {}, At = On(kn), $t = On(!1), Qn = kn; function Ii(t, e) { var n = t.type.contextTypes; if (!n) return kn; var i = t.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in n) r[s] = e[s]; return i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = r), r } function Vt(t) { return t = t.childContextTypes, t != null } function Lo() { nt($t), nt(At) } function Bf(t, e, n) { if (At.current !== kn) throw Error(C(168)); G(At, e), G($t, n) } function dm(t, e, n) { var i = t.stateNode; if (e = e.childContextTypes, typeof i.getChildContext != "function") return n; i = i.getChildContext(); for (var r in i) if (!(r in e)) throw Error(C(108, yv(t) || "Unknown", r)); return lt({}, n, i) } function Ao(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || kn, Qn = At.current, G(At, t), G($t, $t.current), !0 } function Hf(t, e, n) { var i = t.stateNode; if (!i) throw Error(C(169)); n ? (t = dm(t, e, Qn), i.__reactInternalMemoizedMergedChildContext = t, nt($t), nt(At), G(At, t)) : nt($t), G($t, n) } var Re = null, pa = !1, Ga = !1; function hm(t) { Re === null ? Re = [t] : Re.push(t) } function Iy(t) { pa = !0, hm(t) } function Tn() { if (!Ga && Re !== null) { Ga = !0; var t = 0, e = U; try { var n = Re; for (U = 1; t < n.length; t++) { var i = n[t]; do i = i(!0); while (i !== null) } Re = null, pa = !1 } catch (r) { throw Re !== null && (Re = Re.slice(t + 1)), Fp(Qu, Tn), r } finally { U = e, Ga = !1 } } return null } var gi = [], vi = 0, Do = null, No = 0, se = [], oe = 0, Gn = null, je = 1, Be = ""; function zn(t, e) { gi[vi++] = No, gi[vi++] = Do, Do = t, No = e } function pm(t, e, n) { se[oe++] = je, se[oe++] = Be, se[oe++] = Gn, Gn = t; var i = je; t = Be; var r = 32 - ye(i) - 1; i &= ~(1 << r), n += 1; var s = 32 - ye(e) + r; if (30 < s) { var o = r - r % 5; s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, je = 1 << 32 - ye(e) + r | n << r | i, Be = s + t } else je = 1 << s | n << r | i, Be = t } function rc(t) { t.return !== null && (zn(t, 1), pm(t, 1, 0)) } function sc(t) { for (; t === Do;)Do = gi[--vi], gi[vi] = null, No = gi[--vi], gi[vi] = null; for (; t === Gn;)Gn = se[--oe], se[oe] = null, Be = se[--oe], se[oe] = null, je = se[--oe], se[oe] = null } var qt = null, Zt = null, rt = !1, ge = null; function mm(t, e) { var n = ae(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function Wf(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, qt = t, Zt = gn(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, qt = t, Zt = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Gn !== null ? { id: je, overflow: Be } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = ae(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, qt = t, Zt = null, !0) : !1; default: return !1 } } function Xl(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Kl(t) { if (rt) { var e = Zt; if (e) { var n = e; if (!Wf(t, e)) { if (Xl(t)) throw Error(C(418)); e = gn(n.nextSibling); var i = qt; e && Wf(t, e) ? mm(i, n) : (t.flags = t.flags & -4097 | 2, rt = !1, qt = t) } } else { if (Xl(t)) throw Error(C(418)); t.flags = t.flags & -4097 | 2, rt = !1, qt = t } } } function $f(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; qt = t } function Ms(t) { if (t !== qt) return !1; if (!rt) return $f(t), rt = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !$l(t.type, t.memoizedProps)), e && (e = Zt)) { if (Xl(t)) throw gm(), Error(C(418)); for (; e;)mm(t, e), e = gn(e.nextSibling) } if ($f(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(C(317)); t: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { Zt = gn(t.nextSibling); break t } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } Zt = null } } else Zt = qt ? gn(t.stateNode.nextSibling) : null; return !0 } function gm() { for (var t = Zt; t;)t = gn(t.nextSibling) } function zi() { Zt = qt = null, rt = !1 } function oc(t) { ge === null ? ge = [t] : ge.push(t) } var zy = Ge.ReactCurrentBatchConfig; function pe(t, e) { if (t && t.defaultProps) { e = lt({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } var Io = On(null), zo = null, yi = null, ac = null; function lc() { ac = yi = zo = null } function uc(t) { var e = Io.current; nt(Io), t._currentValue = e } function Ql(t, e, n) { for (; t !== null;) { var i = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), t === n) break; t = t.return } } function Oi(t, e) { zo = t, ac = yi = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & e) !== 0 && (Ht = !0), t.firstContext = null) } function fe(t) { var e = t._currentValue; if (ac !== t) if (t = { context: t, memoizedValue: e, next: null }, yi === null) { if (zo === null) throw Error(C(308)); yi = t, zo.dependencies = { lanes: 0, firstContext: t } } else yi = yi.next = t; return e } var Hn = null; function cc(t) { Hn === null ? Hn = [t] : Hn.push(t) } function vm(t, e, n, i) { var r = e.interleaved; return r === null ? (n.next = n, cc(e)) : (n.next = r.next, r.next = n), e.interleaved = n, Ve(t, i) } function Ve(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var nn = !1; function fc(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function ym(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function He(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function vn(t, e, n) { var i = t.updateQueue; if (i === null) return null; if (i = i.shared, ($ & 2) !== 0) { var r = i.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Ve(t, n) } return r = i.interleaved, r === null ? (e.next = e, cc(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Ve(t, n) } function ao(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, Gu(t, n) } } function Vf(t, e) { var n = t.updateQueue, i = t.alternate; if (i !== null && (i = i.updateQueue, n === i)) { var r = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? r = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? r = s = e : s = s.next = e } else r = s = e; n = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Ro(t, e, n, i) { var r = t.updateQueue; nn = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? s = u : o.next = u, o = l; var c = t.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (s !== null) { var f = r.baseState; o = 0, c = u = l = null, a = s; do { var d = a.lane, h = a.eventTime; if ((i & d) === d) { c !== null && (c = c.next = { eventTime: h, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); t: { var g = t, v = a; switch (d = e, h = n, v.tag) { case 1: if (g = v.payload, typeof g == "function") { f = g.call(h, f, d); break t } f = g; break t; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = v.payload, d = typeof g == "function" ? g.call(h, f, d) : g, d == null) break t; f = lt({}, f, d); break t; case 2: nn = !0 } } a.callback !== null && a.lane !== 0 && (t.flags |= 64, d = r.effects, d === null ? r.effects = [a] : d.push(a)) } else h = { eventTime: h, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = h, l = f) : c = c.next = h, o |= d; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; d = a, a = d.next, d.next = null, r.lastBaseUpdate = d, r.shared.pending = null } } while (1); if (c === null && (l = f), r.baseState = l, r.firstBaseUpdate = u, r.lastBaseUpdate = c, e = r.shared.interleaved, e !== null) { r = e; do o |= r.lane, r = r.next; while (r !== e) } else s === null && (r.shared.lanes = 0); qn |= o, t.lanes = o, t.memoizedState = f } } function Uf(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var i = t[e], r = i.callback; if (r !== null) { if (i.callback = null, i = n, typeof r != "function") throw Error(C(191, r)); r.call(i) } } } var xm = new vp.Component().refs; function Gl(t, e, n, i) { e = t.memoizedState, n = n(i, e), n = n == null ? e : lt({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var ma = { isMounted: function (t) { return (t = t._reactInternals) ? si(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var i = It(), r = xn(t), s = He(i, r); s.payload = e, n != null && (s.callback = n), e = vn(t, s, r), e !== null && (xe(e, t, r, i), ao(e, t, r)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var i = It(), r = xn(t), s = He(i, r); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = vn(t, s, r), e !== null && (xe(e, t, r, i), ao(e, t, r)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = It(), i = xn(t), r = He(n, i); r.tag = 2, e != null && (r.callback = e), e = vn(t, r, i), e !== null && (xe(e, t, i, n), ao(e, t, i)) } }; function Yf(t, e, n, i, r, s, o) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Fr(n, i) || !Fr(r, s) : !0 } function _m(t, e, n) { var i = !1, r = kn, s = e.contextType; return typeof s == "object" && s !== null ? s = fe(s) : (r = Vt(e) ? Qn : At.current, i = e.contextTypes, s = (i = i != null) ? Ii(t, r) : kn), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = ma, t.stateNode = e, e._reactInternals = t, i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = s), e } function Xf(t, e, n, i) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, i), e.state !== t && ma.enqueueReplaceState(e, e.state, null) } function Zl(t, e, n, i) { var r = t.stateNode; r.props = n, r.state = t.memoizedState, r.refs = xm, fc(t); var s = e.contextType; typeof s == "object" && s !== null ? r.context = fe(s) : (s = Vt(e) ? Qn : At.current, r.context = Ii(t, s)), r.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Gl(t, e, s, n), r.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && ma.enqueueReplaceState(r, r.state, null), Ro(t, n, r, i), r.state = t.memoizedState), typeof r.componentDidMount == "function" && (t.flags |= 4194308) } function tr(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(C(309)); var i = n.stateNode } if (!i) throw Error(C(147, t)); var r = i, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = r.refs; a === xm && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof t != "string") throw Error(C(284)); if (!n._owner) throw Error(C(290, t)) } return t } function Es(t, e) { throw t = Object.prototype.toString.call(e), Error(C(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function Kf(t) { var e = t._init; return e(t._payload) } function bm(t) { function e(m, p) { if (t) { var y = m.deletions; y === null ? (m.deletions = [p], m.flags |= 16) : y.push(p) } } function n(m, p) { if (!t) return null; for (; p !== null;)e(m, p), p = p.sibling; return null } function i(m, p) { for (m = new Map; p !== null;)p.key !== null ? m.set(p.key, p) : m.set(p.index, p), p = p.sibling; return m } function r(m, p) { return m = _n(m, p), m.index = 0, m.sibling = null, m } function s(m, p, y) { return m.index = y, t ? (y = m.alternate, y !== null ? (y = y.index, y < p ? (m.flags |= 2, p) : y) : (m.flags |= 2, p)) : (m.flags |= 1048576, p) } function o(m) { return t && m.alternate === null && (m.flags |= 2), m } function a(m, p, y, _) { return p === null || p.tag !== 6 ? (p = il(y, m.mode, _), p.return = m, p) : (p = r(p, y), p.return = m, p) } function l(m, p, y, _) { var b = y.type; return b === ci ? c(m, p, y.props.children, _, y.key) : p !== null && (p.elementType === b || typeof b == "object" && b !== null && b.$$typeof === en && Kf(b) === p.type) ? (_ = r(p, y.props), _.ref = tr(m, p, y), _.return = m, _) : (_ = po(y.type, y.key, y.props, null, m.mode, _), _.ref = tr(m, p, y), _.return = m, _) } function u(m, p, y, _) { return p === null || p.tag !== 4 || p.stateNode.containerInfo !== y.containerInfo || p.stateNode.implementation !== y.implementation ? (p = rl(y, m.mode, _), p.return = m, p) : (p = r(p, y.children || []), p.return = m, p) } function c(m, p, y, _, b) { return p === null || p.tag !== 7 ? (p = Xn(y, m.mode, _, b), p.return = m, p) : (p = r(p, y), p.return = m, p) } function f(m, p, y) { if (typeof p == "string" && p !== "" || typeof p == "number") return p = il("" + p, m.mode, y), p.return = m, p; if (typeof p == "object" && p !== null) { switch (p.$$typeof) { case vs: return y = po(p.type, p.key, p.props, null, m.mode, y), y.ref = tr(m, null, p), y.return = m, y; case ui: return p = rl(p, m.mode, y), p.return = m, p; case en: var _ = p._init; return f(m, _(p._payload), y) }if (ur(p) || Qi(p)) return p = Xn(p, m.mode, y, null), p.return = m, p; Es(m, p) } return null } function d(m, p, y, _) { var b = p !== null ? p.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return b !== null ? null : a(m, p, "" + y, _); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case vs: return y.key === b ? l(m, p, y, _) : null; case ui: return y.key === b ? u(m, p, y, _) : null; case en: return b = y._init, d(m, p, b(y._payload), _) }if (ur(y) || Qi(y)) return b !== null ? null : c(m, p, y, _, null); Es(m, y) } return null } function h(m, p, y, _, b) { if (typeof _ == "string" && _ !== "" || typeof _ == "number") return m = m.get(y) || null, a(p, m, "" + _, b); if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case vs: return m = m.get(_.key === null ? y : _.key) || null, l(p, m, _, b); case ui: return m = m.get(_.key === null ? y : _.key) || null, u(p, m, _, b); case en: var w = _._init; return h(m, p, y, w(_._payload), b) }if (ur(_) || Qi(_)) return m = m.get(y) || null, c(p, m, _, b, null); Es(p, _) } return null } function g(m, p, y, _) { for (var b = null, w = null, k = p, S = p = 0, P = null; k !== null && S < y.length; S++) { k.index > S ? (P = k, k = null) : P = k.sibling; var M = d(m, k, y[S], _); if (M === null) { k === null && (k = P); break } t && k && M.alternate === null && e(m, k), p = s(M, p, S), w === null ? b = M : w.sibling = M, w = M, k = P } if (S === y.length) return n(m, k), rt && zn(m, S), b; if (k === null) { for (; S < y.length; S++)k = f(m, y[S], _), k !== null && (p = s(k, p, S), w === null ? b = k : w.sibling = k, w = k); return rt && zn(m, S), b } for (k = i(m, k); S < y.length; S++)P = h(k, m, S, y[S], _), P !== null && (t && P.alternate !== null && k.delete(P.key === null ? S : P.key), p = s(P, p, S), w === null ? b = P : w.sibling = P, w = P); return t && k.forEach(function (D) { return e(m, D) }), rt && zn(m, S), b } function v(m, p, y, _) { var b = Qi(y); if (typeof b != "function") throw Error(C(150)); if (y = b.call(y), y == null) throw Error(C(151)); for (var w = b = null, k = p, S = p = 0, P = null, M = y.next(); k !== null && !M.done; S++, M = y.next()) { k.index > S ? (P = k, k = null) : P = k.sibling; var D = d(m, k, M.value, _); if (D === null) { k === null && (k = P); break } t && k && D.alternate === null && e(m, k), p = s(D, p, S), w === null ? b = D : w.sibling = D, w = D, k = P } if (M.done) return n(m, k), rt && zn(m, S), b; if (k === null) { for (; !M.done; S++, M = y.next())M = f(m, M.value, _), M !== null && (p = s(M, p, S), w === null ? b = M : w.sibling = M, w = M); return rt && zn(m, S), b } for (k = i(m, k); !M.done; S++, M = y.next())M = h(k, m, S, M.value, _), M !== null && (t && M.alternate !== null && k.delete(M.key === null ? S : M.key), p = s(M, p, S), w === null ? b = M : w.sibling = M, w = M); return t && k.forEach(function (F) { return e(m, F) }), rt && zn(m, S), b } function x(m, p, y, _) { if (typeof y == "object" && y !== null && y.type === ci && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case vs: t: { for (var b = y.key, w = p; w !== null;) { if (w.key === b) { if (b = y.type, b === ci) { if (w.tag === 7) { n(m, w.sibling), p = r(w, y.props.children), p.return = m, m = p; break t } } else if (w.elementType === b || typeof b == "object" && b !== null && b.$$typeof === en && Kf(b) === w.type) { n(m, w.sibling), p = r(w, y.props), p.ref = tr(m, w, y), p.return = m, m = p; break t } n(m, w); break } else e(m, w); w = w.sibling } y.type === ci ? (p = Xn(y.props.children, m.mode, _, y.key), p.return = m, m = p) : (_ = po(y.type, y.key, y.props, null, m.mode, _), _.ref = tr(m, p, y), _.return = m, m = _) } return o(m); case ui: t: { for (w = y.key; p !== null;) { if (p.key === w) if (p.tag === 4 && p.stateNode.containerInfo === y.containerInfo && p.stateNode.implementation === y.implementation) { n(m, p.sibling), p = r(p, y.children || []), p.return = m, m = p; break t } else { n(m, p); break } else e(m, p); p = p.sibling } p = rl(y, m.mode, _), p.return = m, m = p } return o(m); case en: return w = y._init, x(m, p, w(y._payload), _) }if (ur(y)) return g(m, p, y, _); if (Qi(y)) return v(m, p, y, _); Es(m, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, p !== null && p.tag === 6 ? (n(m, p.sibling), p = r(p, y), p.return = m, m = p) : (n(m, p), p = il(y, m.mode, _), p.return = m, m = p), o(m)) : n(m, p) } return x } var Ri = bm(!0), wm = bm(!1), us = {}, Te = On(us), Wr = On(us), $r = On(us); function Wn(t) { if (t === us) throw Error(C(174)); return t } function dc(t, e) { switch (G($r, e), G(Wr, t), G(Te, us), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Ol(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Ol(e, t) }nt(Te), G(Te, e) } function Fi() { nt(Te), nt(Wr), nt($r) } function km(t) { Wn($r.current); var e = Wn(Te.current), n = Ol(e, t.type); e !== n && (G(Wr, t), G(Te, n)) } function hc(t) { Wr.current === t && (nt(Te), nt(Wr)) } var ot = On(0); function Fo(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if ((e.flags & 128) !== 0) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var Za = []; function pc() { for (var t = 0; t < Za.length; t++)Za[t]._workInProgressVersionPrimary = null; Za.length = 0 } var lo = Ge.ReactCurrentDispatcher, qa = Ge.ReactCurrentBatchConfig, Zn = 0, at = null, vt = null, wt = null, jo = !1, br = !1, Vr = 0, Ry = 0; function Et() { throw Error(C(321)) } function mc(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!_e(t[n], e[n])) return !1; return !0 } function gc(t, e, n, i, r, s) { if (Zn = s, at = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, lo.current = t === null || t.memoizedState === null ? Hy : Wy, t = n(i, r), br) { s = 0; do { if (br = !1, Vr = 0, 25 <= s) throw Error(C(301)); s += 1, wt = vt = null, e.updateQueue = null, lo.current = $y, t = n(i, r) } while (br) } if (lo.current = Bo, e = vt !== null && vt.next !== null, Zn = 0, wt = vt = at = null, jo = !1, e) throw Error(C(300)); return t } function vc() { var t = Vr !== 0; return Vr = 0, t } function Ce() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return wt === null ? at.memoizedState = wt = t : wt = wt.next = t, wt } function de() { if (vt === null) { var t = at.alternate; t = t !== null ? t.memoizedState : null } else t = vt.next; var e = wt === null ? at.memoizedState : wt.next; if (e !== null) wt = e, vt = t; else { if (t === null) throw Error(C(310)); vt = t, t = { memoizedState: vt.memoizedState, baseState: vt.baseState, baseQueue: vt.baseQueue, queue: vt.queue, next: null }, wt === null ? at.memoizedState = wt = t : wt = wt.next = t } return wt } function Ur(t, e) { return typeof e == "function" ? e(t) : e } function Ja(t) { var e = de(), n = e.queue; if (n === null) throw Error(C(311)); n.lastRenderedReducer = t; var i = vt, r = i.baseQueue, s = n.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } i.baseQueue = r = s, n.pending = null } if (r !== null) { s = r.next, i = i.baseState; var a = o = null, l = null, u = s; do { var c = u.lane; if ((Zn & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), i = u.hasEagerState ? u.eagerState : t(i, u.action); else { var f = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = f, o = i) : l = l.next = f, at.lanes |= c, qn |= c } u = u.next } while (u !== null && u !== s); l === null ? o = i : l.next = a, _e(i, e.memoizedState) || (Ht = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = l, n.lastRenderedState = i } if (t = n.interleaved, t !== null) { r = t; do s = r.lane, at.lanes |= s, qn |= s, r = r.next; while (r !== t) } else r === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function tl(t) { var e = de(), n = e.queue; if (n === null) throw Error(C(311)); n.lastRenderedReducer = t; var i = n.dispatch, r = n.pending, s = e.memoizedState; if (r !== null) { n.pending = null; var o = r = r.next; do s = t(s, o.action), o = o.next; while (o !== r); _e(s, e.memoizedState) || (Ht = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, i] } function Sm() { } function Cm(t, e) { var n = at, i = de(), r = e(), s = !_e(i.memoizedState, r); if (s && (i.memoizedState = r, Ht = !0), i = i.queue, yc(Em.bind(null, n, i, t), [t]), i.getSnapshot !== e || s || wt !== null && wt.memoizedState.tag & 1) { if (n.flags |= 2048, Yr(9, Mm.bind(null, n, i, r, e), void 0, null), kt === null) throw Error(C(349)); (Zn & 30) !== 0 || Pm(n, e, r) } return r } function Pm(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = at.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, at.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function Mm(t, e, n, i) { e.value = n, e.getSnapshot = i, Om(e) && Tm(t) } function Em(t, e, n) { return n(function () { Om(e) && Tm(t) }) } function Om(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !_e(t, n) } catch { return !0 } } function Tm(t) { var e = Ve(t, 1); e !== null && xe(e, t, 1, -1) } function Qf(t) { var e = Ce(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ur, lastRenderedState: t }, e.queue = t, t = t.dispatch = By.bind(null, at, t), [e.memoizedState, t] } function Yr(t, e, n, i) { return t = { tag: t, create: e, destroy: n, deps: i, next: null }, e = at.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, at.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (i = n.next, n.next = t, t.next = i, e.lastEffect = t)), t } function Lm() { return de().memoizedState } function uo(t, e, n, i) { var r = Ce(); at.flags |= t, r.memoizedState = Yr(1 | e, n, void 0, i === void 0 ? null : i) } function ga(t, e, n, i) { var r = de(); i = i === void 0 ? null : i; var s = void 0; if (vt !== null) { var o = vt.memoizedState; if (s = o.destroy, i !== null && mc(i, o.deps)) { r.memoizedState = Yr(e, n, s, i); return } } at.flags |= t, r.memoizedState = Yr(1 | e, n, s, i) } function Gf(t, e) { return uo(8390656, 8, t, e) } function yc(t, e) { return ga(2048, 8, t, e) } function Am(t, e) { return ga(4, 2, t, e) } function Dm(t, e) { return ga(4, 4, t, e) } function Nm(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function Im(t, e, n) { return n = n != null ? n.concat([t]) : null, ga(4, 4, Nm.bind(null, e, t), n) } function xc() { } function zm(t, e) { var n = de(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && mc(e, i[1]) ? i[0] : (n.memoizedState = [t, e], t) } function Rm(t, e) { var n = de(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && mc(e, i[1]) ? i[0] : (t = t(), n.memoizedState = [t, e], t) } function Fm(t, e, n) { return (Zn & 21) === 0 ? (t.baseState && (t.baseState = !1, Ht = !0), t.memoizedState = n) : (_e(n, e) || (n = Hp(), at.lanes |= n, qn |= n, t.baseState = !0), e) } function Fy(t, e) { var n = U; U = n !== 0 && 4 > n ? n : 4, t(!0); var i = qa.transition; qa.transition = {}; try { t(!1), e() } finally { U = n, qa.transition = i } } function jm() { return de().memoizedState } function jy(t, e, n) { var i = xn(t); if (n = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }, Bm(t)) Hm(e, n); else if (n = vm(t, e, n, i), n !== null) { var r = It(); xe(n, t, i, r), Wm(n, e, i) } } function By(t, e, n) { var i = xn(t), r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Bm(t)) Hm(e, r); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, n); if (r.hasEagerState = !0, r.eagerState = a, _e(a, o)) { var l = e.interleaved; l === null ? (r.next = r, cc(e)) : (r.next = l.next, l.next = r), e.interleaved = r; return } } catch { } finally { } n = vm(t, e, r, i), n !== null && (r = It(), xe(n, t, i, r), Wm(n, e, i)) } } function Bm(t) { var e = t.alternate; return t === at || e !== null && e === at } function Hm(t, e) { br = jo = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Wm(t, e, n) { if ((n & 4194240) !== 0) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, Gu(t, n) } } var Bo = { readContext: fe, useCallback: Et, useContext: Et, useEffect: Et, useImperativeHandle: Et, useInsertionEffect: Et, useLayoutEffect: Et, useMemo: Et, useReducer: Et, useRef: Et, useState: Et, useDebugValue: Et, useDeferredValue: Et, useTransition: Et, useMutableSource: Et, useSyncExternalStore: Et, useId: Et, unstable_isNewReconciler: !1 }, Hy = { readContext: fe, useCallback: function (t, e) { return Ce().memoizedState = [t, e === void 0 ? null : e], t }, useContext: fe, useEffect: Gf, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, uo(4194308, 4, Nm.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return uo(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return uo(4, 2, t, e) }, useMemo: function (t, e) { var n = Ce(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var i = Ce(); return e = n !== void 0 ? n(e) : e, i.memoizedState = i.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, i.queue = t, t = t.dispatch = jy.bind(null, at, t), [i.memoizedState, t] }, useRef: function (t) { var e = Ce(); return t = { current: t }, e.memoizedState = t }, useState: Qf, useDebugValue: xc, useDeferredValue: function (t) { return Ce().memoizedState = t }, useTransition: function () { var t = Qf(!1), e = t[0]; return t = Fy.bind(null, t[1]), Ce().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var i = at, r = Ce(); if (rt) { if (n === void 0) throw Error(C(407)); n = n() } else { if (n = e(), kt === null) throw Error(C(349)); (Zn & 30) !== 0 || Pm(i, e, n) } r.memoizedState = n; var s = { value: n, getSnapshot: e }; return r.queue = s, Gf(Em.bind(null, i, s, t), [t]), i.flags |= 2048, Yr(9, Mm.bind(null, i, s, n, e), void 0, null), n }, useId: function () { var t = Ce(), e = kt.identifierPrefix; if (rt) { var n = Be, i = je; n = (i & ~(1 << 32 - ye(i) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Vr++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = Ry++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, Wy = { readContext: fe, useCallback: zm, useContext: fe, useEffect: yc, useImperativeHandle: Im, useInsertionEffect: Am, useLayoutEffect: Dm, useMemo: Rm, useReducer: Ja, useRef: Lm, useState: function () { return Ja(Ur) }, useDebugValue: xc, useDeferredValue: function (t) { var e = de(); return Fm(e, vt.memoizedState, t) }, useTransition: function () { var t = Ja(Ur)[0], e = de().memoizedState; return [t, e] }, useMutableSource: Sm, useSyncExternalStore: Cm, useId: jm, unstable_isNewReconciler: !1 }, $y = { readContext: fe, useCallback: zm, useContext: fe, useEffect: yc, useImperativeHandle: Im, useInsertionEffect: Am, useLayoutEffect: Dm, useMemo: Rm, useReducer: tl, useRef: Lm, useState: function () { return tl(Ur) }, useDebugValue: xc, useDeferredValue: function (t) { var e = de(); return vt === null ? e.memoizedState = t : Fm(e, vt.memoizedState, t) }, useTransition: function () { var t = tl(Ur)[0], e = de().memoizedState; return [t, e] }, useMutableSource: Sm, useSyncExternalStore: Cm, useId: jm, unstable_isNewReconciler: !1 }; function ji(t, e) {
  try { var n = "", i = e; do n += vv(i), i = i.return; while (i); var r = n } catch (s) {
    r = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: t, source: e, stack: r, digest: null }
} function el(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function ql(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var Vy = typeof WeakMap == "function" ? WeakMap : Map; function $m(t, e, n) { n = He(-1, n), n.tag = 3, n.payload = { element: null }; var i = e.value; return n.callback = function () { Wo || (Wo = !0, lu = i), ql(t, e) }, n } function Vm(t, e, n) { n = He(-1, n), n.tag = 3; var i = t.type.getDerivedStateFromError; if (typeof i == "function") { var r = e.value; n.payload = function () { return i(r) }, n.callback = function () { ql(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { ql(t, e), typeof i != "function" && (yn === null ? yn = new Set([this]) : yn.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), n } function Zf(t, e, n) { var i = t.pingCache; if (i === null) { i = t.pingCache = new Vy; var r = new Set; i.set(e, r) } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r)); r.has(n) || (r.add(n), t = r1.bind(null, t, e, n), e.then(t, t)) } function qf(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Jf(t, e, n, i, r) { return (t.mode & 1) === 0 ? (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = He(-1, 1), e.tag = 2, vn(n, e, 1))), n.lanes |= 1), t) : (t.flags |= 65536, t.lanes = r, t) } var Uy = Ge.ReactCurrentOwner, Ht = !1; function Nt(t, e, n, i) { e.child = t === null ? wm(e, null, n, i) : Ri(e, t.child, n, i) } function td(t, e, n, i, r) { n = n.render; var s = e.ref; return Oi(e, r), i = gc(t, e, n, i, s, r), n = vc(), t !== null && !Ht ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Ue(t, e, r)) : (rt && n && rc(e), e.flags |= 1, Nt(t, e, i, r), e.child) } function ed(t, e, n, i, r) { if (t === null) { var s = n.type; return typeof s == "function" && !Mc(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, Um(t, e, s, i, r)) : (t = po(n.type, null, i, e, e.mode, r), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, (t.lanes & r) === 0) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : Fr, n(o, i) && t.ref === e.ref) return Ue(t, e, r) } return e.flags |= 1, t = _n(s, i), t.ref = e.ref, t.return = e, e.child = t } function Um(t, e, n, i, r) { if (t !== null) { var s = t.memoizedProps; if (Fr(s, i) && t.ref === e.ref) if (Ht = !1, e.pendingProps = i = s, (t.lanes & r) !== 0) (t.flags & 131072) !== 0 && (Ht = !0); else return e.lanes = t.lanes, Ue(t, e, r) } return Jl(t, e, n, i, r) } function Ym(t, e, n) { var i = e.pendingProps, r = i.children, s = t !== null ? t.memoizedState : null; if (i.mode === "hidden") if ((e.mode & 1) === 0) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(_i, Qt), Qt |= n; else { if ((n & 1073741824) === 0) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, G(_i, Qt), Qt |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : n, G(_i, Qt), Qt |= i } else s !== null ? (i = s.baseLanes | n, e.memoizedState = null) : i = n, G(_i, Qt), Qt |= i; return Nt(t, e, r, n), e.child } function Xm(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function Jl(t, e, n, i, r) { var s = Vt(n) ? Qn : At.current; return s = Ii(e, s), Oi(e, r), n = gc(t, e, n, i, s, r), i = vc(), t !== null && !Ht ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Ue(t, e, r)) : (rt && i && rc(e), e.flags |= 1, Nt(t, e, n, r), e.child) } function nd(t, e, n, i, r) { if (Vt(n)) { var s = !0; Ao(e) } else s = !1; if (Oi(e, r), e.stateNode === null) co(t, e), _m(e, n, i), Zl(e, n, i, r), i = !0; else if (t === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, u = n.contextType; typeof u == "object" && u !== null ? u = fe(u) : (u = Vt(n) ? Qn : At.current, u = Ii(e, u)); var c = n.getDerivedStateFromProps, f = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function"; f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== u) && Xf(e, o, i, u), nn = !1; var d = e.memoizedState; o.state = d, Ro(e, i, o, r), l = e.memoizedState, a !== i || d !== l || $t.current || nn ? (typeof c == "function" && (Gl(e, n, c, i), l = e.memoizedState), (a = nn || Yf(e, n, a, i, d, l, u)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = u, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1) } else { o = e.stateNode, ym(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : pe(e.type, a), o.props = u, f = e.pendingProps, d = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = fe(l) : (l = Vt(n) ? Qn : At.current, l = Ii(e, l)); var h = n.getDerivedStateFromProps; (c = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || d !== l) && Xf(e, o, i, l), nn = !1, d = e.memoizedState, o.state = d, Ro(e, i, o, r); var g = e.memoizedState; a !== f || d !== g || $t.current || nn ? (typeof h == "function" && (Gl(e, n, h, i), g = e.memoizedState), (u = nn || Yf(e, n, u, i, d, g, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, g, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, g, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = g), o.props = i, o.state = g, o.context = l, i = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024), i = !1) } return tu(t, e, n, i, s, r) } function tu(t, e, n, i, r, s) { Xm(t, e); var o = (e.flags & 128) !== 0; if (!i && !o) return r && Hf(e, n, !1), Ue(t, e, s); i = e.stateNode, Uy.current = e; var a = o && typeof n.getDerivedStateFromError != "function" ? null : i.render(); return e.flags |= 1, t !== null && o ? (e.child = Ri(e, t.child, null, s), e.child = Ri(e, null, a, s)) : Nt(t, e, a, s), e.memoizedState = i.state, r && Hf(e, n, !0), e.child } function Km(t) { var e = t.stateNode; e.pendingContext ? Bf(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Bf(t, e.context, !1), dc(t, e.containerInfo) } function id(t, e, n, i, r) { return zi(), oc(r), e.flags |= 256, Nt(t, e, n, i), e.child } var eu = { dehydrated: null, treeContext: null, retryLane: 0 }; function nu(t) { return { baseLanes: t, cachePool: null, transitions: null } } function Qm(t, e, n) { var i = e.pendingProps, r = ot.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1), G(ot, r & 1), t === null) return Kl(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((e.mode & 1) === 0 ? e.lanes = 1 : t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824, null) : (o = i.children, t = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, (i & 1) === 0 && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = xa(o, i, 0, null), t = Xn(t, i, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = nu(n), e.memoizedState = eu, t) : _c(e, o)); if (r = t.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return Yy(t, e, o, i, a, r, n); if (s) { s = i.fallback, o = e.mode, r = t.child, a = r.sibling; var l = { mode: "hidden", children: i.children }; return (o & 1) === 0 && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = _n(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = _n(a, s) : (s = Xn(s, o, n, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = t.child.memoizedState, o = o === null ? nu(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = eu, i } return s = t.child, t = s.sibling, i = _n(s, { mode: "visible", children: i.children }), (e.mode & 1) === 0 && (i.lanes = n), i.return = e, i.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = i, e.memoizedState = null, i } function _c(t, e) { return e = xa({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function Os(t, e, n, i) { return i !== null && oc(i), Ri(e, t.child, null, n), t = _c(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function Yy(t, e, n, i, r, s, o) { if (n) return e.flags & 256 ? (e.flags &= -257, i = el(Error(C(422))), Os(t, e, o, i)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = xa({ mode: "visible", children: i.children }, r, 0, null), s = Xn(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, (e.mode & 1) !== 0 && Ri(e, t.child, null, o), e.child.memoizedState = nu(o), e.memoizedState = eu, s); if ((e.mode & 1) === 0) return Os(t, e, o, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst; return i = a, s = Error(C(419)), i = el(s, i, void 0), Os(t, e, o, i) } if (a = (o & t.childLanes) !== 0, Ht || a) { if (i = kt, i !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = (r & (i.suspendedLanes | o)) !== 0 ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Ve(t, r), xe(i, t, r, -1)) } return Pc(), i = el(Error(C(421))), Os(t, e, o, i) } return r.data === "$?" ? (e.flags |= 128, e.child = t.child, e = s1.bind(null, t), r._reactRetry = e, null) : (t = s.treeContext, Zt = gn(r.nextSibling), qt = e, rt = !0, ge = null, t !== null && (se[oe++] = je, se[oe++] = Be, se[oe++] = Gn, je = t.id, Be = t.overflow, Gn = e), e = _c(e, i.children), e.flags |= 4096, e) } function rd(t, e, n) { t.lanes |= e; var i = t.alternate; i !== null && (i.lanes |= e), Ql(t.return, e, n) } function nl(t, e, n, i, r) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: n, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = r) } function Gm(t, e, n) { var i = e.pendingProps, r = i.revealOrder, s = i.tail; if (Nt(t, e, i.children, n), i = ot.current, (i & 2) !== 0) i = i & 1 | 2, e.flags |= 128; else { if (t !== null && (t.flags & 128) !== 0) t: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && rd(t, n, e); else if (t.tag === 19) rd(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break t; for (; t.sibling === null;) { if (t.return === null || t.return === e) break t; t = t.return } t.sibling.return = t.return, t = t.sibling } i &= 1 } if (G(ot, i), (e.mode & 1) === 0) e.memoizedState = null; else switch (r) { case "forwards": for (n = e.child, r = null; n !== null;)t = n.alternate, t !== null && Fo(t) === null && (r = n), n = n.sibling; n = r, n === null ? (r = e.child, e.child = null) : (r = n.sibling, n.sibling = null), nl(e, !1, r, n, s); break; case "backwards": for (n = null, r = e.child, e.child = null; r !== null;) { if (t = r.alternate, t !== null && Fo(t) === null) { e.child = r; break } t = r.sibling, r.sibling = n, n = r, r = t } nl(e, !0, n, null, s); break; case "together": nl(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function co(t, e) { (e.mode & 1) === 0 && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Ue(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), qn |= e.lanes, (n & e.childLanes) === 0) return null; if (t !== null && e.child !== t.child) throw Error(C(153)); if (e.child !== null) { for (t = e.child, n = _n(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = _n(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function Xy(t, e, n) { switch (e.tag) { case 3: Km(e), zi(); break; case 5: km(e); break; case 1: Vt(e.type) && Ao(e); break; case 4: dc(e, e.stateNode.containerInfo); break; case 10: var i = e.type._context, r = e.memoizedProps.value; G(Io, i._currentValue), i._currentValue = r; break; case 13: if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (G(ot, ot.current & 1), e.flags |= 128, null) : (n & e.child.childLanes) !== 0 ? Qm(t, e, n) : (G(ot, ot.current & 1), t = Ue(t, e, n), t !== null ? t.sibling : null); G(ot, ot.current & 1); break; case 19: if (i = (n & e.childLanes) !== 0, (t.flags & 128) !== 0) { if (i) return Gm(t, e, n); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), G(ot, ot.current), i) break; return null; case 22: case 23: return e.lanes = 0, Ym(t, e, n) }return Ue(t, e, n) } var Zm, iu, qm, Jm; Zm = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; iu = function () { }; qm = function (t, e, n, i) { var r = t.memoizedProps; if (r !== i) { t = e.stateNode, Wn(Te.current); var s = null; switch (n) { case "input": r = Cl(t, r), i = Cl(t, i), s = []; break; case "select": r = lt({}, r, { value: void 0 }), i = lt({}, i, { value: void 0 }), s = []; break; case "textarea": r = El(t, r), i = El(t, i), s = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (t.onclick = To) }Tl(n, i); var o; n = null; for (u in r) if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null) if (u === "style") { var a = r[u]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Lr.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in i) { var l = i[u]; if (a = r != null ? r[u] : void 0, i.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (s || (s = []), s.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Lr.hasOwnProperty(u) ? (l != null && u === "onScroll" && q("scroll", t), s || a === l || (s = [])) : (s = s || []).push(u, l)) } n && (s = s || []).push("style", n); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; Jm = function (t, e, n, i) { n !== i && (e.flags |= 4) }; function er(t, e) { if (!rt) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : i.sibling = null } } function Ot(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, i = 0; if (e) for (var r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = t, r = r.sibling; else for (r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = t, r = r.sibling; return t.subtreeFlags |= i, t.childLanes = n, e } function Ky(t, e, n) { var i = e.pendingProps; switch (sc(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ot(e), null; case 1: return Vt(e.type) && Lo(), Ot(e), null; case 3: return i = e.stateNode, Fi(), nt($t), nt(At), pc(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (t === null || t.child === null) && (Ms(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, ge !== null && (fu(ge), ge = null))), iu(t, e), Ot(e), null; case 5: hc(e); var r = Wn($r.current); if (n = e.type, t !== null && e.stateNode != null) qm(t, e, n, i, r), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!i) { if (e.stateNode === null) throw Error(C(166)); return Ot(e), null } if (t = Wn(Te.current), Ms(e)) { i = e.stateNode, n = e.type; var s = e.memoizedProps; switch (i[Me] = e, i[Hr] = s, t = (e.mode & 1) !== 0, n) { case "dialog": q("cancel", i), q("close", i); break; case "iframe": case "object": case "embed": q("load", i); break; case "video": case "audio": for (r = 0; r < fr.length; r++)q(fr[r], i); break; case "source": q("error", i); break; case "img": case "image": case "link": q("error", i), q("load", i); break; case "details": q("toggle", i); break; case "input": hf(i, s), q("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!s.multiple }, q("invalid", i); break; case "textarea": mf(i, s), q("invalid", i) }Tl(n, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Ps(i.textContent, a, t), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Ps(i.textContent, a, t), r = ["children", "" + a]) : Lr.hasOwnProperty(o) && a != null && o === "onScroll" && q("scroll", i) } switch (n) { case "input": ys(i), pf(i, s, !0); break; case "textarea": ys(i), gf(i); break; case "select": case "option": break; default: typeof s.onClick == "function" && (i.onclick = To) }i = r, e.updateQueue = i, i !== null && (e.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Pp(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script></script>", t = t.removeChild(t.firstChild)) : typeof i.is == "string" ? t = o.createElement(n, { is: i.is }) : (t = o.createElement(n), n === "select" && (o = t, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : t = o.createElementNS(t, n), t[Me] = e, t[Hr] = i, Zm(t, e, !1, !1), e.stateNode = t; t: { switch (o = Ll(n, i), n) { case "dialog": q("cancel", t), q("close", t), r = i; break; case "iframe": case "object": case "embed": q("load", t), r = i; break; case "video": case "audio": for (r = 0; r < fr.length; r++)q(fr[r], t); r = i; break; case "source": q("error", t), r = i; break; case "img": case "image": case "link": q("error", t), q("load", t), r = i; break; case "details": q("toggle", t), r = i; break; case "input": hf(t, i), r = Cl(t, i), q("invalid", t); break; case "option": r = i; break; case "select": t._wrapperState = { wasMultiple: !!i.multiple }, r = lt({}, i, { value: void 0 }), q("invalid", t); break; case "textarea": mf(t, i), r = El(t, i), q("invalid", t); break; default: r = i }Tl(n, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Op(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Mp(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Ar(t, l) : typeof l == "number" && Ar(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Lr.hasOwnProperty(s) ? l != null && s === "onScroll" && q("scroll", t) : l != null && Vu(t, s, l, o)) } switch (n) { case "input": ys(t), pf(t, i, !1); break; case "textarea": ys(t), gf(t); break; case "option": i.value != null && t.setAttribute("value", "" + wn(i.value)); break; case "select": t.multiple = !!i.multiple, s = i.value, s != null ? Ci(t, !!i.multiple, s, !1) : i.defaultValue != null && Ci(t, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (t.onclick = To) }switch (n) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break t; case "img": i = !0; break t; default: i = !1 } } i && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Ot(e), null; case 6: if (t && e.stateNode != null) Jm(t, e, t.memoizedProps, i); else { if (typeof i != "string" && e.stateNode === null) throw Error(C(166)); if (n = Wn($r.current), Wn(Te.current), Ms(e)) { if (i = e.stateNode, n = e.memoizedProps, i[Me] = e, (s = i.nodeValue !== n) && (t = qt, t !== null)) switch (t.tag) { case 3: Ps(i.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && Ps(i.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i), i[Me] = e, e.stateNode = i } return Ot(e), null; case 13: if (nt(ot), i = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (rt && Zt !== null && (e.mode & 1) !== 0 && (e.flags & 128) === 0) gm(), zi(), e.flags |= 98560, s = !1; else if (s = Ms(e), i !== null && i.dehydrated !== null) { if (t === null) { if (!s) throw Error(C(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(C(317)); s[Me] = e } else zi(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4; Ot(e), s = !1 } else ge !== null && (fu(ge), ge = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return (e.flags & 128) !== 0 ? (e.lanes = n, e) : (i = i !== null, i !== (t !== null && t.memoizedState !== null) && i && (e.child.flags |= 8192, (e.mode & 1) !== 0 && (t === null || (ot.current & 1) !== 0 ? yt === 0 && (yt = 3) : Pc())), e.updateQueue !== null && (e.flags |= 4), Ot(e), null); case 4: return Fi(), iu(t, e), t === null && jr(e.stateNode.containerInfo), Ot(e), null; case 10: return uc(e.type._context), Ot(e), null; case 17: return Vt(e.type) && Lo(), Ot(e), null; case 19: if (nt(ot), s = e.memoizedState, s === null) return Ot(e), null; if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) er(s, !1); else { if (yt !== 0 || t !== null && (t.flags & 128) !== 0) for (t = e.child; t !== null;) { if (o = Fo(t), o !== null) { for (e.flags |= 128, er(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = n, n = e.child; n !== null;)s = n, t = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return G(ot, ot.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && pt() > Bi && (e.flags |= 128, i = !0, er(s, !1), e.lanes = 4194304) } else { if (!i) if (t = Fo(o), t !== null) { if (e.flags |= 128, i = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), er(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !rt) return Ot(e), null } else 2 * pt() - s.renderingStartTime > Bi && n !== 1073741824 && (e.flags |= 128, i = !0, er(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = pt(), e.sibling = null, n = ot.current, G(ot, i ? n & 1 | 2 : n & 1), e) : (Ot(e), null); case 22: case 23: return Cc(), i = e.memoizedState !== null, t !== null && t.memoizedState !== null !== i && (e.flags |= 8192), i && (e.mode & 1) !== 0 ? (Qt & 1073741824) !== 0 && (Ot(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Ot(e), null; case 24: return null; case 25: return null }throw Error(C(156, e.tag)) } function Qy(t, e) { switch (sc(e), e.tag) { case 1: return Vt(e.type) && Lo(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Fi(), nt($t), nt(At), pc(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null; case 5: return hc(e), null; case 13: if (nt(ot), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(C(340)); zi() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return nt(ot), null; case 4: return Fi(), null; case 10: return uc(e.type._context), null; case 22: case 23: return Cc(), null; case 24: return null; default: return null } } var Ts = !1, Lt = !1, Gy = typeof WeakSet == "function" ? WeakSet : Set, T = null; function xi(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (i) { ct(t, e, i) } else n.current = null } function ru(t, e, n) { try { n() } catch (i) { ct(t, e, i) } } var sd = !1; function Zy(t, e) { if (Hl = Mo, t = im(), ic(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else t: { n = (n = t.ownerDocument) && n.defaultView || window; var i = n.getSelection && n.getSelection(); if (i && i.rangeCount !== 0) { n = i.anchorNode; var r = i.anchorOffset, s = i.focusNode; i = i.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break t } var o = 0, a = -1, l = -1, u = 0, c = 0, f = t, d = null; e: for (; ;) { for (var h; f !== n || r !== 0 && f.nodeType !== 3 || (a = o + r), f !== s || i !== 0 && f.nodeType !== 3 || (l = o + i), f.nodeType === 3 && (o += f.nodeValue.length), (h = f.firstChild) !== null;)d = f, f = h; for (; ;) { if (f === t) break e; if (d === n && ++u === r && (a = o), d === s && ++c === i && (l = o), (h = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = h } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Wl = { focusedElem: t, selectionRange: n }, Mo = !1, T = e; T !== null;)if (e = T, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, T = t; else for (; T !== null;) { e = T; try { var g = e.alternate; if ((e.flags & 1024) !== 0) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var v = g.memoizedProps, x = g.memoizedState, m = e.stateNode, p = m.getSnapshotBeforeUpdate(e.elementType === e.type ? v : pe(e.type, v), x); m.__reactInternalSnapshotBeforeUpdate = p } break; case 3: var y = e.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(C(163)) } } catch (_) { ct(e, e.return, _) } if (t = e.sibling, t !== null) { t.return = e.return, T = t; break } T = e.return } return g = sd, sd = !1, g } function wr(t, e, n) { var i = e.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & t) === t) { var s = r.destroy; r.destroy = void 0, s !== void 0 && ru(e, n, s) } r = r.next } while (r !== i) } } function va(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var i = n.create; n.destroy = i() } n = n.next } while (n !== e) } } function su(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function tg(t) { var e = t.alternate; e !== null && (t.alternate = null, tg(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[Me], delete e[Hr], delete e[Ul], delete e[Dy], delete e[Ny])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function eg(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function od(t) { t: for (; ;) { for (; t.sibling === null;) { if (t.return === null || eg(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue t; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function ou(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = To)); else if (i !== 4 && (t = t.child, t !== null)) for (ou(t, e, n), t = t.sibling; t !== null;)ou(t, e, n), t = t.sibling } function au(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (i !== 4 && (t = t.child, t !== null)) for (au(t, e, n), t = t.sibling; t !== null;)au(t, e, n), t = t.sibling } var St = null, me = !1; function qe(t, e, n) { for (n = n.child; n !== null;)ng(t, e, n), n = n.sibling } function ng(t, e, n) { if (Oe && typeof Oe.onCommitFiberUnmount == "function") try { Oe.onCommitFiberUnmount(ua, n) } catch { } switch (n.tag) { case 5: Lt || xi(n, e); case 6: var i = St, r = me; St = null, qe(t, e, n), St = i, me = r, St !== null && (me ? (t = St, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : St.removeChild(n.stateNode)); break; case 18: St !== null && (me ? (t = St, n = n.stateNode, t.nodeType === 8 ? Qa(t.parentNode, n) : t.nodeType === 1 && Qa(t, n), zr(t)) : Qa(St, n.stateNode)); break; case 4: i = St, r = me, St = n.stateNode.containerInfo, me = !0, qe(t, e, n), St = i, me = r; break; case 0: case 11: case 14: case 15: if (!Lt && (i = n.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && ((s & 2) !== 0 || (s & 4) !== 0) && ru(n, e, o), r = r.next } while (r !== i) } qe(t, e, n); break; case 1: if (!Lt && (xi(n, e), i = n.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = n.memoizedProps, i.state = n.memoizedState, i.componentWillUnmount() } catch (a) { ct(n, e, a) } qe(t, e, n); break; case 21: qe(t, e, n); break; case 22: n.mode & 1 ? (Lt = (i = Lt) || n.memoizedState !== null, qe(t, e, n), Lt = i) : qe(t, e, n); break; default: qe(t, e, n) } } function ad(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new Gy), e.forEach(function (i) { var r = o1.bind(null, t, i); n.has(i) || (n.add(i), i.then(r, r)) }) } } function he(t, e) { var n = e.deletions; if (n !== null) for (var i = 0; i < n.length; i++) { var r = n[i]; try { var s = t, o = e, a = o; t: for (; a !== null;) { switch (a.tag) { case 5: St = a.stateNode, me = !1; break t; case 3: St = a.stateNode.containerInfo, me = !0; break t; case 4: St = a.stateNode.containerInfo, me = !0; break t }a = a.return } if (St === null) throw Error(C(160)); ng(s, o, r), St = null, me = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (u) { ct(r, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)ig(e, t), e = e.sibling } function ig(t, e) { var n = t.alternate, i = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (he(e, t), ke(t), i & 4) { try { wr(3, t, t.return), va(3, t) } catch (v) { ct(t, t.return, v) } try { wr(5, t, t.return) } catch (v) { ct(t, t.return, v) } } break; case 1: he(e, t), ke(t), i & 512 && n !== null && xi(n, n.return); break; case 5: if (he(e, t), ke(t), i & 512 && n !== null && xi(n, n.return), t.flags & 32) { var r = t.stateNode; try { Ar(r, "") } catch (v) { ct(t, t.return, v) } } if (i & 4 && (r = t.stateNode, r != null)) { var s = t.memoizedProps, o = n !== null ? n.memoizedProps : s, a = t.type, l = t.updateQueue; if (t.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && Sp(r, s), Ll(a, o); var u = Ll(a, s); for (o = 0; o < l.length; o += 2) { var c = l[o], f = l[o + 1]; c === "style" ? Op(r, f) : c === "dangerouslySetInnerHTML" ? Mp(r, f) : c === "children" ? Ar(r, f) : Vu(r, c, f, u) } switch (a) { case "input": Pl(r, s); break; case "textarea": Cp(r, s); break; case "select": var d = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var h = s.value; h != null ? Ci(r, !!s.multiple, h, !1) : d !== !!s.multiple && (s.defaultValue != null ? Ci(r, !!s.multiple, s.defaultValue, !0) : Ci(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[Hr] = s } catch (v) { ct(t, t.return, v) } } break; case 6: if (he(e, t), ke(t), i & 4) { if (t.stateNode === null) throw Error(C(162)); r = t.stateNode, s = t.memoizedProps; try { r.nodeValue = s } catch (v) { ct(t, t.return, v) } } break; case 3: if (he(e, t), ke(t), i & 4 && n !== null && n.memoizedState.isDehydrated) try { zr(e.containerInfo) } catch (v) { ct(t, t.return, v) } break; case 4: he(e, t), ke(t); break; case 13: he(e, t), ke(t), r = t.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (kc = pt())), i & 4 && ad(t); break; case 22: if (c = n !== null && n.memoizedState !== null, t.mode & 1 ? (Lt = (u = Lt) || c, he(e, t), Lt = u) : he(e, t), ke(t), i & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !c && (t.mode & 1) !== 0) for (T = t, c = t.child; c !== null;) { for (f = T = c; T !== null;) { switch (d = T, h = d.child, d.tag) { case 0: case 11: case 14: case 15: wr(4, d, d.return); break; case 1: xi(d, d.return); var g = d.stateNode; if (typeof g.componentWillUnmount == "function") { i = d, n = d.return; try { e = i, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (v) { ct(i, n, v) } } break; case 5: xi(d, d.return); break; case 22: if (d.memoizedState !== null) { ud(f); continue } }h !== null ? (h.return = d, T = h) : ud(f) } c = c.sibling } t: for (c = null, f = t; ;) { if (f.tag === 5) { if (c === null) { c = f; try { r = f.stateNode, u ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Ep("display", o)) } catch (v) { ct(t, t.return, v) } } } else if (f.tag === 6) { if (c === null) try { f.stateNode.nodeValue = u ? "" : f.memoizedProps } catch (v) { ct(t, t.return, v) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === t) break t; for (; f.sibling === null;) { if (f.return === null || f.return === t) break t; c === f && (c = null), f = f.return } c === f && (c = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: he(e, t), ke(t), i & 4 && ad(t); break; case 21: break; default: he(e, t), ke(t) } } function ke(t) { var e = t.flags; if (e & 2) { try { t: { for (var n = t.return; n !== null;) { if (eg(n)) { var i = n; break t } n = n.return } throw Error(C(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (Ar(r, ""), i.flags &= -33); var s = od(t); au(t, s, r); break; case 3: case 4: var o = i.stateNode.containerInfo, a = od(t); ou(t, a, o); break; default: throw Error(C(161)) } } catch (l) { ct(t, t.return, l) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function qy(t, e, n) { T = t, rg(t) } function rg(t, e, n) { for (var i = (t.mode & 1) !== 0; T !== null;) { var r = T, s = r.child; if (r.tag === 22 && i) { var o = r.memoizedState !== null || Ts; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || Lt; a = Ts; var u = Lt; if (Ts = o, (Lt = l) && !u) for (T = r; T !== null;)o = T, l = o.child, o.tag === 22 && o.memoizedState !== null ? cd(r) : l !== null ? (l.return = o, T = l) : cd(r); for (; s !== null;)T = s, rg(s), s = s.sibling; T = r, Ts = a, Lt = u } ld(t) } else (r.subtreeFlags & 8772) !== 0 && s !== null ? (s.return = r, T = s) : ld(t) } } function ld(t) { for (; T !== null;) { var e = T; if ((e.flags & 8772) !== 0) { var n = e.alternate; try { if ((e.flags & 8772) !== 0) switch (e.tag) { case 0: case 11: case 15: Lt || va(5, e); break; case 1: var i = e.stateNode; if (e.flags & 4 && !Lt) if (n === null) i.componentDidMount(); else { var r = e.elementType === e.type ? n.memoizedProps : pe(e.type, n.memoizedProps); i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && Uf(e, s, i); break; case 3: var o = e.updateQueue; if (o !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }Uf(e, o, n) } break; case 5: var a = e.stateNode; if (n === null && e.flags & 4) { n = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var f = c.dehydrated; f !== null && zr(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(C(163)) }Lt || e.flags & 512 && su(e) } catch (d) { ct(e, e.return, d) } } if (e === t) { T = null; break } if (n = e.sibling, n !== null) { n.return = e.return, T = n; break } T = e.return } } function ud(t) { for (; T !== null;) { var e = T; if (e === t) { T = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, T = n; break } T = e.return } } function cd(t) { for (; T !== null;) { var e = T; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { va(4, e) } catch (l) { ct(e, n, l) } break; case 1: var i = e.stateNode; if (typeof i.componentDidMount == "function") { var r = e.return; try { i.componentDidMount() } catch (l) { ct(e, r, l) } } var s = e.return; try { su(e) } catch (l) { ct(e, s, l) } break; case 5: var o = e.return; try { su(e) } catch (l) { ct(e, o, l) } } } catch (l) { ct(e, e.return, l) } if (e === t) { T = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, T = a; break } T = e.return } } var Jy = Math.ceil, Ho = Ge.ReactCurrentDispatcher, bc = Ge.ReactCurrentOwner, ce = Ge.ReactCurrentBatchConfig, $ = 0, kt = null, gt = null, Ct = 0, Qt = 0, _i = On(0), yt = 0, Xr = null, qn = 0, ya = 0, wc = 0, kr = null, jt = null, kc = 0, Bi = 1 / 0, ze = null, Wo = !1, lu = null, yn = null, Ls = !1, an = null, $o = 0, Sr = 0, uu = null, fo = -1, ho = 0; function It() { return ($ & 6) !== 0 ? pt() : fo !== -1 ? fo : fo = pt() } function xn(t) { return (t.mode & 1) === 0 ? 1 : ($ & 2) !== 0 && Ct !== 0 ? Ct & -Ct : zy.transition !== null ? (ho === 0 && (ho = Hp()), ho) : (t = U, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Kp(t.type)), t) } function xe(t, e, n, i) { if (50 < Sr) throw Sr = 0, uu = null, Error(C(185)); os(t, n, i), (($ & 2) === 0 || t !== kt) && (t === kt && (($ & 2) === 0 && (ya |= n), yt === 4 && sn(t, Ct)), Ut(t, i), n === 1 && $ === 0 && (e.mode & 1) === 0 && (Bi = pt() + 500, pa && Tn())) } function Ut(t, e) { var n = t.callbackNode; zv(t, e); var i = Po(t, t === kt ? Ct : 0); if (i === 0) n !== null && xf(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = i & -i, t.callbackPriority !== e) { if (n != null && xf(n), e === 1) t.tag === 0 ? Iy(fd.bind(null, t)) : hm(fd.bind(null, t)), Ly(function () { ($ & 6) === 0 && Tn() }), n = null; else { switch (Wp(i)) { case 1: n = Qu; break; case 4: n = jp; break; case 16: n = Co; break; case 536870912: n = Bp; break; default: n = Co }n = dg(n, sg.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function sg(t, e) { if (fo = -1, ho = 0, ($ & 6) !== 0) throw Error(C(327)); var n = t.callbackNode; if (Ti() && t.callbackNode !== n) return null; var i = Po(t, t === kt ? Ct : 0); if (i === 0) return null; if ((i & 30) !== 0 || (i & t.expiredLanes) !== 0 || e) e = Vo(t, i); else { e = i; var r = $; $ |= 2; var s = ag(); (kt !== t || Ct !== e) && (ze = null, Bi = pt() + 500, Yn(t, e)); do try { n1(); break } catch (a) { og(t, a) } while (1); lc(), Ho.current = s, $ = r, gt !== null ? e = 0 : (kt = null, Ct = 0, e = yt) } if (e !== 0) { if (e === 2 && (r = zl(t), r !== 0 && (i = r, e = cu(t, r))), e === 1) throw n = Xr, Yn(t, 0), sn(t, i), Ut(t, pt()), n; if (e === 6) sn(t, i); else { if (r = t.current.alternate, (i & 30) === 0 && !t1(r) && (e = Vo(t, i), e === 2 && (s = zl(t), s !== 0 && (i = s, e = cu(t, s))), e === 1)) throw n = Xr, Yn(t, 0), sn(t, i), Ut(t, pt()), n; switch (t.finishedWork = r, t.finishedLanes = i, e) { case 0: case 1: throw Error(C(345)); case 2: Rn(t, jt, ze); break; case 3: if (sn(t, i), (i & 130023424) === i && (e = kc + 500 - pt(), 10 < e)) { if (Po(t, 0) !== 0) break; if (r = t.suspendedLanes, (r & i) !== i) { It(), t.pingedLanes |= t.suspendedLanes & r; break } t.timeoutHandle = Vl(Rn.bind(null, t, jt, ze), e); break } Rn(t, jt, ze); break; case 4: if (sn(t, i), (i & 4194240) === i) break; for (e = t.eventTimes, r = -1; 0 < i;) { var o = 31 - ye(i); s = 1 << o, o = e[o], o > r && (r = o), i &= ~s } if (i = r, i = pt() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * Jy(i / 1960)) - i, 10 < i) { t.timeoutHandle = Vl(Rn.bind(null, t, jt, ze), i); break } Rn(t, jt, ze); break; case 5: Rn(t, jt, ze); break; default: throw Error(C(329)) } } } return Ut(t, pt()), t.callbackNode === n ? sg.bind(null, t) : null } function cu(t, e) { var n = kr; return t.current.memoizedState.isDehydrated && (Yn(t, e).flags |= 256), t = Vo(t, e), t !== 2 && (e = jt, jt = n, e !== null && fu(e)), t } function fu(t) { jt === null ? jt = t : jt.push.apply(jt, t) } function t1(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var i = 0; i < n.length; i++) { var r = n[i], s = r.getSnapshot; r = r.value; try { if (!_e(s(), r)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function sn(t, e) { for (e &= ~wc, e &= ~ya, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - ye(e), i = 1 << n; t[n] = -1, e &= ~i } } function fd(t) { if (($ & 6) !== 0) throw Error(C(327)); Ti(); var e = Po(t, 0); if ((e & 1) === 0) return Ut(t, pt()), null; var n = Vo(t, e); if (t.tag !== 0 && n === 2) { var i = zl(t); i !== 0 && (e = i, n = cu(t, i)) } if (n === 1) throw n = Xr, Yn(t, 0), sn(t, e), Ut(t, pt()), n; if (n === 6) throw Error(C(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, Rn(t, jt, ze), Ut(t, pt()), null } function Sc(t, e) { var n = $; $ |= 1; try { return t(e) } finally { $ = n, $ === 0 && (Bi = pt() + 500, pa && Tn()) } } function Jn(t) { an !== null && an.tag === 0 && ($ & 6) === 0 && Ti(); var e = $; $ |= 1; var n = ce.transition, i = U; try { if (ce.transition = null, U = 1, t) return t() } finally { U = i, ce.transition = n, $ = e, ($ & 6) === 0 && Tn() } } function Cc() { Qt = _i.current, nt(_i) } function Yn(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, Ty(n)), gt !== null) for (n = gt.return; n !== null;) { var i = n; switch (sc(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && Lo(); break; case 3: Fi(), nt($t), nt(At), pc(); break; case 5: hc(i); break; case 4: Fi(); break; case 13: nt(ot); break; case 19: nt(ot); break; case 10: uc(i.type._context); break; case 22: case 23: Cc() }n = n.return } if (kt = t, gt = t = _n(t.current, null), Ct = Qt = e, yt = 0, Xr = null, wc = ya = qn = 0, jt = kr = null, Hn !== null) { for (e = 0; e < Hn.length; e++)if (n = Hn[e], i = n.interleaved, i !== null) { n.interleaved = null; var r = i.next, s = n.pending; if (s !== null) { var o = s.next; s.next = r, i.next = o } n.pending = i } Hn = null } return t } function og(t, e) { do { var n = gt; try { if (lc(), lo.current = Bo, jo) { for (var i = at.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } jo = !1 } if (Zn = 0, wt = vt = at = null, br = !1, Vr = 0, bc.current = null, n === null || n.return === null) { yt = 1, Xr = e, gt = null; break } t: { var s = t, o = n.return, a = n, l = e; if (e = Ct, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, f = c.tag; if ((c.mode & 1) === 0 && (f === 0 || f === 11 || f === 15)) { var d = c.alternate; d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null) } var h = qf(o); if (h !== null) { h.flags &= -257, Jf(h, o, a, s, e), h.mode & 1 && Zf(s, u, e), e = h, l = u; var g = e.updateQueue; if (g === null) { var v = new Set; v.add(l), e.updateQueue = v } else g.add(l); break t } else { if ((e & 1) === 0) { Zf(s, u, e), Pc(); break t } l = Error(C(426)) } } else if (rt && a.mode & 1) { var x = qf(o); if (x !== null) { (x.flags & 65536) === 0 && (x.flags |= 256), Jf(x, o, a, s, e), oc(ji(l, a)); break t } } s = l = ji(l, a), yt !== 4 && (yt = 2), kr === null ? kr = [s] : kr.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var m = $m(s, l, e); Vf(s, m); break t; case 1: a = l; var p = s.type, y = s.stateNode; if ((s.flags & 128) === 0 && (typeof p.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (yn === null || !yn.has(y)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var _ = Vm(s, a, e); Vf(s, _); break t } }s = s.return } while (s !== null) } ug(n) } catch (b) { e = b, gt === n && n !== null && (gt = n = n.return); continue } break } while (1) } function ag() { var t = Ho.current; return Ho.current = Bo, t === null ? Bo : t } function Pc() { (yt === 0 || yt === 3 || yt === 2) && (yt = 4), kt === null || (qn & 268435455) === 0 && (ya & 268435455) === 0 || sn(kt, Ct) } function Vo(t, e) { var n = $; $ |= 2; var i = ag(); (kt !== t || Ct !== e) && (ze = null, Yn(t, e)); do try { e1(); break } catch (r) { og(t, r) } while (1); if (lc(), $ = n, Ho.current = i, gt !== null) throw Error(C(261)); return kt = null, Ct = 0, yt } function e1() { for (; gt !== null;)lg(gt) } function n1() { for (; gt !== null && !Mv();)lg(gt) } function lg(t) { var e = fg(t.alternate, t, Qt); t.memoizedProps = t.pendingProps, e === null ? ug(t) : gt = e, bc.current = null } function ug(t) { var e = t; do { var n = e.alternate; if (t = e.return, (e.flags & 32768) === 0) { if (n = Ky(n, e, Qt), n !== null) { gt = n; return } } else { if (n = Qy(n, e), n !== null) { n.flags &= 32767, gt = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { yt = 6, gt = null; return } } if (e = e.sibling, e !== null) { gt = e; return } gt = e = t } while (e !== null); yt === 0 && (yt = 5) } function Rn(t, e, n) { var i = U, r = ce.transition; try { ce.transition = null, U = 1, i1(t, e, n, i) } finally { ce.transition = r, U = i } return null } function i1(t, e, n, i) { do Ti(); while (an !== null); if (($ & 6) !== 0) throw Error(C(327)); n = t.finishedWork; var r = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(C(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (Rv(t, s), t === kt && (gt = kt = null, Ct = 0), (n.subtreeFlags & 2064) === 0 && (n.flags & 2064) === 0 || Ls || (Ls = !0, dg(Co, function () { return Ti(), null })), s = (n.flags & 15990) !== 0, (n.subtreeFlags & 15990) !== 0 || s) { s = ce.transition, ce.transition = null; var o = U; U = 1; var a = $; $ |= 4, bc.current = null, Zy(t, n), ig(n, t), ky(Wl), Mo = !!Hl, Wl = Hl = null, t.current = n, qy(n), Ev(), $ = a, U = o, ce.transition = s } else t.current = n; if (Ls && (Ls = !1, an = t, $o = r), s = t.pendingLanes, s === 0 && (yn = null), Lv(n.stateNode), Ut(t, pt()), e !== null) for (i = t.onRecoverableError, n = 0; n < e.length; n++)r = e[n], i(r.value, { componentStack: r.stack, digest: r.digest }); if (Wo) throw Wo = !1, t = lu, lu = null, t; return ($o & 1) !== 0 && t.tag !== 0 && Ti(), s = t.pendingLanes, (s & 1) !== 0 ? t === uu ? Sr++ : (Sr = 0, uu = t) : Sr = 0, Tn(), null } function Ti() { if (an !== null) { var t = Wp($o), e = ce.transition, n = U; try { if (ce.transition = null, U = 16 > t ? 16 : t, an === null) var i = !1; else { if (t = an, an = null, $o = 0, ($ & 6) !== 0) throw Error(C(331)); var r = $; for ($ |= 4, T = t.current; T !== null;) { var s = T, o = s.child; if ((T.flags & 16) !== 0) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (T = u; T !== null;) { var c = T; switch (c.tag) { case 0: case 11: case 15: wr(8, c, s) }var f = c.child; if (f !== null) f.return = c, T = f; else for (; T !== null;) { c = T; var d = c.sibling, h = c.return; if (tg(c), c === u) { T = null; break } if (d !== null) { d.return = h, T = d; break } T = h } } } var g = s.alternate; if (g !== null) { var v = g.child; if (v !== null) { g.child = null; do { var x = v.sibling; v.sibling = null, v = x } while (v !== null) } } T = s } } if ((s.subtreeFlags & 2064) !== 0 && o !== null) o.return = s, T = o; else t: for (; T !== null;) { if (s = T, (s.flags & 2048) !== 0) switch (s.tag) { case 0: case 11: case 15: wr(9, s, s.return) }var m = s.sibling; if (m !== null) { m.return = s.return, T = m; break t } T = s.return } } var p = t.current; for (T = p; T !== null;) { o = T; var y = o.child; if ((o.subtreeFlags & 2064) !== 0 && y !== null) y.return = o, T = y; else t: for (o = p; T !== null;) { if (a = T, (a.flags & 2048) !== 0) try { switch (a.tag) { case 0: case 11: case 15: va(9, a) } } catch (b) { ct(a, a.return, b) } if (a === o) { T = null; break t } var _ = a.sibling; if (_ !== null) { _.return = a.return, T = _; break t } T = a.return } } if ($ = r, Tn(), Oe && typeof Oe.onPostCommitFiberRoot == "function") try { Oe.onPostCommitFiberRoot(ua, t) } catch { } i = !0 } return i } finally { U = n, ce.transition = e } } return !1 } function dd(t, e, n) { e = ji(n, e), e = $m(t, e, 1), t = vn(t, e, 1), e = It(), t !== null && (os(t, 1, e), Ut(t, e)) } function ct(t, e, n) { if (t.tag === 3) dd(t, t, n); else for (; e !== null;) { if (e.tag === 3) { dd(e, t, n); break } else if (e.tag === 1) { var i = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (yn === null || !yn.has(i))) { t = ji(n, t), t = Vm(e, t, 1), e = vn(e, t, 1), t = It(), e !== null && (os(e, 1, t), Ut(e, t)); break } } e = e.return } } function r1(t, e, n) { var i = t.pingCache; i !== null && i.delete(e), e = It(), t.pingedLanes |= t.suspendedLanes & n, kt === t && (Ct & n) === n && (yt === 4 || yt === 3 && (Ct & 130023424) === Ct && 500 > pt() - kc ? Yn(t, 0) : wc |= n), Ut(t, e) } function cg(t, e) { e === 0 && ((t.mode & 1) === 0 ? e = 1 : (e = bs, bs <<= 1, (bs & 130023424) === 0 && (bs = 4194304))); var n = It(); t = Ve(t, e), t !== null && (os(t, e, n), Ut(t, n)) } function s1(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), cg(t, n) } function o1(t, e) { var n = 0; switch (t.tag) { case 13: var i = t.stateNode, r = t.memoizedState; r !== null && (n = r.retryLane); break; case 19: i = t.stateNode; break; default: throw Error(C(314)) }i !== null && i.delete(e), cg(t, n) } var fg; fg = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || $t.current) Ht = !0; else { if ((t.lanes & n) === 0 && (e.flags & 128) === 0) return Ht = !1, Xy(t, e, n); Ht = (t.flags & 131072) !== 0 } else Ht = !1, rt && (e.flags & 1048576) !== 0 && pm(e, No, e.index); switch (e.lanes = 0, e.tag) { case 2: var i = e.type; co(t, e), t = e.pendingProps; var r = Ii(e, At.current); Oi(e, n), r = gc(null, e, i, t, r, n); var s = vc(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Vt(i) ? (s = !0, Ao(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, fc(e), r.updater = ma, e.stateNode = r, r._reactInternals = e, Zl(e, i, t, n), e = tu(null, e, i, !0, s, n)) : (e.tag = 0, rt && s && rc(e), Nt(null, e, r, n), e = e.child), e; case 16: i = e.elementType; t: { switch (co(t, e), t = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = l1(i), t = pe(i, t), r) { case 0: e = Jl(null, e, i, t, n); break t; case 1: e = nd(null, e, i, t, n); break t; case 11: e = td(null, e, i, t, n); break t; case 14: e = ed(null, e, i, pe(i.type, t), n); break t }throw Error(C(306, i, "")) } return e; case 0: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : pe(i, r), Jl(t, e, i, r, n); case 1: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : pe(i, r), nd(t, e, i, r, n); case 3: t: { if (Km(e), t === null) throw Error(C(387)); i = e.pendingProps, s = e.memoizedState, r = s.element, ym(t, e), Ro(e, i, null, n); var o = e.memoizedState; if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { r = ji(Error(C(423)), e), e = id(t, e, i, n, r); break t } else if (i !== r) { r = ji(Error(C(424)), e), e = id(t, e, i, n, r); break t } else for (Zt = gn(e.stateNode.containerInfo.firstChild), qt = e, rt = !0, ge = null, n = wm(e, null, i, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (zi(), i === r) { e = Ue(t, e, n); break t } Nt(t, e, i, n) } e = e.child } return e; case 5: return km(e), t === null && Kl(e), i = e.type, r = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = r.children, $l(i, r) ? o = null : s !== null && $l(i, s) && (e.flags |= 32), Xm(t, e), Nt(t, e, o, n), e.child; case 6: return t === null && Kl(e), null; case 13: return Qm(t, e, n); case 4: return dc(e, e.stateNode.containerInfo), i = e.pendingProps, t === null ? e.child = Ri(e, null, i, n) : Nt(t, e, i, n), e.child; case 11: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : pe(i, r), td(t, e, i, r, n); case 7: return Nt(t, e, e.pendingProps, n), e.child; case 8: return Nt(t, e, e.pendingProps.children, n), e.child; case 12: return Nt(t, e, e.pendingProps.children, n), e.child; case 10: t: { if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, G(Io, i._currentValue), i._currentValue = o, s !== null) if (_e(s.value, o)) { if (s.children === r.children && !$t.current) { e = Ue(t, e, n); break t } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === i) { if (s.tag === 1) { l = He(-1, n & -n), l.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Ql(s.return, n, e), a.lanes |= n; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(C(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Ql(o, n, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } Nt(t, e, r.children, n), e = e.child } return e; case 9: return r = e.type, i = e.pendingProps.children, Oi(e, n), r = fe(r), i = i(r), e.flags |= 1, Nt(t, e, i, n), e.child; case 14: return i = e.type, r = pe(i, e.pendingProps), r = pe(i.type, r), ed(t, e, i, r, n); case 15: return Um(t, e, e.type, e.pendingProps, n); case 17: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : pe(i, r), co(t, e), e.tag = 1, Vt(i) ? (t = !0, Ao(e)) : t = !1, Oi(e, n), _m(e, i, r), Zl(e, i, r, n), tu(null, e, i, !0, t, n); case 19: return Gm(t, e, n); case 22: return Ym(t, e, n) }throw Error(C(156, e.tag)) }; function dg(t, e) { return Fp(t, e) } function a1(t, e, n, i) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ae(t, e, n, i) { return new a1(t, e, n, i) } function Mc(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function l1(t) { if (typeof t == "function") return Mc(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Yu) return 11; if (t === Xu) return 14 } return 2 } function _n(t, e) { var n = t.alternate; return n === null ? (n = ae(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function po(t, e, n, i, r, s) { var o = 2; if (i = t, typeof t == "function") Mc(t) && (o = 1); else if (typeof t == "string") o = 5; else t: switch (t) { case ci: return Xn(n.children, r, s, e); case Uu: o = 8, r |= 8; break; case bl: return t = ae(12, n, e, r | 2), t.elementType = bl, t.lanes = s, t; case wl: return t = ae(13, n, e, r), t.elementType = wl, t.lanes = s, t; case kl: return t = ae(19, n, e, r), t.elementType = kl, t.lanes = s, t; case bp: return xa(n, r, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case xp: o = 10; break t; case _p: o = 9; break t; case Yu: o = 11; break t; case Xu: o = 14; break t; case en: o = 16, i = null; break t }throw Error(C(130, t == null ? t : typeof t, "")) }return e = ae(o, n, e, r), e.elementType = t, e.type = i, e.lanes = s, e } function Xn(t, e, n, i) { return t = ae(7, t, i, e), t.lanes = n, t } function xa(t, e, n, i) { return t = ae(22, t, i, e), t.elementType = bp, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function il(t, e, n) { return t = ae(6, t, null, e), t.lanes = n, t } function rl(t, e, n) { return e = ae(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function u1(t, e, n, i, r) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Fa(0), this.expirationTimes = Fa(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Fa(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function Ec(t, e, n, i, r, s, o, a, l) { return t = new u1(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = ae(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: i, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, fc(s), t } function c1(t, e, n) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: ui, key: i == null ? null : "" + i, children: t, containerInfo: e, implementation: n } } function hg(t) { if (!t) return kn; t = t._reactInternals; t: { if (si(t) !== t || t.tag !== 1) throw Error(C(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break t; case 1: if (Vt(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break t } }e = e.return } while (e !== null); throw Error(C(171)) } if (t.tag === 1) { var n = t.type; if (Vt(n)) return dm(t, n, e) } return e } function pg(t, e, n, i, r, s, o, a, l) { return t = Ec(n, i, !0, t, r, s, o, a, l), t.context = hg(null), n = t.current, i = It(), r = xn(n), s = He(i, r), s.callback = e ?? null, vn(n, s, r), t.current.lanes = r, os(t, r, i), Ut(t, i), t } function _a(t, e, n, i) { var r = e.current, s = It(), o = xn(r); return n = hg(n), e.context === null ? e.context = n : e.pendingContext = n, e = He(s, o), e.payload = { element: t }, i = i === void 0 ? null : i, i !== null && (e.callback = i), t = vn(r, e, o), t !== null && (xe(t, r, o, s), ao(t, r, o)), o } function Uo(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function hd(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function Oc(t, e) { hd(t, e), (t = t.alternate) && hd(t, e) } function f1() { return null } var mg = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Tc(t) { this._internalRoot = t } ba.prototype.render = Tc.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(C(409)); _a(t, e, null, null) }; ba.prototype.unmount = Tc.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Jn(function () { _a(null, t, null, null) }), e[$e] = null } }; function ba(t) { this._internalRoot = t } ba.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Up(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < rn.length && e !== 0 && e < rn[n].priority; n++); rn.splice(n, 0, t), n === 0 && Xp(t) } }; function Lc(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function wa(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function pd() { } function d1(t, e, n, i, r) { if (r) { if (typeof i == "function") { var s = i; i = function () { var u = Uo(o); s.call(u) } } var o = pg(e, i, t, 0, null, !1, !1, "", pd); return t._reactRootContainer = o, t[$e] = o.current, jr(t.nodeType === 8 ? t.parentNode : t), Jn(), o } for (; r = t.lastChild;)t.removeChild(r); if (typeof i == "function") { var a = i; i = function () { var u = Uo(l); a.call(u) } } var l = Ec(t, 0, !1, null, null, !1, !1, "", pd); return t._reactRootContainer = l, t[$e] = l.current, jr(t.nodeType === 8 ? t.parentNode : t), Jn(function () { _a(e, l, n, i) }), l } function ka(t, e, n, i, r) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = Uo(o); a.call(l) } } _a(e, o, t, r) } else o = d1(n, e, t, r, i); return Uo(o) } $p = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = cr(e.pendingLanes); n !== 0 && (Gu(e, n | 1), Ut(e, pt()), ($ & 6) === 0 && (Bi = pt() + 500, Tn())) } break; case 13: Jn(function () { var i = Ve(t, 1); if (i !== null) { var r = It(); xe(i, t, 1, r) } }), Oc(t, 1) } }; Zu = function (t) { if (t.tag === 13) { var e = Ve(t, 134217728); if (e !== null) { var n = It(); xe(e, t, 134217728, n) } Oc(t, 134217728) } }; Vp = function (t) { if (t.tag === 13) { var e = xn(t), n = Ve(t, e); if (n !== null) { var i = It(); xe(n, t, e, i) } Oc(t, e) } }; Up = function () { return U }; Yp = function (t, e) { var n = U; try { return U = t, e() } finally { U = n } }; Dl = function (t, e, n) { switch (e) { case "input": if (Pl(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var i = n[e]; if (i !== t && i.form === t.form) { var r = ha(i); if (!r) throw Error(C(90)); kp(i), Pl(i, r) } } } break; case "textarea": Cp(t, n); break; case "select": e = n.value, e != null && Ci(t, !!n.multiple, e, !1) } }; Ap = Sc; Dp = Jn; var h1 = { usingClientEntryPoint: !1, Events: [ls, pi, ha, Tp, Lp, Sc] }, nr = { findFiberByHostInstance: Bn, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, p1 = { bundleType: nr.bundleType, version: nr.version, rendererPackageName: nr.rendererPackageName, rendererConfig: nr.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ge.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = zp(t), t === null ? null : t.stateNode }, findFiberByHostInstance: nr.findFiberByHostInstance || f1, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var As = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!As.isDisabled && As.supportsFiber) try { ua = As.inject(p1), Oe = As } catch { } } ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = h1; ee.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Lc(e)) throw Error(C(200)); return c1(t, e, null, n) }; ee.createRoot = function (t, e) { if (!Lc(t)) throw Error(C(299)); var n = !1, i = "", r = mg; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = Ec(t, 1, !1, null, null, n, !1, i, r), t[$e] = e.current, jr(t.nodeType === 8 ? t.parentNode : t), new Tc(e) }; ee.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(C(188)) : (t = Object.keys(t).join(","), Error(C(268, t))); return t = zp(e), t = t === null ? null : t.stateNode, t }; ee.flushSync = function (t) { return Jn(t) }; ee.hydrate = function (t, e, n) { if (!wa(e)) throw Error(C(200)); return ka(null, t, e, !0, n) }; ee.hydrateRoot = function (t, e, n) { if (!Lc(t)) throw Error(C(405)); var i = n != null && n.hydratedSources || null, r = !1, s = "", o = mg; if (n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = pg(e, null, t, 1, n ?? null, r, !1, s, o), t[$e] = e.current, jr(t), i) for (t = 0; t < i.length; t++)n = i[t], r = n._getVersion, r = r(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, r] : e.mutableSourceEagerHydrationData.push(n, r); return new ba(e) }; ee.render = function (t, e, n) { if (!wa(e)) throw Error(C(200)); return ka(null, t, e, !1, n) }; ee.unmountComponentAtNode = function (t) { if (!wa(t)) throw Error(C(40)); return t._reactRootContainer ? (Jn(function () { ka(null, null, t, !1, function () { t._reactRootContainer = null, t[$e] = null }) }), !0) : !1 }; ee.unstable_batchedUpdates = Sc; ee.unstable_renderSubtreeIntoContainer = function (t, e, n, i) { if (!wa(n)) throw Error(C(200)); if (t == null || t._reactInternals === void 0) throw Error(C(38)); return ka(t, e, n, !1, i) }; ee.version = "18.2.0-next-9e3b772b8-20220608"; (function (t) { function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (n) { console.error(n) } } e(), t.exports = ee })(pp); var md = pp.exports; xl.createRoot = md.createRoot, xl.hydrateRoot = md.hydrateRoot; const m1 = ({ setCity: t, toggle: e }) => { const [n, i] = J.exports.useState(""); return H("div", { className: "search-bar", children: H("div", { className: "omrs-input-group", children: H("form", { onSubmit: s => { s.preventDefault(), t(n) }, children: dt("label", { className: "omrs-input-underlined", children: [H("input", { type: "text", name: "Location", value: n, required: !0, onChange: s => i(s.target.value), style: { background: e ? "#2f8a91;" : "rgba(17, 51, 101, 0.425)" } }), H("span", { className: "omrs-input-label", children: "Location" }), H("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 384 512", children: H("path", { d: "M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 256c-35.3 0-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64s-28.7 64-64 64z" }) })] }) }) }) }) }; function gd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(t, r).enumerable })), n.push.apply(n, i) } return n } function O(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? gd(Object(n), !0).forEach(function (i) { _t(t, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : gd(Object(n)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i)) }) } return t } function Yo(t) { return Yo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Yo(t) } function g1(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function vd(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function v1(t, e, n) { return e && vd(t.prototype, e), n && vd(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function _t(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ac(t, e) { return x1(t) || b1(t, e) || gg(t, e) || k1() } function cs(t) { return y1(t) || _1(t) || gg(t) || w1() } function y1(t) { if (Array.isArray(t)) return du(t) } function x1(t) { if (Array.isArray(t)) return t } function _1(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function b1(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var i = [], r = !0, s = !1, o, a; try { for (n = n.call(t); !(r = (o = n.next()).done) && (i.push(o.value), !(e && i.length === e)); r = !0); } catch (l) { s = !0, a = l } finally { try { !r && n.return != null && n.return() } finally { if (s) throw a } } return i } } function gg(t, e) { if (!!t) { if (typeof t == "string") return du(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return du(t, e) } } function du(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } function w1() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function k1() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} var yd = function () { }, Dc = {}, vg = {}, yg = null, xg = { mark: yd, measure: yd }; try { typeof window < "u" && (Dc = window), typeof document < "u" && (vg = document), typeof MutationObserver < "u" && (yg = MutationObserver), typeof performance < "u" && (xg = performance) } catch { } var S1 = Dc.navigator || {}, xd = S1.userAgent, _d = xd === void 0 ? "" : xd, Sn = Dc, it = vg, bd = yg, Ds = xg; Sn.document; var Ze = !!it.documentElement && !!it.head && typeof it.addEventListener == "function" && typeof it.createElement == "function", _g = ~_d.indexOf("MSIE") || ~_d.indexOf("Trident/"), Ns, Is, zs, Rs, Fs, Ye = "___FONT_AWESOME___", hu = 16, bg = "fa", wg = "svg-inline--fa", ti = "data-fa-i2svg", pu = "data-fa-pseudo-element", C1 = "data-fa-pseudo-element-pending", Nc = "data-prefix", Ic = "data-icon", wd = "fontawesome-i2svg", P1 = "async", M1 = ["HTML", "HEAD", "STYLE", "SCRIPT"], kg = function () { try { return !0 } catch { return !1 } }(), tt = "classic", ft = "sharp", zc = [tt, ft]; function fs(t) { return new Proxy(t, { get: function (n, i) { return i in n ? n[i] : n[tt] } }) } var Kr = fs((Ns = {}, _t(Ns, tt, { fa: "solid", fas: "solid", "fa-solid": "solid", far: "regular", "fa-regular": "regular", fal: "light", "fa-light": "light", fat: "thin", "fa-thin": "thin", fad: "duotone", "fa-duotone": "duotone", fab: "brands", "fa-brands": "brands", fak: "kit", "fa-kit": "kit" }), _t(Ns, ft, { fa: "solid", fass: "solid", "fa-solid": "solid" }), Ns)), Qr = fs((Is = {}, _t(Is, tt, { solid: "fas", regular: "far", light: "fal", thin: "fat", duotone: "fad", brands: "fab", kit: "fak" }), _t(Is, ft, { solid: "fass" }), Is)), Gr = fs((zs = {}, _t(zs, tt, { fab: "fa-brands", fad: "fa-duotone", fak: "fa-kit", fal: "fa-light", far: "fa-regular", fas: "fa-solid", fat: "fa-thin" }), _t(zs, ft, { fass: "fa-solid" }), zs)), E1 = fs((Rs = {}, _t(Rs, tt, { "fa-brands": "fab", "fa-duotone": "fad", "fa-kit": "fak", "fa-light": "fal", "fa-regular": "far", "fa-solid": "fas", "fa-thin": "fat" }), _t(Rs, ft, { "fa-solid": "fass" }), Rs)), O1 = /fa(s|r|l|t|d|b|k|ss)?[\-\ ]/, Sg = "fa-layers-text", T1 = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i, L1 = fs((Fs = {}, _t(Fs, tt, { 900: "fas", 400: "far", normal: "far", 300: "fal", 100: "fat" }), _t(Fs, ft, { 900: "fass" }), Fs)), Cg = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], A1 = Cg.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), D1 = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], $n = { GROUP: "duotone-group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" }, Zr = new Set; Object.keys(Qr[tt]).map(Zr.add.bind(Zr)); Object.keys(Qr[ft]).map(Zr.add.bind(Zr)); var N1 = [].concat(zc, cs(Zr), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", $n.GROUP, $n.SWAP_OPACITY, $n.PRIMARY, $n.SECONDARY]).concat(Cg.map(function (t) { return "".concat(t, "x") })).concat(A1.map(function (t) { return "w-".concat(t) })), Cr = Sn.FontAwesomeConfig || {}; function I1(t) { var e = it.querySelector("script[" + t + "]"); if (e) return e.getAttribute(t) } function z1(t) { return t === "" ? !0 : t === "false" ? !1 : t === "true" ? !0 : t } if (it && typeof it.querySelector == "function") { var R1 = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]]; R1.forEach(function (t) { var e = Ac(t, 2), n = e[0], i = e[1], r = z1(I1(n)); r != null && (Cr[i] = r) }) } var Pg = { styleDefault: "solid", familyDefault: "classic", cssPrefix: bg, replacementClass: wg, autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, mutateApproach: "async", keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0 }; Cr.familyPrefix && (Cr.cssPrefix = Cr.familyPrefix); var Hi = O(O({}, Pg), Cr); Hi.autoReplaceSvg || (Hi.observeMutations = !1); var L = {}; Object.keys(Pg).forEach(function (t) { Object.defineProperty(L, t, { enumerable: !0, set: function (n) { Hi[t] = n, Pr.forEach(function (i) { return i(L) }) }, get: function () { return Hi[t] } }) }); Object.defineProperty(L, "familyPrefix", { enumerable: !0, set: function (e) { Hi.cssPrefix = e, Pr.forEach(function (n) { return n(L) }) }, get: function () { return Hi.cssPrefix } }); Sn.FontAwesomeConfig = L; var Pr = []; function F1(t) { return Pr.push(t), function () { Pr.splice(Pr.indexOf(t), 1) } } var Je = hu, Ee = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 }; function j1(t) { if (!(!t || !Ze)) { var e = it.createElement("style"); e.setAttribute("type", "text/css"), e.innerHTML = t; for (var n = it.head.childNodes, i = null, r = n.length - 1; r > -1; r--) { var s = n[r], o = (s.tagName || "").toUpperCase();["STYLE", "LINK"].indexOf(o) > -1 && (i = s) } return it.head.insertBefore(e, i), t } } var B1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; function qr() { for (var t = 12, e = ""; t-- > 0;)e += B1[Math.random() * 62 | 0]; return e } function Ki(t) { for (var e = [], n = (t || []).length >>> 0; n--;)e[n] = t[n]; return e } function Rc(t) { return t.classList ? Ki(t.classList) : (t.getAttribute("class") || "").split(" ").filter(function (e) { return e }) } function Mg(t) { return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function H1(t) { return Object.keys(t || {}).reduce(function (e, n) { return e + "".concat(n, '="').concat(Mg(t[n]), '" ') }, "").trim() } function Sa(t) { return Object.keys(t || {}).reduce(function (e, n) { return e + "".concat(n, ": ").concat(t[n].trim(), ";") }, "") } function Fc(t) { return t.size !== Ee.size || t.x !== Ee.x || t.y !== Ee.y || t.rotate !== Ee.rotate || t.flipX || t.flipY } function W1(t) { var e = t.transform, n = t.containerWidth, i = t.iconWidth, r = { transform: "translate(".concat(n / 2, " 256)") }, s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), a = "rotate(".concat(e.rotate, " 0 0)"), l = { transform: "".concat(s, " ").concat(o, " ").concat(a) }, u = { transform: "translate(".concat(i / 2 * -1, " -256)") }; return { outer: r, inner: l, path: u } } function $1(t) { var e = t.transform, n = t.width, i = n === void 0 ? hu : n, r = t.height, s = r === void 0 ? hu : r, o = t.startCentered, a = o === void 0 ? !1 : o, l = ""; return a && _g ? l += "translate(".concat(e.x / Je - i / 2, "em, ").concat(e.y / Je - s / 2, "em) ") : a ? l += "translate(calc(-50% + ".concat(e.x / Je, "em), calc(-50% + ").concat(e.y / Je, "em)) ") : l += "translate(".concat(e.x / Je, "em, ").concat(e.y / Je, "em) "), l += "scale(".concat(e.size / Je * (e.flipX ? -1 : 1), ", ").concat(e.size / Je * (e.flipY ? -1 : 1), ") "), l += "rotate(".concat(e.rotate, "deg) "), l } var V1 = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: rgba(0, 0, 0, 0.2);;
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`; function Eg() { var t = bg, e = wg, n = L.cssPrefix, i = L.replacementClass, r = V1; if (n !== t || i !== e) { var s = new RegExp("\\.".concat(t, "\\-"), "g"), o = new RegExp("\\--".concat(t, "\\-"), "g"), a = new RegExp("\\.".concat(e), "g"); r = r.replace(s, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(i)) } return r } var kd = !1; function sl() { L.autoAddCss && !kd && (j1(Eg()), kd = !0) } var U1 = { mixout: function () { return { dom: { css: Eg, insertCss: sl } } }, hooks: function () { return { beforeDOMElementCreation: function () { sl() }, beforeI2svg: function () { sl() } } } }, Xe = Sn || {}; Xe[Ye] || (Xe[Ye] = {}); Xe[Ye].styles || (Xe[Ye].styles = {}); Xe[Ye].hooks || (Xe[Ye].hooks = {}); Xe[Ye].shims || (Xe[Ye].shims = []); var ve = Xe[Ye], Og = [], Y1 = function t() { it.removeEventListener("DOMContentLoaded", t), Xo = 1, Og.map(function (e) { return e() }) }, Xo = !1; Ze && (Xo = (it.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(it.readyState), Xo || it.addEventListener("DOMContentLoaded", Y1)); function X1(t) { !Ze || (Xo ? setTimeout(t, 0) : Og.push(t)) } function ds(t) { var e = t.tag, n = t.attributes, i = n === void 0 ? {} : n, r = t.children, s = r === void 0 ? [] : r; return typeof t == "string" ? Mg(t) : "<".concat(e, " ").concat(H1(i), ">").concat(s.map(ds).join(""), "</").concat(e, ">") } function Sd(t, e, n) { if (t && t[e] && t[e][n]) return { prefix: e, iconName: n, icon: t[e][n] } } var K1 = function (e, n) { return function (i, r, s, o) { return e.call(n, i, r, s, o) } }, ol = function (e, n, i, r) { var s = Object.keys(e), o = s.length, a = r !== void 0 ? K1(n, r) : n, l, u, c; for (i === void 0 ? (l = 1, c = e[s[0]]) : (l = 0, c = i); l < o; l++)u = s[l], c = a(c, e[u], u, e); return c }; function Q1(t) { for (var e = [], n = 0, i = t.length; n < i;) { var r = t.charCodeAt(n++); if (r >= 55296 && r <= 56319 && n < i) { var s = t.charCodeAt(n++); (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r), n--) } else e.push(r) } return e } function mu(t) { var e = Q1(t); return e.length === 1 ? e[0].toString(16) : null } function G1(t, e) { var n = t.length, i = t.charCodeAt(e), r; return i >= 55296 && i <= 56319 && n > e + 1 && (r = t.charCodeAt(e + 1), r >= 56320 && r <= 57343) ? (i - 55296) * 1024 + r - 56320 + 65536 : i } function Cd(t) { return Object.keys(t).reduce(function (e, n) { var i = t[n], r = !!i.icon; return r ? e[i.iconName] = i.icon : e[n] = i, e }, {}) } function gu(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = n.skipHooks, r = i === void 0 ? !1 : i, s = Cd(e); typeof ve.hooks.addPack == "function" && !r ? ve.hooks.addPack(t, Cd(e)) : ve.styles[t] = O(O({}, ve.styles[t] || {}), s), t === "fas" && gu("fa", e) } var js, Bs, Hs, bi = ve.styles, Z1 = ve.shims, q1 = (js = {}, _t(js, tt, Object.values(Gr[tt])), _t(js, ft, Object.values(Gr[ft])), js), jc = null, Tg = {}, Lg = {}, Ag = {}, Dg = {}, Ng = {}, J1 = (Bs = {}, _t(Bs, tt, Object.keys(Kr[tt])), _t(Bs, ft, Object.keys(Kr[ft])), Bs); function tx(t) { return ~N1.indexOf(t) } function ex(t, e) { var n = e.split("-"), i = n[0], r = n.slice(1).join("-"); return i === t && r !== "" && !tx(r) ? r : null } var Ig = function () { var e = function (s) { return ol(bi, function (o, a, l) { return o[l] = ol(a, s, {}), o }, {}) }; Tg = e(function (r, s, o) { if (s[3] && (r[s[3]] = o), s[2]) { var a = s[2].filter(function (l) { return typeof l == "number" }); a.forEach(function (l) { r[l.toString(16)] = o }) } return r }), Lg = e(function (r, s, o) { if (r[o] = o, s[2]) { var a = s[2].filter(function (l) { return typeof l == "string" }); a.forEach(function (l) { r[l] = o }) } return r }), Ng = e(function (r, s, o) { var a = s[2]; return r[o] = o, a.forEach(function (l) { r[l] = o }), r }); var n = "far" in bi || L.autoFetchSvg, i = ol(Z1, function (r, s) { var o = s[0], a = s[1], l = s[2]; return a === "far" && !n && (a = "fas"), typeof o == "string" && (r.names[o] = { prefix: a, iconName: l }), typeof o == "number" && (r.unicodes[o.toString(16)] = { prefix: a, iconName: l }), r }, { names: {}, unicodes: {} }); Ag = i.names, Dg = i.unicodes, jc = Ca(L.styleDefault, { family: L.familyDefault }) }; F1(function (t) { jc = Ca(t.styleDefault, { family: L.familyDefault }) }); Ig(); function Bc(t, e) { return (Tg[t] || {})[e] } function nx(t, e) { return (Lg[t] || {})[e] } function Vn(t, e) { return (Ng[t] || {})[e] } function zg(t) { return Ag[t] || { prefix: null, iconName: null } } function ix(t) { var e = Dg[t], n = Bc("fas", t); return e || (n ? { prefix: "fas", iconName: n } : null) || { prefix: null, iconName: null } } function Cn() { return jc } var Hc = function () { return { prefix: null, iconName: null, rest: [] } }; function Ca(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.family, i = n === void 0 ? tt : n, r = Kr[i][t], s = Qr[i][t] || Qr[i][r], o = t in ve.styles ? t : null; return s || o || null } var Pd = (Hs = {}, _t(Hs, tt, Object.keys(Gr[tt])), _t(Hs, ft, Object.keys(Gr[ft])), Hs); function Pa(t) { var e, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.skipLookups, r = i === void 0 ? !1 : i, s = (e = {}, _t(e, tt, "".concat(L.cssPrefix, "-").concat(tt)), _t(e, ft, "".concat(L.cssPrefix, "-").concat(ft)), e), o = null, a = tt; (t.includes(s[tt]) || t.some(function (u) { return Pd[tt].includes(u) })) && (a = tt), (t.includes(s[ft]) || t.some(function (u) { return Pd[ft].includes(u) })) && (a = ft); var l = t.reduce(function (u, c) { var f = ex(L.cssPrefix, c); if (bi[c] ? (c = q1[a].includes(c) ? E1[a][c] : c, o = c, u.prefix = c) : J1[a].indexOf(c) > -1 ? (o = c, u.prefix = Ca(c, { family: a })) : f ? u.iconName = f : c !== L.replacementClass && c !== s[tt] && c !== s[ft] && u.rest.push(c), !r && u.prefix && u.iconName) { var d = o === "fa" ? zg(u.iconName) : {}, h = Vn(u.prefix, u.iconName); d.prefix && (o = null), u.iconName = d.iconName || h || u.iconName, u.prefix = d.prefix || u.prefix, u.prefix === "far" && !bi.far && bi.fas && !L.autoFetchSvg && (u.prefix = "fas") } return u }, Hc()); return (t.includes("fa-brands") || t.includes("fab")) && (l.prefix = "fab"), (t.includes("fa-duotone") || t.includes("fad")) && (l.prefix = "fad"), !l.prefix && a === ft && (bi.fass || L.autoFetchSvg) && (l.prefix = "fass", l.iconName = Vn(l.prefix, l.iconName) || l.iconName), (l.prefix === "fa" || o === "fa") && (l.prefix = Cn() || "fas"), l } var rx = function () { function t() { g1(this, t), this.definitions = {} } return v1(t, [{ key: "add", value: function () { for (var n = this, i = arguments.length, r = new Array(i), s = 0; s < i; s++)r[s] = arguments[s]; var o = r.reduce(this._pullDefinitions, {}); Object.keys(o).forEach(function (a) { n.definitions[a] = O(O({}, n.definitions[a] || {}), o[a]), gu(a, o[a]); var l = Gr[tt][a]; l && gu(l, o[a]), Ig() }) } }, { key: "reset", value: function () { this.definitions = {} } }, { key: "_pullDefinitions", value: function (n, i) { var r = i.prefix && i.iconName && i.icon ? { 0: i } : i; return Object.keys(r).map(function (s) { var o = r[s], a = o.prefix, l = o.iconName, u = o.icon, c = u[2]; n[a] || (n[a] = {}), c.length > 0 && c.forEach(function (f) { typeof f == "string" && (n[a][f] = u) }), n[a][l] = u }), n } }]), t }(), Md = [], wi = {}, Li = {}, sx = Object.keys(Li); function ox(t, e) { var n = e.mixoutsTo; return Md = t, wi = {}, Object.keys(Li).forEach(function (i) { sx.indexOf(i) === -1 && delete Li[i] }), Md.forEach(function (i) { var r = i.mixout ? i.mixout() : {}; if (Object.keys(r).forEach(function (o) { typeof r[o] == "function" && (n[o] = r[o]), Yo(r[o]) === "object" && Object.keys(r[o]).forEach(function (a) { n[o] || (n[o] = {}), n[o][a] = r[o][a] }) }), i.hooks) { var s = i.hooks(); Object.keys(s).forEach(function (o) { wi[o] || (wi[o] = []), wi[o].push(s[o]) }) } i.provides && i.provides(Li) }), n } function vu(t, e) { for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)i[r - 2] = arguments[r]; var s = wi[t] || []; return s.forEach(function (o) { e = o.apply(null, [e].concat(i)) }), e } function ei(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)n[i - 1] = arguments[i]; var r = wi[t] || []; r.forEach(function (s) { s.apply(null, n) }) } function Ke() { var t = arguments[0], e = Array.prototype.slice.call(arguments, 1); return Li[t] ? Li[t].apply(null, e) : void 0 } function yu(t) { t.prefix === "fa" && (t.prefix = "fas"); var e = t.iconName, n = t.prefix || Cn(); if (!!e) return e = Vn(n, e) || e, Sd(Rg.definitions, n, e) || Sd(ve.styles, n, e) } var Rg = new rx, ax = function () { L.autoReplaceSvg = !1, L.observeMutations = !1, ei("noAuto") }, lx = { i2svg: function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return Ze ? (ei("beforeI2svg", e), Ke("pseudoElements2svg", e), Ke("i2svg", e)) : Promise.reject("Operation requires a DOM of some kind.") }, watch: function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.autoReplaceSvgRoot; L.autoReplaceSvg === !1 && (L.autoReplaceSvg = !0), L.observeMutations = !0, X1(function () { cx({ autoReplaceSvgRoot: n }), ei("watch", e) }) } }, ux = { icon: function (e) { if (e === null) return null; if (Yo(e) === "object" && e.prefix && e.iconName) return { prefix: e.prefix, iconName: Vn(e.prefix, e.iconName) || e.iconName }; if (Array.isArray(e) && e.length === 2) { var n = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], i = Ca(e[0]); return { prefix: i, iconName: Vn(i, n) || n } } if (typeof e == "string" && (e.indexOf("".concat(L.cssPrefix, "-")) > -1 || e.match(O1))) { var r = Pa(e.split(" "), { skipLookups: !0 }); return { prefix: r.prefix || Cn(), iconName: Vn(r.prefix, r.iconName) || r.iconName } } if (typeof e == "string") { var s = Cn(); return { prefix: s, iconName: Vn(s, e) || e } } } }, ie = { noAuto: ax, config: L, dom: lx, parse: ux, library: Rg, findIconDefinition: yu, toHtml: ds }, cx = function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.autoReplaceSvgRoot, i = n === void 0 ? it : n; (Object.keys(ve.styles).length > 0 || L.autoFetchSvg) && Ze && L.autoReplaceSvg && ie.dom.i2svg({ node: i }) }; function Ma(t, e) { return Object.defineProperty(t, "abstract", { get: e }), Object.defineProperty(t, "html", { get: function () { return t.abstract.map(function (i) { return ds(i) }) } }), Object.defineProperty(t, "node", { get: function () { if (!!Ze) { var i = it.createElement("div"); return i.innerHTML = t.html, i.children } } }), t } function fx(t) { var e = t.children, n = t.main, i = t.mask, r = t.attributes, s = t.styles, o = t.transform; if (Fc(o) && n.found && !i.found) { var a = n.width, l = n.height, u = { x: a / l / 2, y: .5 }; r.style = Sa(O(O({}, s), {}, { "transform-origin": "".concat(u.x + o.x / 16, "em ").concat(u.y + o.y / 16, "em") })) } return [{ tag: "svg", attributes: r, children: e }] } function dx(t) { var e = t.prefix, n = t.iconName, i = t.children, r = t.attributes, s = t.symbol, o = s === !0 ? "".concat(e, "-").concat(L.cssPrefix, "-").concat(n) : s; return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: O(O({}, r), {}, { id: o }), children: i }] }] } function Wc(t) { var e = t.icons, n = e.main, i = e.mask, r = t.prefix, s = t.iconName, o = t.transform, a = t.symbol, l = t.title, u = t.maskId, c = t.titleId, f = t.extra, d = t.watchable, h = d === void 0 ? !1 : d, g = i.found ? i : n, v = g.width, x = g.height, m = r === "fak", p = [L.replacementClass, s ? "".concat(L.cssPrefix, "-").concat(s) : ""].filter(function (P) { return f.classes.indexOf(P) === -1 }).filter(function (P) { return P !== "" || !!P }).concat(f.classes).join(" "), y = { children: [], attributes: O(O({}, f.attributes), {}, { "data-prefix": r, "data-icon": s, class: p, role: f.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(v, " ").concat(x) }) }, _ = m && !~f.classes.indexOf("fa-fw") ? { width: "".concat(v / x * 16 * .0625, "em") } : {}; h && (y.attributes[ti] = ""), l && (y.children.push({ tag: "title", attributes: { id: y.attributes["aria-labelledby"] || "title-".concat(c || qr()) }, children: [l] }), delete y.attributes.title); var b = O(O({}, y), {}, { prefix: r, iconName: s, main: n, mask: i, maskId: u, transform: o, symbol: a, styles: O(O({}, _), f.styles) }), w = i.found && n.found ? Ke("generateAbstractMask", b) || { children: [], attributes: {} } : Ke("generateAbstractIcon", b) || { children: [], attributes: {} }, k = w.children, S = w.attributes; return b.children = k, b.attributes = S, a ? dx(b) : fx(b) } function Ed(t) { var e = t.content, n = t.width, i = t.height, r = t.transform, s = t.title, o = t.extra, a = t.watchable, l = a === void 0 ? !1 : a, u = O(O(O({}, o.attributes), s ? { title: s } : {}), {}, { class: o.classes.join(" ") }); l && (u[ti] = ""); var c = O({}, o.styles); Fc(r) && (c.transform = $1({ transform: r, startCentered: !0, width: n, height: i }), c["-webkit-transform"] = c.transform); var f = Sa(c); f.length > 0 && (u.style = f); var d = []; return d.push({ tag: "span", attributes: u, children: [e] }), s && d.push({ tag: "span", attributes: { class: "sr-only" }, children: [s] }), d } function hx(t) { var e = t.content, n = t.title, i = t.extra, r = O(O(O({}, i.attributes), n ? { title: n } : {}), {}, { class: i.classes.join(" ") }), s = Sa(i.styles); s.length > 0 && (r.style = s); var o = []; return o.push({ tag: "span", attributes: r, children: [e] }), n && o.push({ tag: "span", attributes: { class: "sr-only" }, children: [n] }), o } var al = ve.styles; function xu(t) { var e = t[0], n = t[1], i = t.slice(4), r = Ac(i, 1), s = r[0], o = null; return Array.isArray(s) ? o = { tag: "g", attributes: { class: "".concat(L.cssPrefix, "-").concat($n.GROUP) }, children: [{ tag: "path", attributes: { class: "".concat(L.cssPrefix, "-").concat($n.SECONDARY), fill: "currentColor", d: s[0] } }, { tag: "path", attributes: { class: "".concat(L.cssPrefix, "-").concat($n.PRIMARY), fill: "currentColor", d: s[1] } }] } : o = { tag: "path", attributes: { fill: "currentColor", d: s } }, { found: !0, width: e, height: n, icon: o } } var px = { found: !1, width: 512, height: 512 }; function mx(t, e) { !kg && !L.showMissingIcons && t && console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.')) } function _u(t, e) { var n = e; return e === "fa" && L.styleDefault !== null && (e = Cn()), new Promise(function (i, r) { if (Ke("missingIconAbstract"), n === "fa") { var s = zg(t) || {}; t = s.iconName || t, e = s.prefix || e } if (t && e && al[e] && al[e][t]) { var o = al[e][t]; return i(xu(o)) } mx(t, e), i(O(O({}, px), {}, { icon: L.showMissingIcons && t ? Ke("missingIconAbstract") || {} : {} })) }) } var Od = function () { }, bu = L.measurePerformance && Ds && Ds.mark && Ds.measure ? Ds : { mark: Od, measure: Od }, dr = 'FA "6.2.1"', gx = function (e) { return bu.mark("".concat(dr, " ").concat(e, " begins")), function () { return Fg(e) } }, Fg = function (e) { bu.mark("".concat(dr, " ").concat(e, " ends")), bu.measure("".concat(dr, " ").concat(e), "".concat(dr, " ").concat(e, " begins"), "".concat(dr, " ").concat(e, " ends")) }, $c = { begin: gx, end: Fg }, mo = function () { }; function Td(t) { var e = t.getAttribute ? t.getAttribute(ti) : null; return typeof e == "string" } function vx(t) { var e = t.getAttribute ? t.getAttribute(Nc) : null, n = t.getAttribute ? t.getAttribute(Ic) : null; return e && n } function yx(t) { return t && t.classList && t.classList.contains && t.classList.contains(L.replacementClass) } function xx() { if (L.autoReplaceSvg === !0) return go.replace; var t = go[L.autoReplaceSvg]; return t || go.replace } function _x(t) { return it.createElementNS("http://www.w3.org/2000/svg", t) } function bx(t) { return it.createElement(t) } function jg(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.ceFn, i = n === void 0 ? t.tag === "svg" ? _x : bx : n; if (typeof t == "string") return it.createTextNode(t); var r = i(t.tag); Object.keys(t.attributes || []).forEach(function (o) { r.setAttribute(o, t.attributes[o]) }); var s = t.children || []; return s.forEach(function (o) { r.appendChild(jg(o, { ceFn: i })) }), r } function wx(t) { var e = " ".concat(t.outerHTML, " "); return e = "".concat(e, "Font Awesome fontawesome.com "), e } var go = {
  replace: function (e) { var n = e[0]; if (n.parentNode) if (e[1].forEach(function (r) { n.parentNode.insertBefore(jg(r), n) }), n.getAttribute(ti) === null && L.keepOriginalSource) { var i = it.createComment(wx(n)); n.parentNode.replaceChild(i, n) } else n.remove() }, nest: function (e) {
    var n = e[0], i = e[1]; if (~Rc(n).indexOf(L.replacementClass)) return go.replace(e); var r = new RegExp("".concat(L.cssPrefix, "-.*")); if (delete i[0].attributes.id, i[0].attributes.class) { var s = i[0].attributes.class.split(" ").reduce(function (a, l) { return l === L.replacementClass || l.match(r) ? a.toSvg.push(l) : a.toNode.push(l), a }, { toNode: [], toSvg: [] }); i[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", s.toNode.join(" ")) } var o = i.map(function (a) { return ds(a) }).join(`
`); n.setAttribute(ti, ""), n.innerHTML = o
  }
}; function Ld(t) { t() } function Bg(t, e) { var n = typeof e == "function" ? e : mo; if (t.length === 0) n(); else { var i = Ld; L.mutateApproach === P1 && (i = Sn.requestAnimationFrame || Ld), i(function () { var r = xx(), s = $c.begin("mutate"); t.map(r), s(), n() }) } } var Vc = !1; function Hg() { Vc = !0 } function wu() { Vc = !1 } var Ko = null; function Ad(t) { if (!!bd && !!L.observeMutations) { var e = t.treeCallback, n = e === void 0 ? mo : e, i = t.nodeCallback, r = i === void 0 ? mo : i, s = t.pseudoElementsCallback, o = s === void 0 ? mo : s, a = t.observeMutationsRoot, l = a === void 0 ? it : a; Ko = new bd(function (u) { if (!Vc) { var c = Cn(); Ki(u).forEach(function (f) { if (f.type === "childList" && f.addedNodes.length > 0 && !Td(f.addedNodes[0]) && (L.searchPseudoElements && o(f.target), n(f.target)), f.type === "attributes" && f.target.parentNode && L.searchPseudoElements && o(f.target.parentNode), f.type === "attributes" && Td(f.target) && ~D1.indexOf(f.attributeName)) if (f.attributeName === "class" && vx(f.target)) { var d = Pa(Rc(f.target)), h = d.prefix, g = d.iconName; f.target.setAttribute(Nc, h || c), g && f.target.setAttribute(Ic, g) } else yx(f.target) && r(f.target) }) } }), Ze && Ko.observe(l, { childList: !0, attributes: !0, characterData: !0, subtree: !0 }) } } function kx() { !Ko || Ko.disconnect() } function Sx(t) { var e = t.getAttribute("style"), n = []; return e && (n = e.split(";").reduce(function (i, r) { var s = r.split(":"), o = s[0], a = s.slice(1); return o && a.length > 0 && (i[o] = a.join(":").trim()), i }, {})), n } function Cx(t) { var e = t.getAttribute("data-prefix"), n = t.getAttribute("data-icon"), i = t.innerText !== void 0 ? t.innerText.trim() : "", r = Pa(Rc(t)); return r.prefix || (r.prefix = Cn()), e && n && (r.prefix = e, r.iconName = n), r.iconName && r.prefix || (r.prefix && i.length > 0 && (r.iconName = nx(r.prefix, t.innerText) || Bc(r.prefix, mu(t.innerText))), !r.iconName && L.autoFetchSvg && t.firstChild && t.firstChild.nodeType === Node.TEXT_NODE && (r.iconName = t.firstChild.data)), r } function Px(t) { var e = Ki(t.attributes).reduce(function (r, s) { return r.name !== "class" && r.name !== "style" && (r[s.name] = s.value), r }, {}), n = t.getAttribute("title"), i = t.getAttribute("data-fa-title-id"); return L.autoA11y && (n ? e["aria-labelledby"] = "".concat(L.replacementClass, "-title-").concat(i || qr()) : (e["aria-hidden"] = "true", e.focusable = "false")), e } function Mx() { return { iconName: null, title: null, titleId: null, prefix: null, transform: Ee, symbol: !1, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, extra: { classes: [], styles: {}, attributes: {} } } } function Dd(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { styleParser: !0 }, n = Cx(t), i = n.iconName, r = n.prefix, s = n.rest, o = Px(t), a = vu("parseNodeAttributes", {}, t), l = e.styleParser ? Sx(t) : []; return O({ iconName: i, title: t.getAttribute("title"), titleId: t.getAttribute("data-fa-title-id"), prefix: r, transform: Ee, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, symbol: !1, extra: { classes: s, styles: l, attributes: o } }, a) } var Ex = ve.styles; function Wg(t) { var e = L.autoReplaceSvg === "nest" ? Dd(t, { styleParser: !1 }) : Dd(t); return ~e.extra.classes.indexOf(Sg) ? Ke("generateLayersText", t, e) : Ke("generateSvgReplacementMutation", t, e) } var Pn = new Set; zc.map(function (t) { Pn.add("fa-".concat(t)) }); Object.keys(Kr[tt]).map(Pn.add.bind(Pn)); Object.keys(Kr[ft]).map(Pn.add.bind(Pn)); Pn = cs(Pn); function Nd(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; if (!Ze) return Promise.resolve(); var n = it.documentElement.classList, i = function (f) { return n.add("".concat(wd, "-").concat(f)) }, r = function (f) { return n.remove("".concat(wd, "-").concat(f)) }, s = L.autoFetchSvg ? Pn : zc.map(function (c) { return "fa-".concat(c) }).concat(Object.keys(Ex)); s.includes("fa") || s.push("fa"); var o = [".".concat(Sg, ":not([").concat(ti, "])")].concat(s.map(function (c) { return ".".concat(c, ":not([").concat(ti, "])") })).join(", "); if (o.length === 0) return Promise.resolve(); var a = []; try { a = Ki(t.querySelectorAll(o)) } catch { } if (a.length > 0) i("pending"), r("complete"); else return Promise.resolve(); var l = $c.begin("onTree"), u = a.reduce(function (c, f) { try { var d = Wg(f); d && c.push(d) } catch (h) { kg || h.name === "MissingIcon" && console.error(h) } return c }, []); return new Promise(function (c, f) { Promise.all(u).then(function (d) { Bg(d, function () { i("active"), i("complete"), r("pending"), typeof e == "function" && e(), l(), c() }) }).catch(function (d) { l(), f(d) }) }) } function Ox(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; Wg(t).then(function (n) { n && Bg([n], e) }) } function Tx(t) { return function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = (e || {}).icon ? e : yu(e || {}), r = n.mask; return r && (r = (r || {}).icon ? r : yu(r || {})), t(i, O(O({}, n), {}, { mask: r })) } } var Lx = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.transform, r = i === void 0 ? Ee : i, s = n.symbol, o = s === void 0 ? !1 : s, a = n.mask, l = a === void 0 ? null : a, u = n.maskId, c = u === void 0 ? null : u, f = n.title, d = f === void 0 ? null : f, h = n.titleId, g = h === void 0 ? null : h, v = n.classes, x = v === void 0 ? [] : v, m = n.attributes, p = m === void 0 ? {} : m, y = n.styles, _ = y === void 0 ? {} : y; if (!!e) { var b = e.prefix, w = e.iconName, k = e.icon; return Ma(O({ type: "icon" }, e), function () { return ei("beforeDOMElementCreation", { iconDefinition: e, params: n }), L.autoA11y && (d ? p["aria-labelledby"] = "".concat(L.replacementClass, "-title-").concat(g || qr()) : (p["aria-hidden"] = "true", p.focusable = "false")), Wc({ icons: { main: xu(k), mask: l ? xu(l.icon) : { found: !1, width: null, height: null, icon: {} } }, prefix: b, iconName: w, transform: O(O({}, Ee), r), symbol: o, title: d, maskId: c, titleId: g, extra: { attributes: p, styles: _, classes: x } }) }) } }, Ax = { mixout: function () { return { icon: Tx(Lx) } }, hooks: function () { return { mutationObserverCallbacks: function (n) { return n.treeCallback = Nd, n.nodeCallback = Ox, n } } }, provides: function (e) { e.i2svg = function (n) { var i = n.node, r = i === void 0 ? it : i, s = n.callback, o = s === void 0 ? function () { } : s; return Nd(r, o) }, e.generateSvgReplacementMutation = function (n, i) { var r = i.iconName, s = i.title, o = i.titleId, a = i.prefix, l = i.transform, u = i.symbol, c = i.mask, f = i.maskId, d = i.extra; return new Promise(function (h, g) { Promise.all([_u(r, a), c.iconName ? _u(c.iconName, c.prefix) : Promise.resolve({ found: !1, width: 512, height: 512, icon: {} })]).then(function (v) { var x = Ac(v, 2), m = x[0], p = x[1]; h([n, Wc({ icons: { main: m, mask: p }, prefix: a, iconName: r, transform: l, symbol: u, maskId: f, title: s, titleId: o, extra: d, watchable: !0 })]) }).catch(g) }) }, e.generateAbstractIcon = function (n) { var i = n.children, r = n.attributes, s = n.main, o = n.transform, a = n.styles, l = Sa(a); l.length > 0 && (r.style = l); var u; return Fc(o) && (u = Ke("generateAbstractTransformGrouping", { main: s, transform: o, containerWidth: s.width, iconWidth: s.width })), i.push(u || s.icon), { children: i, attributes: r } } } }, Dx = { mixout: function () { return { layer: function (n) { var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = i.classes, s = r === void 0 ? [] : r; return Ma({ type: "layer" }, function () { ei("beforeDOMElementCreation", { assembler: n, params: i }); var o = []; return n(function (a) { Array.isArray(a) ? a.map(function (l) { o = o.concat(l.abstract) }) : o = o.concat(a.abstract) }), [{ tag: "span", attributes: { class: ["".concat(L.cssPrefix, "-layers")].concat(cs(s)).join(" ") }, children: o }] }) } } } }, Nx = { mixout: function () { return { counter: function (n) { var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = i.title, s = r === void 0 ? null : r, o = i.classes, a = o === void 0 ? [] : o, l = i.attributes, u = l === void 0 ? {} : l, c = i.styles, f = c === void 0 ? {} : c; return Ma({ type: "counter", content: n }, function () { return ei("beforeDOMElementCreation", { content: n, params: i }), hx({ content: n.toString(), title: s, extra: { attributes: u, styles: f, classes: ["".concat(L.cssPrefix, "-layers-counter")].concat(cs(a)) } }) }) } } } }, Ix = { mixout: function () { return { text: function (n) { var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = i.transform, s = r === void 0 ? Ee : r, o = i.title, a = o === void 0 ? null : o, l = i.classes, u = l === void 0 ? [] : l, c = i.attributes, f = c === void 0 ? {} : c, d = i.styles, h = d === void 0 ? {} : d; return Ma({ type: "text", content: n }, function () { return ei("beforeDOMElementCreation", { content: n, params: i }), Ed({ content: n, transform: O(O({}, Ee), s), title: a, extra: { attributes: f, styles: h, classes: ["".concat(L.cssPrefix, "-layers-text")].concat(cs(u)) } }) }) } } }, provides: function (e) { e.generateLayersText = function (n, i) { var r = i.title, s = i.transform, o = i.extra, a = null, l = null; if (_g) { var u = parseInt(getComputedStyle(n).fontSize, 10), c = n.getBoundingClientRect(); a = c.width / u, l = c.height / u } return L.autoA11y && !r && (o.attributes["aria-hidden"] = "true"), Promise.resolve([n, Ed({ content: n.innerHTML, width: a, height: l, transform: s, title: r, extra: o, watchable: !0 })]) } } }, zx = new RegExp('"', "ug"), Id = [1105920, 1112319]; function Rx(t) { var e = t.replace(zx, ""), n = G1(e, 0), i = n >= Id[0] && n <= Id[1], r = e.length === 2 ? e[0] === e[1] : !1; return { value: mu(r ? e[0] : e), isSecondary: i || r } } function zd(t, e) {
  var n = "".concat(C1).concat(e.replace(":", "-")); return new Promise(function (i, r) {
    if (t.getAttribute(n) !== null) return i(); var s = Ki(t.children), o = s.filter(function (k) { return k.getAttribute(pu) === e })[0], a = Sn.getComputedStyle(t, e), l = a.getPropertyValue("font-family").match(T1), u = a.getPropertyValue("font-weight"), c = a.getPropertyValue("content"); if (o && !l) return t.removeChild(o), i(); if (l && c !== "none" && c !== "") {
      var f = a.getPropertyValue("content"), d = ~["Sharp"].indexOf(l[2]) ? ft : tt, h = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(l[2]) ? Qr[d][l[2].toLowerCase()] : L1[d][u], g = Rx(f), v = g.value, x = g.isSecondary, m = l[0].startsWith("FontAwesome"), p = Bc(h, v), y = p; if (m) { var _ = ix(v); _.iconName && _.prefix && (p = _.iconName, h = _.prefix) } if (p && !x && (!o || o.getAttribute(Nc) !== h || o.getAttribute(Ic) !== y)) {
        t.setAttribute(n, y), o && t.removeChild(o); var b = Mx(), w = b.extra; w.attributes[pu] = e, _u(p, h).then(function (k) {
          var S = Wc(O(O({}, b), {}, { icons: { main: k, mask: Hc() }, prefix: h, iconName: y, extra: w, watchable: !0 })), P = it.createElement("svg"); e === "::before" ? t.insertBefore(P, t.firstChild) : t.appendChild(P), P.outerHTML = S.map(function (M) { return ds(M) }).join(`
`), t.removeAttribute(n), i()
        }).catch(r)
      } else i()
    } else i()
  })
} function Fx(t) { return Promise.all([zd(t, "::before"), zd(t, "::after")]) } function jx(t) { return t.parentNode !== document.head && !~M1.indexOf(t.tagName.toUpperCase()) && !t.getAttribute(pu) && (!t.parentNode || t.parentNode.tagName !== "svg") } function Rd(t) { if (!!Ze) return new Promise(function (e, n) { var i = Ki(t.querySelectorAll("*")).filter(jx).map(Fx), r = $c.begin("searchPseudoElements"); Hg(), Promise.all(i).then(function () { r(), wu(), e() }).catch(function () { r(), wu(), n() }) }) } var Bx = { hooks: function () { return { mutationObserverCallbacks: function (n) { return n.pseudoElementsCallback = Rd, n } } }, provides: function (e) { e.pseudoElements2svg = function (n) { var i = n.node, r = i === void 0 ? it : i; L.searchPseudoElements && Rd(r) } } }, Fd = !1, Hx = { mixout: function () { return { dom: { unwatch: function () { Hg(), Fd = !0 } } } }, hooks: function () { return { bootstrap: function () { Ad(vu("mutationObserverCallbacks", {})) }, noAuto: function () { kx() }, watch: function (n) { var i = n.observeMutationsRoot; Fd ? wu() : Ad(vu("mutationObserverCallbacks", { observeMutationsRoot: i })) } } } }, jd = function (e) { var n = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }; return e.toLowerCase().split(" ").reduce(function (i, r) { var s = r.toLowerCase().split("-"), o = s[0], a = s.slice(1).join("-"); if (o && a === "h") return i.flipX = !0, i; if (o && a === "v") return i.flipY = !0, i; if (a = parseFloat(a), isNaN(a)) return i; switch (o) { case "grow": i.size = i.size + a; break; case "shrink": i.size = i.size - a; break; case "left": i.x = i.x - a; break; case "right": i.x = i.x + a; break; case "up": i.y = i.y - a; break; case "down": i.y = i.y + a; break; case "rotate": i.rotate = i.rotate + a; break }return i }, n) }, Wx = { mixout: function () { return { parse: { transform: function (n) { return jd(n) } } } }, hooks: function () { return { parseNodeAttributes: function (n, i) { var r = i.getAttribute("data-fa-transform"); return r && (n.transform = jd(r)), n } } }, provides: function (e) { e.generateAbstractTransformGrouping = function (n) { var i = n.main, r = n.transform, s = n.containerWidth, o = n.iconWidth, a = { transform: "translate(".concat(s / 2, " 256)") }, l = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), u = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), c = "rotate(".concat(r.rotate, " 0 0)"), f = { transform: "".concat(l, " ").concat(u, " ").concat(c) }, d = { transform: "translate(".concat(o / 2 * -1, " -256)") }, h = { outer: a, inner: f, path: d }; return { tag: "g", attributes: O({}, h.outer), children: [{ tag: "g", attributes: O({}, h.inner), children: [{ tag: i.icon.tag, children: i.icon.children, attributes: O(O({}, i.icon.attributes), h.path) }] }] } } } }, ll = { x: 0, y: 0, width: "100%", height: "100%" }; function Bd(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t } function $x(t) { return t.tag === "g" ? t.children : [t] } var Vx = { hooks: function () { return { parseNodeAttributes: function (n, i) { var r = i.getAttribute("data-fa-mask"), s = r ? Pa(r.split(" ").map(function (o) { return o.trim() })) : Hc(); return s.prefix || (s.prefix = Cn()), n.mask = s, n.maskId = i.getAttribute("data-fa-mask-id"), n } } }, provides: function (e) { e.generateAbstractMask = function (n) { var i = n.children, r = n.attributes, s = n.main, o = n.mask, a = n.maskId, l = n.transform, u = s.width, c = s.icon, f = o.width, d = o.icon, h = W1({ transform: l, containerWidth: f, iconWidth: u }), g = { tag: "rect", attributes: O(O({}, ll), {}, { fill: "white" }) }, v = c.children ? { children: c.children.map(Bd) } : {}, x = { tag: "g", attributes: O({}, h.inner), children: [Bd(O({ tag: c.tag, attributes: O(O({}, c.attributes), h.path) }, v))] }, m = { tag: "g", attributes: O({}, h.outer), children: [x] }, p = "mask-".concat(a || qr()), y = "clip-".concat(a || qr()), _ = { tag: "mask", attributes: O(O({}, ll), {}, { id: p, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [g, m] }, b = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: y }, children: $x(d) }, _] }; return i.push(b, { tag: "rect", attributes: O({ fill: "currentColor", "clip-path": "url(#".concat(y, ")"), mask: "url(#".concat(p, ")") }, ll) }), { children: i, attributes: r } } } }, Ux = { provides: function (e) { var n = !1; Sn.matchMedia && (n = Sn.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function () { var i = [], r = { fill: "currentColor" }, s = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }; i.push({ tag: "path", attributes: O(O({}, r), {}, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }) }); var o = O(O({}, s), {}, { attributeName: "opacity" }), a = { tag: "circle", attributes: O(O({}, r), {}, { cx: "256", cy: "364", r: "28" }), children: [] }; return n || a.children.push({ tag: "animate", attributes: O(O({}, s), {}, { attributeName: "r", values: "28;14;28;28;14;28;" }) }, { tag: "animate", attributes: O(O({}, o), {}, { values: "1;0;1;1;0;1;" }) }), i.push(a), i.push({ tag: "path", attributes: O(O({}, r), {}, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), children: n ? [] : [{ tag: "animate", attributes: O(O({}, o), {}, { values: "1;0;0;0;0;1;" }) }] }), n || i.push({ tag: "path", attributes: O(O({}, r), {}, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), children: [{ tag: "animate", attributes: O(O({}, o), {}, { values: "0;0;1;1;0;0;" }) }] }), { tag: "g", attributes: { class: "missing" }, children: i } } } }, Yx = { hooks: function () { return { parseNodeAttributes: function (n, i) { var r = i.getAttribute("data-fa-symbol"), s = r === null ? !1 : r === "" ? !0 : r; return n.symbol = s, n } } } }, Xx = [U1, Ax, Dx, Nx, Ix, Bx, Hx, Wx, Vx, Ux, Yx]; ox(Xx, { mixoutsTo: ie }); ie.noAuto; ie.config; ie.library; ie.dom; var ku = ie.parse; ie.findIconDefinition; ie.toHtml; var Kx = ie.icon; ie.layer; ie.text; ie.counter; var R = { exports: {} }, Qx = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", Gx = Qx, Zx = Gx; function $g() { } function Vg() { } Vg.resetWarningCache = $g; var qx = function () { function t(i, r, s, o, a, l) { if (l !== Zx) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: Vg, resetWarningCache: $g }; return n.PropTypes = n, n }; R.exports = qx(); function Hd(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(t, r).enumerable })), n.push.apply(n, i) } return n } function ln(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? Hd(Object(n), !0).forEach(function (i) { ki(t, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Hd(Object(n)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i)) }) } return t } function Qo(t) { return Qo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Qo(t) } function ki(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Jx(t, e) { if (t == null) return {}; var n = {}, i = Object.keys(t), r, s; for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && (n[r] = t[r]); return n } function t_(t, e) { if (t == null) return {}; var n = Jx(t, e), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (r = 0; r < s.length; r++)i = s[r], !(e.indexOf(i) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, i) || (n[i] = t[i])) } return n } function Su(t) { return e_(t) || n_(t) || i_(t) || r_() } function e_(t) { if (Array.isArray(t)) return Cu(t) } function n_(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function i_(t, e) { if (!!t) { if (typeof t == "string") return Cu(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Cu(t, e) } } function Cu(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } function r_() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function s_(t) { var e, n = t.beat, i = t.fade, r = t.beatFade, s = t.bounce, o = t.shake, a = t.flash, l = t.spin, u = t.spinPulse, c = t.spinReverse, f = t.pulse, d = t.fixedWidth, h = t.inverse, g = t.border, v = t.listItem, x = t.flip, m = t.size, p = t.rotation, y = t.pull, _ = (e = { "fa-beat": n, "fa-fade": i, "fa-beat-fade": r, "fa-bounce": s, "fa-shake": o, "fa-flash": a, "fa-spin": l, "fa-spin-reverse": c, "fa-spin-pulse": u, "fa-pulse": f, "fa-fw": d, "fa-inverse": h, "fa-border": g, "fa-li": v, "fa-flip": x === !0, "fa-flip-horizontal": x === "horizontal" || x === "both", "fa-flip-vertical": x === "vertical" || x === "both" }, ki(e, "fa-".concat(m), typeof m < "u" && m !== null), ki(e, "fa-rotate-".concat(p), typeof p < "u" && p !== null && p !== 0), ki(e, "fa-pull-".concat(y), typeof y < "u" && y !== null), ki(e, "fa-swap-opacity", t.swapOpacity), e); return Object.keys(_).map(function (b) { return _[b] ? b : null }).filter(function (b) { return b }) } function o_(t) { return t = t - 0, t === t } function Ug(t) { return o_(t) ? t : (t = t.replace(/[\-_\s]+(.)?/g, function (e, n) { return n ? n.toUpperCase() : "" }), t.substr(0, 1).toLowerCase() + t.substr(1)) } var a_ = ["style"]; function l_(t) { return t.charAt(0).toUpperCase() + t.slice(1) } function u_(t) { return t.split(";").map(function (e) { return e.trim() }).filter(function (e) { return e }).reduce(function (e, n) { var i = n.indexOf(":"), r = Ug(n.slice(0, i)), s = n.slice(i + 1).trim(); return r.startsWith("webkit") ? e[l_(r)] = s : e[r] = s, e }, {}) } function Yg(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (typeof e == "string") return e; var i = (e.children || []).map(function (l) { return Yg(t, l) }), r = Object.keys(e.attributes || {}).reduce(function (l, u) { var c = e.attributes[u]; switch (u) { case "class": l.attrs.className = c, delete e.attributes.class; break; case "style": l.attrs.style = u_(c); break; default: u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? l.attrs[u.toLowerCase()] = c : l.attrs[Ug(u)] = c }return l }, { attrs: {} }), s = n.style, o = s === void 0 ? {} : s, a = t_(n, a_); return r.attrs.style = ln(ln({}, r.attrs.style), o), t.apply(void 0, [e.tag, ln(ln({}, r.attrs), a)].concat(Su(i))) } var Xg = !1; try { Xg = !0 } catch { } function c_() { if (!Xg && console && typeof console.error == "function") { var t; (t = console).error.apply(t, arguments) } } function Wd(t) { if (t && Qo(t) === "object" && t.prefix && t.iconName && t.icon) return t; if (ku.icon) return ku.icon(t); if (t === null) return null; if (t && Qo(t) === "object" && t.prefix && t.iconName) return t; if (Array.isArray(t) && t.length === 2) return { prefix: t[0], iconName: t[1] }; if (typeof t == "string") return { prefix: "fas", iconName: t } } function ul(t, e) { return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? ki({}, t, e) : {} } var Le = ss.forwardRef(function (t, e) { var n = t.icon, i = t.mask, r = t.symbol, s = t.className, o = t.title, a = t.titleId, l = t.maskId, u = Wd(n), c = ul("classes", [].concat(Su(s_(t)), Su(s.split(" ")))), f = ul("transform", typeof t.transform == "string" ? ku.transform(t.transform) : t.transform), d = ul("mask", Wd(i)), h = Kx(u, ln(ln(ln(ln({}, c), f), d), {}, { symbol: r, title: o, titleId: a, maskId: l })); if (!h) return c_("Could not find icon", u), null; var g = h.abstract, v = { ref: e }; return Object.keys(t).forEach(function (x) { Le.defaultProps.hasOwnProperty(x) || (v[x] = t[x]) }), f_(g[0], v) }); Le.displayName = "FontAwesomeIcon"; Le.propTypes = { beat: R.exports.bool, border: R.exports.bool, beatFade: R.exports.bool, bounce: R.exports.bool, className: R.exports.string, fade: R.exports.bool, flash: R.exports.bool, mask: R.exports.oneOfType([R.exports.object, R.exports.array, R.exports.string]), maskId: R.exports.string, fixedWidth: R.exports.bool, inverse: R.exports.bool, flip: R.exports.oneOf([!0, !1, "horizontal", "vertical", "both"]), icon: R.exports.oneOfType([R.exports.object, R.exports.array, R.exports.string]), listItem: R.exports.bool, pull: R.exports.oneOf(["right", "left"]), pulse: R.exports.bool, rotation: R.exports.oneOf([0, 90, 180, 270]), shake: R.exports.bool, size: R.exports.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]), spin: R.exports.bool, spinPulse: R.exports.bool, spinReverse: R.exports.bool, symbol: R.exports.oneOfType([R.exports.bool, R.exports.string]), title: R.exports.string, titleId: R.exports.string, transform: R.exports.oneOfType([R.exports.string, R.exports.object]), swapOpacity: R.exports.bool }; Le.defaultProps = { border: !1, className: "", mask: null, maskId: null, fixedWidth: !1, inverse: !1, flip: !1, icon: null, listItem: !1, pull: null, pulse: !1, rotation: null, size: null, spin: !1, spinPulse: !1, spinReverse: !1, beat: !1, fade: !1, beatFade: !1, bounce: !1, shake: !1, symbol: !1, title: "", titleId: null, transform: null, swapOpacity: !1 }; var f_ = Yg.bind(null, ss.createElement); const Kg = t => { let e; switch (t) { case "Clear": e = "fa-cloud"; break; case "Sunny": e = "fa-sun"; break; case "Mist": e = "fa-cloud-meatball"; break; case "Cloudy": e = "fa-cloud"; break; case "Partly cloudy": e = "fa-cloud-sun"; break; case "Overcast": e = "fa-smog"; break; case "Blizzard": e = "fa-meteor"; break; case "Fog": e = "fa-smog"; break; case "Light rain": e = "fa-cloud-rain"; break; case "Medium rain": e = "fa-cloud-rain"; break; case "Heavy rain": e = "fa-cloud-showers-heavy"; break; case "Light snow": e = "fa-snowflake"; break; case "Medium snow": e = "fa-snowflake"; break; case "Heavy snow": e = "fa-icicles"; break; default: e = "fa-cloud" }return e }, d_ = ({ weatherData: t }) => { const e = t == null ? void 0 : t.text, n = new Date().toLocaleTimeString("en-us", { hour: "numeric", minute: "numeric", hour12: !0 }), i = new Date().toLocaleDateString("en-us", { weekday: "long", year: "numeric", month: "long", day: "numeric" }); return dt("div", { className: "current", children: [dt("h1", { className: "current-temp", children: [t == null ? void 0 : t.temp, H("sup", { children: "C" })] }), dt("div", { className: "location-date", children: [H("h2", { className: "location", children: t == null ? void 0 : t.location }), dt("h3", { className: "current-date", children: [n, " - ", i] })] }), dt("div", { className: "current-weather", children: [H(Le, { icon: `fa-solid ${Kg(e)}`, className: "current-weather__icon" }), H("h3", { className: "current-weather__text", children: t == null ? void 0 : t.text })] })] }) }; function De() { } const h_ = (() => { let t = 0; return () => t++ })(); function et(t) { return t === null || typeof t > "u" } function st(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]" } function W(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]" } function ht(t) { return (typeof t == "number" || t instanceof Number) && isFinite(+t) } function Kt(t, e) { return ht(t) ? t : e } function j(t, e) { return typeof t > "u" ? e : t } const p_ = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function Q(t, e, n) { if (t && typeof t.call == "function") return t.apply(n, e) } function V(t, e, n, i) { let r, s, o; if (st(t)) if (s = t.length, i) for (r = s - 1; r >= 0; r--)e.call(n, t[r], r); else for (r = 0; r < s; r++)e.call(n, t[r], r); else if (W(t)) for (o = Object.keys(t), s = o.length, r = 0; r < s; r++)e.call(n, t[o[r]], o[r]) } function Go(t, e) { let n, i, r, s; if (!t || !e || t.length !== e.length) return !1; for (n = 0, i = t.length; n < i; ++n)if (r = t[n], s = e[n], r.datasetIndex !== s.datasetIndex || r.index !== s.index) return !1; return !0 } function Zo(t) { if (st(t)) return t.map(Zo); if (W(t)) { const e = Object.create(null), n = Object.keys(t), i = n.length; let r = 0; for (; r < i; ++r)e[n[r]] = Zo(t[n[r]]); return e } return t } function Qg(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1 } function m_(t, e, n, i) { if (!Qg(t)) return; const r = e[t], s = n[t]; W(r) && W(s) ? Jr(r, s, i) : e[t] = Zo(s) } function Jr(t, e, n) { const i = st(e) ? e : [e], r = i.length; if (!W(t)) return t; n = n || {}; const s = n.merger || m_; let o; for (let a = 0; a < r; ++a) { if (o = i[a], !W(o)) continue; const l = Object.keys(o); for (let u = 0, c = l.length; u < c; ++u)s(l[u], t, o, n) } return t } function Mr(t, e) { return Jr(t, e, { merger: g_ }) } function g_(t, e, n) { if (!Qg(t)) return; const i = e[t], r = n[t]; W(i) && W(r) ? Mr(i, r) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Zo(r)) } const $d = { "": t => t, x: t => t.x, y: t => t.y }; function v_(t) { const e = t.split("."), n = []; let i = ""; for (const r of e) i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = ""); return n } function y_(t) { const e = v_(t); return n => { for (const i of e) { if (i === "") break; n = n && n[i] } return n } } function qo(t, e) { return ($d[e] || ($d[e] = y_(e)))(t) } function Uc(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const be = t => typeof t < "u", Mn = t => typeof t == "function", Vd = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }; function x_(t) { return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu" } const bt = Math.PI, Jt = 2 * bt, __ = Jt + bt, Jo = Number.POSITIVE_INFINITY, b_ = bt / 180, Wt = bt / 2, An = bt / 4, Ud = bt * 2 / 3, un = Math.log10, Wi = Math.sign; function Er(t, e, n) { return Math.abs(t - e) < n } function Yd(t) { const e = Math.round(t); t = Er(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(un(t))), i = t / n; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n } function w_(t) { const e = [], n = Math.sqrt(t); let i; for (i = 1; i < n; i++)t % i === 0 && (e.push(i), e.push(t / i)); return n === (n | 0) && e.push(n), e.sort((r, s) => r - s).pop(), e } function ts(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function k_(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function Gg(t, e, n) { let i, r, s; for (i = 0, r = t.length; i < r; i++)s = t[i][n], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function cn(t) { return t * (bt / 180) } function Yc(t) { return t * (180 / bt) } function Xd(t) { if (!ht(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function S_(t, e) { const n = e.x - t.x, i = e.y - t.y, r = Math.sqrt(n * n + i * i); let s = Math.atan2(i, n); return s < -.5 * bt && (s += Jt), { angle: s, distance: r } } function Pu(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function C_(t, e) { return (t - e + __) % Jt - bt } function Gt(t) { return (t % Jt + Jt) % Jt } function Zg(t, e, n, i) { const r = Gt(t), s = Gt(e), o = Gt(n), a = Gt(s - r), l = Gt(o - r), u = Gt(r - s), c = Gt(r - o); return r === s || r === o || i && s === o || a > l && u < c } function le(t, e, n) { return Math.max(e, Math.min(n, t)) } function P_(t) { return le(t, -32768, 32767) } function Si(t, e, n, i = 1e-6) { return t >= Math.min(e, n) - i && t <= Math.max(e, n) + i } function Xc(t, e, n) { n = n || (o => t[o] < e); let i = t.length - 1, r = 0, s; for (; i - r > 1;)s = r + i >> 1, n(s) ? r = s : i = s; return { lo: r, hi: i } } const Un = (t, e, n, i) => Xc(t, n, i ? r => { const s = t[r][e]; return s < n || s === n && t[r + 1][e] === n } : r => t[r][e] < n), M_ = (t, e, n) => Xc(t, n, i => t[i][e] >= n); function E_(t, e, n) { let i = 0, r = t.length; for (; i < r && t[i] < e;)i++; for (; r > i && t[r - 1] > n;)r--; return i > 0 || r < t.length ? t.slice(i, r) : t } const qg = ["push", "pop", "shift", "splice", "unshift"]; function O_(t, e) { if (t._chartjs) { t._chartjs.listeners.push(e); return } Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), qg.forEach(n => { const i = "_onData" + Uc(n), r = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...s) { const o = r.apply(this, s); return t._chartjs.listeners.forEach(a => { typeof a[i] == "function" && a[i](...s) }), o } }) }) } function Kd(t, e) { const n = t._chartjs; if (!n) return; const i = n.listeners, r = i.indexOf(e); r !== -1 && i.splice(r, 1), !(i.length > 0) && (qg.forEach(s => { delete t[s] }), delete t._chartjs) } function T_(t) { const e = new Set; let n, i; for (n = 0, i = t.length; n < i; ++n)e.add(t[n]); return e.size === i ? t : Array.from(e) } const Jg = function () { return typeof window > "u" ? function (t) { return t() } : window.requestAnimationFrame }(); function t0(t, e) { let n = !1; return function (...i) { n || (n = !0, Jg.call(window, () => { n = !1, t.apply(e, i) })) } } function L_(t, e) { let n; return function (...i) { return e ? (clearTimeout(n), n = setTimeout(t, e, i)) : t.apply(this, i), e } } const Kc = t => t === "start" ? "left" : t === "end" ? "right" : "center", Tt = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, A_ = (t, e, n, i) => t === (i ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e; function D_(t, e, n) { const i = e.length; let r = 0, s = i; if (t._sorted) { const { iScale: o, _parsed: a } = t, l = o.axis, { min: u, max: c, minDefined: f, maxDefined: d } = o.getUserBounds(); f && (r = le(Math.min(Un(a, o.axis, u).lo, n ? i : Un(e, l, o.getPixelForValue(u)).lo), 0, i - 1)), d ? s = le(Math.max(Un(a, o.axis, c, !0).hi + 1, n ? 0 : Un(e, l, o.getPixelForValue(c), !0).hi + 1), r, i) - r : s = i - r } return { start: r, count: s } } function N_(t) { const { xScale: e, yScale: n, _scaleRanges: i } = t, r = { xmin: e.min, xmax: e.max, ymin: n.min, ymax: n.max }; if (!i) return t._scaleRanges = r, !0; const s = i.xmin !== e.min || i.xmax !== e.max || i.ymin !== n.min || i.ymax !== n.max; return Object.assign(i, r), s } const Ws = t => t === 0 || t === 1, Qd = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Jt / n)), Gd = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * Jt / n) + 1, vo = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => -Math.cos(t * Wt) + 1, easeOutSine: t => Math.sin(t * Wt), easeInOutSine: t => -.5 * (Math.cos(bt * t) - 1), easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1, easeInOutExpo: t => Ws(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Ws(t) ? t : Qd(t, .075, .3), easeOutElastic: t => Ws(t) ? t : Gd(t, .075, .3), easeInOutElastic(t) { return Ws(t) ? t : t < .5 ? .5 * Qd(t * 2, .1125, .45) : .5 + .5 * Gd(t * 2 - 1, .1125, .45) }, easeInBack(t) { return t * t * ((1.70158 + 1) * t - 1.70158) }, easeOutBack(t) { return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: t => 1 - vo.easeOutBounce(1 - t), easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: t => t < .5 ? vo.easeInBounce(t * 2) * .5 : vo.easeOutBounce(t * 2 - 1) * .5 + .5 }; var Zd = vo; function hs(t) { return t + .5 | 0 } const fn = (t, e, n) => Math.max(Math.min(t, n), e); function hr(t) { return fn(hs(t * 2.55), 0, 255) } function bn(t) { return fn(hs(t * 255), 0, 255) } function Fe(t) { return fn(hs(t / 2.55) / 100, 0, 1) } function qd(t) { return fn(hs(t * 100), 0, 100) } const re = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Mu = [..."0123456789ABCDEF"], I_ = t => Mu[t & 15], z_ = t => Mu[(t & 240) >> 4] + Mu[t & 15], $s = t => (t & 240) >> 4 === (t & 15), R_ = t => $s(t.r) && $s(t.g) && $s(t.b) && $s(t.a); function F_(t) { var e = t.length, n; return t[0] === "#" && (e === 4 || e === 5 ? n = { r: 255 & re[t[1]] * 17, g: 255 & re[t[2]] * 17, b: 255 & re[t[3]] * 17, a: e === 5 ? re[t[4]] * 17 : 255 } : (e === 7 || e === 9) && (n = { r: re[t[1]] << 4 | re[t[2]], g: re[t[3]] << 4 | re[t[4]], b: re[t[5]] << 4 | re[t[6]], a: e === 9 ? re[t[7]] << 4 | re[t[8]] : 255 })), n } const j_ = (t, e) => t < 255 ? e(t) : ""; function B_(t) { var e = R_(t) ? I_ : z_; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + j_(t.a, e) : void 0 } const H_ = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function e0(t, e, n) { const i = e * Math.min(n, 1 - n), r = (s, o = (s + t / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [r(0), r(8), r(4)] } function W_(t, e, n) { const i = (r, s = (r + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0); return [i(5), i(3), i(1)] } function $_(t, e, n) { const i = e0(t, 1, .5); let r; for (e + n > 1 && (r = 1 / (e + n), e *= r, n *= r), r = 0; r < 3; r++)i[r] *= 1 - e - n, i[r] += e; return i } function V_(t, e, n, i, r) { return t === r ? (e - n) / i + (e < n ? 6 : 0) : e === r ? (n - t) / i + 2 : (t - e) / i + 4 } function Qc(t) { const n = t.r / 255, i = t.g / 255, r = t.b / 255, s = Math.max(n, i, r), o = Math.min(n, i, r), a = (s + o) / 2; let l, u, c; return s !== o && (c = s - o, u = a > .5 ? c / (2 - s - o) : c / (s + o), l = V_(n, i, r, c, s), l = l * 60 + .5), [l | 0, u || 0, a] } function Gc(t, e, n, i) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, i)).map(bn) } function Zc(t, e, n) { return Gc(e0, t, e, n) } function U_(t, e, n) { return Gc($_, t, e, n) } function Y_(t, e, n) { return Gc(W_, t, e, n) } function n0(t) { return (t % 360 + 360) % 360 } function X_(t) { const e = H_.exec(t); let n = 255, i; if (!e) return; e[5] !== i && (n = e[6] ? hr(+e[5]) : bn(+e[5])); const r = n0(+e[2]), s = +e[3] / 100, o = +e[4] / 100; return e[1] === "hwb" ? i = U_(r, s, o) : e[1] === "hsv" ? i = Y_(r, s, o) : i = Zc(r, s, o), { r: i[0], g: i[1], b: i[2], a: n } } function K_(t, e) { var n = Qc(t); n[0] = n0(n[0] + e), n = Zc(n), t.r = n[0], t.g = n[1], t.b = n[2] } function Q_(t) { if (!t) return; const e = Qc(t), n = e[0], i = qd(e[1]), r = qd(e[2]); return t.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${Fe(t.a)})` : `hsl(${n}, ${i}%, ${r}%)` } const Jd = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, th = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function G_() { const t = {}, e = Object.keys(th), n = Object.keys(Jd); let i, r, s, o, a; for (i = 0; i < e.length; i++) { for (o = a = e[i], r = 0; r < n.length; r++)s = n[r], a = a.replace(s, Jd[s]); s = parseInt(th[o], 16), t[a] = [s >> 16 & 255, s >> 8 & 255, s & 255] } return t } let Vs; function Z_(t) { Vs || (Vs = G_(), Vs.transparent = [0, 0, 0, 0]); const e = Vs[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const q_ = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function J_(t) { const e = q_.exec(t); let n = 255, i, r, s; if (!!e) { if (e[7] !== i) { const o = +e[7]; n = e[8] ? hr(o) : fn(o * 255, 0, 255) } return i = +e[1], r = +e[3], s = +e[5], i = 255 & (e[2] ? hr(i) : fn(i, 0, 255)), r = 255 & (e[4] ? hr(r) : fn(r, 0, 255)), s = 255 & (e[6] ? hr(s) : fn(s, 0, 255)), { r: i, g: r, b: s, a: n } } } function tb(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Fe(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) } const cl = t => t <= .0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - .055, li = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function eb(t, e, n) { const i = li(Fe(t.r)), r = li(Fe(t.g)), s = li(Fe(t.b)); return { r: bn(cl(i + n * (li(Fe(e.r)) - i))), g: bn(cl(r + n * (li(Fe(e.g)) - r))), b: bn(cl(s + n * (li(Fe(e.b)) - s))), a: t.a + n * (e.a - t.a) } } function Us(t, e, n) { if (t) { let i = Qc(t); i[e] = Math.max(0, Math.min(i[e] + i[e] * n, e === 0 ? 360 : 1)), i = Zc(i), t.r = i[0], t.g = i[1], t.b = i[2] } } function i0(t, e) { return t && Object.assign(e || {}, t) } function eh(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = bn(t[3]))) : (e = i0(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = bn(e.a)), e } function nb(t) { return t.charAt(0) === "r" ? J_(t) : X_(t) } class ta { constructor(e) { if (e instanceof ta) return e; const n = typeof e; let i; n === "object" ? i = eh(e) : n === "string" && (i = F_(e) || Z_(e) || nb(e)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var e = i0(this._rgb); return e && (e.a = Fe(e.a)), e } set rgb(e) { this._rgb = eh(e) } rgbString() { return this._valid ? tb(this._rgb) : void 0 } hexString() { return this._valid ? B_(this._rgb) : void 0 } hslString() { return this._valid ? Q_(this._rgb) : void 0 } mix(e, n) { if (e) { const i = this.rgb, r = e.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = i.a - r.a, u = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - u, i.r = 255 & u * i.r + s * r.r + .5, i.g = 255 & u * i.g + s * r.g + .5, i.b = 255 & u * i.b + s * r.b + .5, i.a = o * i.a + (1 - o) * r.a, this.rgb = i } return this } interpolate(e, n) { return e && (this._rgb = eb(this._rgb, e._rgb, n)), this } clone() { return new ta(this.rgb) } alpha(e) { return this._rgb.a = bn(e), this } clearer(e) { const n = this._rgb; return n.a *= 1 - e, this } greyscale() { const e = this._rgb, n = hs(e.r * .3 + e.g * .59 + e.b * .11); return e.r = e.g = e.b = n, this } opaquer(e) { const n = this._rgb; return n.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return Us(this._rgb, 2, e), this } darken(e) { return Us(this._rgb, 2, -e), this } saturate(e) { return Us(this._rgb, 1, e), this } desaturate(e) { return Us(this._rgb, 1, -e), this } rotate(e) { return K_(this._rgb, e), this } } function r0(t) { return new ta(t) } function s0(t) { if (t && typeof t == "object") { const e = t.toString(); return e === "[object CanvasPattern]" || e === "[object CanvasGradient]" } return !1 } function nh(t) { return s0(t) ? t : r0(t) } function fl(t) { return s0(t) ? t : r0(t).saturate(.5).darken(.1).hexString() } const ib = ["x", "y", "borderWidth", "radius", "tension"], rb = ["color", "borderColor", "backgroundColor"]; function sb(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn" }), t.set("animations", { colors: { type: "color", properties: rb }, numbers: { type: "number", properties: ib } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => e | 0 } } } }) } function ob(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const ih = new Map; function ab(t, e) { e = e || {}; const n = t + JSON.stringify(e); let i = ih.get(n); return i || (i = new Intl.NumberFormat(t, e), ih.set(n, i)), i } function qc(t, e, n) { return ab(e, n).format(t) } const o0 = { values(t) { return st(t) ? t : "" + t }, numeric(t, e, n) { if (t === 0) return "0"; const i = this.chart.options.locale; let r, s = t; if (n.length > 1) { const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (u < 1e-4 || u > 1e15) && (r = "scientific"), s = lb(t, n) } const o = un(Math.abs(s)), a = Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: r, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), qc(t, i, l) }, logarithmic(t, e, n) { if (t === 0) return "0"; const i = n[e].significand || t / Math.pow(10, Math.floor(un(t))); return [1, 2, 3, 5, 10, 15].includes(i) || e > .8 * n.length ? o0.numeric.call(this, t, e, n) : "" } }; function lb(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n } var Ea = { formatters: o0 }; function ub(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Ea.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser", _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash" }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => e !== "backdropPadding" && e !== "callback", _indexable: e => e !== "backdropPadding" }) } const ni = Object.create(null), Eu = Object.create(null); function Or(t, e) { if (!e) return t; const n = e.split("."); for (let i = 0, r = n.length; i < r; ++i) { const s = n[i]; t = t[s] || (t[s] = Object.create(null)) } return t } function dl(t, e, n) { return typeof e == "string" ? Jr(Or(t, e), n) : Jr(Or(t, ""), e) } class cb { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = i => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (i, r) => fl(r.backgroundColor), this.hoverBorderColor = (i, r) => fl(r.borderColor), this.hoverColor = (i, r) => fl(r.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return dl(this, e, n) } get(e) { return Or(this, e) } describe(e, n) { return dl(Eu, e, n) } override(e, n) { return dl(ni, e, n) } route(e, n, i, r) { const s = Or(this, e), o = Or(this, i), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], u = o[r]; return W(l) ? Object.assign({}, u, l) : j(l, u) }, set(l) { this[a] = l } } }) } apply(e) { e.forEach(n => n(this)) } } var mt = new cb({ _scriptable: t => !t.startsWith("on"), _indexable: t => t !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [sb, ob, ub]); function fb(t) { return !t || et(t.size) || et(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function ea(t, e, n, i, r) { let s = e[r]; return s || (s = e[r] = t.measureText(r).width, n.push(r)), s > i && (i = s), i } function db(t, e, n, i) { i = i || {}; let r = i.data = i.data || {}, s = i.garbageCollect = i.garbageCollect || []; i.font !== e && (r = i.data = {}, s = i.garbageCollect = [], i.font = e), t.save(), t.font = e; let o = 0; const a = n.length; let l, u, c, f, d; for (l = 0; l < a; l++)if (f = n[l], f != null && st(f) !== !0) o = ea(t, r, s, o, f); else if (st(f)) for (u = 0, c = f.length; u < c; u++)d = f[u], d != null && !st(d) && (o = ea(t, r, s, o, d)); t.restore(); const h = s.length / 2; if (h > n.length) { for (l = 0; l < h; l++)delete r[s[l]]; s.splice(0, h) } return o } function Dn(t, e, n) { const i = t.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((e - r) * i) / i + r } function rh(t, e) { e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function Ou(t, e, n, i) { a0(t, e, n, i, null) } function a0(t, e, n, i, r) { let s, o, a, l, u, c, f, d; const h = e.pointStyle, g = e.rotation, v = e.radius; let x = (g || 0) * b_; if (h && typeof h == "object" && (s = h.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) { t.save(), t.translate(n, i), t.rotate(x), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t.restore(); return } if (!(isNaN(v) || v <= 0)) { switch (t.beginPath(), h) { default: r ? t.ellipse(n, i, r / 2, v, 0, 0, Jt) : t.arc(n, i, v, 0, Jt), t.closePath(); break; case "triangle": c = r ? r / 2 : v, t.moveTo(n + Math.sin(x) * c, i - Math.cos(x) * v), x += Ud, t.lineTo(n + Math.sin(x) * c, i - Math.cos(x) * v), x += Ud, t.lineTo(n + Math.sin(x) * c, i - Math.cos(x) * v), t.closePath(); break; case "rectRounded": u = v * .516, l = v - u, o = Math.cos(x + An) * l, f = Math.cos(x + An) * (r ? r / 2 - u : l), a = Math.sin(x + An) * l, d = Math.sin(x + An) * (r ? r / 2 - u : l), t.arc(n - f, i - a, u, x - bt, x - Wt), t.arc(n + d, i - o, u, x - Wt, x), t.arc(n + f, i + a, u, x, x + Wt), t.arc(n - d, i + o, u, x + Wt, x + bt), t.closePath(); break; case "rect": if (!g) { l = Math.SQRT1_2 * v, c = r ? r / 2 : l, t.rect(n - c, i - l, 2 * c, 2 * l); break } x += An; case "rectRot": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, d = Math.sin(x) * (r ? r / 2 : v), t.moveTo(n - f, i - a), t.lineTo(n + d, i - o), t.lineTo(n + f, i + a), t.lineTo(n - d, i + o), t.closePath(); break; case "crossRot": x += An; case "cross": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, d = Math.sin(x) * (r ? r / 2 : v), t.moveTo(n - f, i - a), t.lineTo(n + f, i + a), t.moveTo(n + d, i - o), t.lineTo(n - d, i + o); break; case "star": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, d = Math.sin(x) * (r ? r / 2 : v), t.moveTo(n - f, i - a), t.lineTo(n + f, i + a), t.moveTo(n + d, i - o), t.lineTo(n - d, i + o), x += An, f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, d = Math.sin(x) * (r ? r / 2 : v), t.moveTo(n - f, i - a), t.lineTo(n + f, i + a), t.moveTo(n + d, i - o), t.lineTo(n - d, i + o); break; case "line": o = r ? r / 2 : Math.cos(x) * v, a = Math.sin(x) * v, t.moveTo(n - o, i - a), t.lineTo(n + o, i + a); break; case "dash": t.moveTo(n, i), t.lineTo(n + Math.cos(x) * (r ? r / 2 : v), i + Math.sin(x) * v); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function es(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function Oa(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function Ta(t) { t.restore() } function hb(t, e, n, i, r) { if (!e) return t.lineTo(n.x, n.y); if (r === "middle") { const s = (e.x + n.x) / 2; t.lineTo(s, e.y), t.lineTo(s, n.y) } else r === "after" != !!i ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y); t.lineTo(n.x, n.y) } function pb(t, e, n, i) { if (!e) return t.lineTo(n.x, n.y); t.bezierCurveTo(i ? e.cp1x : e.cp2x, i ? e.cp1y : e.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y) } function ii(t, e, n, i, r, s = {}) { const o = st(e) ? e : [e], a = s.strokeWidth > 0 && s.strokeColor !== ""; let l, u; for (t.save(), t.font = r.string, mb(t, s), l = 0; l < o.length; ++l)u = o[l], s.backdrop && vb(t, s.backdrop), a && (s.strokeColor && (t.strokeStyle = s.strokeColor), et(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(u, n, i, s.maxWidth)), t.fillText(u, n, i, s.maxWidth), gb(t, n, i, u, s), i += r.lineHeight; t.restore() } function mb(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), et(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function gb(t, e, n, i, r) { if (r.strikethrough || r.underline) { const s = t.measureText(i), o = e - s.actualBoundingBoxLeft, a = e + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, u = n + s.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = r.decorationWidth || 2, t.moveTo(o, c), t.lineTo(a, c), t.stroke() } } function vb(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function na(t, e) { const { x: n, y: i, w: r, h: s, radius: o } = e; t.arc(n + o.topLeft, i + o.topLeft, o.topLeft, -Wt, bt, !0), t.lineTo(n, i + s - o.bottomLeft), t.arc(n + o.bottomLeft, i + s - o.bottomLeft, o.bottomLeft, bt, Wt, !0), t.lineTo(n + r - o.bottomRight, i + s), t.arc(n + r - o.bottomRight, i + s - o.bottomRight, o.bottomRight, Wt, 0, !0), t.lineTo(n + r, i + o.topRight), t.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -Wt, !0), t.lineTo(n + o.topLeft, i) } const yb = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, xb = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function _b(t, e) { const n = ("" + t).match(yb); if (!n || n[1] === "normal") return e * 1.2; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; break }return e * t } const bb = t => +t || 0; function l0(t, e) { const n = {}, i = W(e), r = i ? Object.keys(e) : e, s = W(t) ? i ? o => j(t[o], t[e[o]]) : o => t[o] : () => t; for (const o of r) n[o] = bb(s(o)); return n } function wb(t) { return l0(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Ai(t) { return l0(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Dt(t) { const e = wb(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function xt(t, e) { t = t || {}, e = e || mt.font; let n = j(t.size, e.size); typeof n == "string" && (n = parseInt(n, 10)); let i = j(t.style, e.style); i && !("" + i).match(xb) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0); const r = { family: j(t.family, e.family), lineHeight: _b(j(t.lineHeight, e.lineHeight), n), size: n, style: i, weight: j(t.weight, e.weight), string: "" }; return r.string = fb(r), r } function Ys(t, e, n, i) { let r = !0, s, o, a; for (s = 0, o = t.length; s < o; ++s)if (a = t[s], a !== void 0 && (e !== void 0 && typeof a == "function" && (a = a(e), r = !1), n !== void 0 && st(a) && (a = a[n % a.length], r = !1), a !== void 0)) return i && !r && (i.cacheable = !1), a } function kb(t, e, n) { const { min: i, max: r } = t, s = p_(e, (r - i) / 2), o = (a, l) => n && a === 0 ? 0 : a + l; return { min: o(i, -Math.abs(s)), max: o(r, s) } } function Ln(t, e) { return Object.assign(Object.create(t), e) } function Jc(t, e = [""], n = t, i, r = () => t[0]) { be(i) || (i = d0("_fallback", t)); const s = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: n, _fallback: i, _getTarget: r, override: o => Jc([o, ...t], e, n, i) }; return new Proxy(s, { deleteProperty(o, a) { return delete o[a], delete o._keys, delete t[0][a], !0 }, get(o, a) { return c0(o, a, () => Lb(a, e, t, o)) }, getOwnPropertyDescriptor(o, a) { return Reflect.getOwnPropertyDescriptor(o._scopes[0], a) }, getPrototypeOf() { return Reflect.getPrototypeOf(t[0]) }, has(o, a) { return oh(o).includes(a) }, ownKeys(o) { return oh(o) }, set(o, a, l) { const u = o._storage || (o._storage = r()); return o[a] = u[a] = l, delete o._keys, !0 } }) } function $i(t, e, n, i) { const r = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: u0(t, i), setContext: s => $i(t, s, n, i), override: s => $i(t.override(s), e, n, i) }; return new Proxy(r, { deleteProperty(s, o) { return delete s[o], delete t[o], !0 }, get(s, o, a) { return c0(s, o, () => Cb(s, o, a)) }, getOwnPropertyDescriptor(s, o) { return s._descriptors.allKeys ? Reflect.has(t, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, o) }, getPrototypeOf() { return Reflect.getPrototypeOf(t) }, has(s, o) { return Reflect.has(t, o) }, ownKeys() { return Reflect.ownKeys(t) }, set(s, o, a) { return t[o] = a, delete s[o], !0 } }) } function u0(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: i = e.indexable, _allKeys: r = e.allKeys } = t; return { allKeys: r, scriptable: n, indexable: i, isScriptable: Mn(n) ? n : () => n, isIndexable: Mn(i) ? i : () => i } } const Sb = (t, e) => t ? t + Uc(e) : e, tf = (t, e) => W(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object); function c0(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const i = n(); return t[e] = i, i } function Cb(t, e, n) { const { _proxy: i, _context: r, _subProxy: s, _descriptors: o } = t; let a = i[e]; return Mn(a) && o.isScriptable(e) && (a = Pb(e, a, t, n)), st(a) && a.length && (a = Mb(e, a, t, o.isIndexable)), tf(e, a) && (a = $i(a, r, s && s[e], o)), a } function Pb(t, e, n, i) { const { _proxy: r, _context: s, _subProxy: o, _stack: a } = n; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); return a.add(t), e = e(s, o || i), a.delete(t), tf(t, e) && (e = ef(r._scopes, r, t, e)), e } function Mb(t, e, n, i) { const { _proxy: r, _context: s, _subProxy: o, _descriptors: a } = n; if (be(s.index) && i(t)) e = e[s.index % e.length]; else if (W(e[0])) { const l = e, u = r._scopes.filter(c => c !== l); e = []; for (const c of l) { const f = ef(u, r, t, c); e.push($i(f, s, o && o[t], a)) } } return e } function f0(t, e, n) { return Mn(t) ? t(e, n) : t } const Eb = (t, e) => t === !0 ? e : typeof t == "string" ? qo(e, t) : void 0; function Ob(t, e, n, i, r) { for (const s of e) { const o = Eb(n, s); if (o) { t.add(o); const a = f0(o._fallback, n, r); if (be(a) && a !== n && a !== i) return a } else if (o === !1 && be(i) && n !== i) return null } return !1 } function ef(t, e, n, i) { const r = e._rootScopes, s = f0(e._fallback, n, i), o = [...t, ...r], a = new Set; a.add(i); let l = sh(a, o, n, s || n, i); return l === null || be(s) && s !== n && (l = sh(a, o, s, l, i), l === null) ? !1 : Jc(Array.from(a), [""], r, s, () => Tb(e, n, i)) } function sh(t, e, n, i, r) { for (; n;)n = Ob(t, e, n, i, r); return n } function Tb(t, e, n) { const i = t._getTarget(); e in i || (i[e] = {}); const r = i[e]; return st(r) && W(n) ? n : r || {} } function Lb(t, e, n, i) { let r; for (const s of e) if (r = d0(Sb(s, t), n), be(r)) return tf(t, r) ? ef(n, i, t, r) : r } function d0(t, e) { for (const n of e) { if (!n) continue; const i = n[t]; if (be(i)) return i } } function oh(t) { let e = t._keys; return e || (e = t._keys = Ab(t._scopes)), e } function Ab(t) { const e = new Set; for (const n of t) for (const i of Object.keys(n).filter(r => !r.startsWith("_"))) e.add(i); return Array.from(e) } const Db = Number.EPSILON || 1e-14, Vi = (t, e) => e < t.length && !t[e].skip && t[e], h0 = t => t === "x" ? "y" : "x"; function Nb(t, e, n, i) { const r = t.skip ? e : t, s = e, o = n.skip ? e : n, a = Pu(s, r), l = Pu(o, s); let u = a / (a + l), c = l / (a + l); u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c; const f = i * u, d = i * c; return { previous: { x: s.x - f * (o.x - r.x), y: s.y - f * (o.y - r.y) }, next: { x: s.x + d * (o.x - r.x), y: s.y + d * (o.y - r.y) } } } function Ib(t, e, n) { const i = t.length; let r, s, o, a, l, u = Vi(t, 0); for (let c = 0; c < i - 1; ++c)if (l = u, u = Vi(t, c + 1), !(!l || !u)) { if (Er(e[c], 0, Db)) { n[c] = n[c + 1] = 0; continue } r = n[c] / e[c], s = n[c + 1] / e[c], a = Math.pow(r, 2) + Math.pow(s, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[c] = r * o * e[c], n[c + 1] = s * o * e[c]) } } function zb(t, e, n = "x") { const i = h0(n), r = t.length; let s, o, a, l = Vi(t, 0); for (let u = 0; u < r; ++u) { if (o = a, a = l, l = Vi(t, u + 1), !a) continue; const c = a[n], f = a[i]; o && (s = (c - o[n]) / 3, a[`cp1${n}`] = c - s, a[`cp1${i}`] = f - s * e[u]), l && (s = (l[n] - c) / 3, a[`cp2${n}`] = c + s, a[`cp2${i}`] = f + s * e[u]) } } function Rb(t, e = "x") { const n = h0(e), i = t.length, r = Array(i).fill(0), s = Array(i); let o, a, l, u = Vi(t, 0); for (o = 0; o < i; ++o)if (a = l, l = u, u = Vi(t, o + 1), !!l) { if (u) { const c = u[e] - l[e]; r[o] = c !== 0 ? (u[n] - l[n]) / c : 0 } s[o] = a ? u ? Wi(r[o - 1]) !== Wi(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o] } Ib(t, r, s), zb(t, s, e) } function Xs(t, e, n) { return Math.max(Math.min(t, n), e) } function Fb(t, e) { let n, i, r, s, o, a = es(t[0], e); for (n = 0, i = t.length; n < i; ++n)o = s, s = a, a = n < i - 1 && es(t[n + 1], e), s && (r = t[n], o && (r.cp1x = Xs(r.cp1x, e.left, e.right), r.cp1y = Xs(r.cp1y, e.top, e.bottom)), a && (r.cp2x = Xs(r.cp2x, e.left, e.right), r.cp2y = Xs(r.cp2y, e.top, e.bottom))) } function jb(t, e, n, i, r) { let s, o, a, l; if (e.spanGaps && (t = t.filter(u => !u.skip)), e.cubicInterpolationMode === "monotone") Rb(t, r); else { let u = i ? t[t.length - 1] : t[0]; for (s = 0, o = t.length; s < o; ++s)a = t[s], l = Nb(u, a, t[Math.min(s + 1, o - (i ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, u = a } e.capBezierPoints && Fb(t, n) } function p0() { return typeof window < "u" && typeof document < "u" } function nf(t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e } function ia(t, e, n) { let i; return typeof t == "string" ? (i = parseInt(t, 10), t.indexOf("%") !== -1 && (i = i / 100 * e.parentNode[n])) : i = t, i } const La = t => t.ownerDocument.defaultView.getComputedStyle(t, null); function Bb(t, e) { return La(t).getPropertyValue(e) } const Hb = ["top", "right", "bottom", "left"]; function Kn(t, e, n) { const i = {}; n = n ? "-" + n : ""; for (let r = 0; r < 4; r++) { const s = Hb[r]; i[s] = parseFloat(t[e + "-" + s + n]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } const Wb = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot); function $b(t, e) { const n = t.touches, i = n && n.length ? n[0] : t, { offsetX: r, offsetY: s } = i; let o = !1, a, l; if (Wb(r, s, t.target)) a = r, l = s; else { const u = e.getBoundingClientRect(); a = i.clientX - u.left, l = i.clientY - u.top, o = !0 } return { x: a, y: l, box: o } } function Fn(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: i } = e, r = La(n), s = r.boxSizing === "border-box", o = Kn(r, "padding"), a = Kn(r, "border", "width"), { x: l, y: u, box: c } = $b(t, n), f = o.left + (c && a.left), d = o.top + (c && a.top); let { width: h, height: g } = e; return s && (h -= o.width + a.width, g -= o.height + a.height), { x: Math.round((l - f) / h * n.width / i), y: Math.round((u - d) / g * n.height / i) } } function Vb(t, e, n) { let i, r; if (e === void 0 || n === void 0) { const s = nf(t); if (!s) e = t.clientWidth, n = t.clientHeight; else { const o = s.getBoundingClientRect(), a = La(s), l = Kn(a, "border", "width"), u = Kn(a, "padding"); e = o.width - u.width - l.width, n = o.height - u.height - l.height, i = ia(a.maxWidth, s, "clientWidth"), r = ia(a.maxHeight, s, "clientHeight") } } return { width: e, height: n, maxWidth: i || Jo, maxHeight: r || Jo } } const Ks = t => Math.round(t * 10) / 10; function Ub(t, e, n, i) { const r = La(t), s = Kn(r, "margin"), o = ia(r.maxWidth, t, "clientWidth") || Jo, a = ia(r.maxHeight, t, "clientHeight") || Jo, l = Vb(t, e, n); let { width: u, height: c } = l; if (r.boxSizing === "content-box") { const d = Kn(r, "border", "width"), h = Kn(r, "padding"); u -= h.width + d.width, c -= h.height + d.height } return u = Math.max(0, u - s.width), c = Math.max(0, i ? Math.floor(u / i) : c - s.height), u = Ks(Math.min(u, o, l.maxWidth)), c = Ks(Math.min(c, a, l.maxHeight)), u && !c && (c = Ks(u / 2)), (e !== void 0 || n !== void 0) && i && l.height && c > l.height && (c = l.height, u = Ks(Math.floor(c * i))), { width: u, height: c } } function ah(t, e, n) { const i = e || 1, r = Math.floor(t.height * i), s = Math.floor(t.width * i); t.height = r / i, t.width = s / i; const o = t.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== i || o.height !== r || o.width !== s ? (t.currentDevicePixelRatio = i, o.height = r, o.width = s, t.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1 } const Yb = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch { } return t }(); function lh(t, e) { const n = Bb(t, e), i = n && n.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } function jn(t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) } } function Xb(t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: i === "middle" ? n < .5 ? t.y : e.y : i === "after" ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y } } function Kb(t, e, n, i) { const r = { x: t.cp2x, y: t.cp2y }, s = { x: e.cp1x, y: e.cp1y }, o = jn(t, r, n), a = jn(r, s, n), l = jn(s, e, n), u = jn(o, a, n), c = jn(a, l, n); return jn(u, c, n) } const Qb = function (t, e) { return { x(n) { return t + t + e - n }, setWidth(n) { e = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, i) { return n - i }, leftForLtr(n, i) { return n - i } } }, Gb = function () { return { x(t) { return t }, setWidth(t) { }, textAlign(t) { return t }, xPlus(t, e) { return t + e }, leftForLtr(t, e) { return t } } }; function Di(t, e, n) { return t ? Qb(e, n) : Gb() } function m0(t, e) { let n, i; (e === "ltr" || e === "rtl") && (n = t.canvas.style, i = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = i) } function g0(t, e) { e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) } function v0(t) { return t === "angle" ? { between: Zg, compare: C_, normalize: Gt } : { between: Si, compare: (e, n) => e - n, normalize: e => e } } function uh({ start: t, end: e, count: n, loop: i, style: r }) { return { start: t % n, end: e % n, loop: i && (e - t + 1) % n === 0, style: r } } function Zb(t, e, n) { const { property: i, start: r, end: s } = n, { between: o, normalize: a } = v0(i), l = e.length; let { start: u, end: c, loop: f } = t, d, h; if (f) { for (u += l, c += l, d = 0, h = l; d < h && o(a(e[u % l][i]), r, s); ++d)u--, c--; u %= l, c %= l } return c < u && (c += l), { start: u, end: c, loop: f, style: t.style } } function y0(t, e, n) { if (!n) return [t]; const { property: i, start: r, end: s } = n, o = e.length, { compare: a, between: l, normalize: u } = v0(i), { start: c, end: f, loop: d, style: h } = Zb(t, e, n), g = []; let v = !1, x = null, m, p, y; const _ = () => l(r, y, m) && a(r, y) !== 0, b = () => a(s, m) === 0 || l(s, y, m), w = () => v || _(), k = () => !v || b(); for (let S = c, P = c; S <= f; ++S)p = e[S % o], !p.skip && (m = u(p[i]), m !== y && (v = l(m, r, s), x === null && w() && (x = a(m, r) === 0 ? S : P), x !== null && k() && (g.push(uh({ start: x, end: S, loop: d, count: o, style: h })), x = null), P = S, y = m)); return x !== null && g.push(uh({ start: x, end: f, loop: d, count: o, style: h })), g } function x0(t, e) { const n = [], i = t.segments; for (let r = 0; r < i.length; r++) { const s = y0(i[r], t.points, e); s.length && n.push(...s) } return n } function qb(t, e, n, i) { let r = 0, s = e - 1; if (n && !i) for (; r < e && !t[r].skip;)r++; for (; r < e && t[r].skip;)r++; for (r %= e, n && (s += r); s > r && t[s % e].skip;)s--; return s %= e, { start: r, end: s } } function Jb(t, e, n, i) { const r = t.length, s = []; let o = e, a = t[e], l; for (l = e + 1; l <= n; ++l) { const u = t[l % r]; u.skip || u.stop ? a.skip || (i = !1, s.push({ start: e % r, end: (l - 1) % r, loop: i }), e = o = u.stop ? l : null) : (o = l, a.skip && (e = l)), a = u } return o !== null && s.push({ start: e % r, end: o % r, loop: i }), s } function tw(t, e) { const n = t.points, i = t.options.spanGaps, r = n.length; if (!r) return []; const s = !!t._loop, { start: o, end: a } = qb(n, r, s, i); if (i === !0) return ch(t, [{ start: o, end: a, loop: s }], n, e); const l = a < o ? a + r : a, u = !!t._fullLoop && o === 0 && a === r - 1; return ch(t, Jb(n, o, l, u), n, e) } function ch(t, e, n, i) { return !i || !i.setContext || !n ? e : ew(t, e, n, i) } function ew(t, e, n, i) { const r = t._chart.getContext(), s = fh(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, l = n.length, u = []; let c = s, f = e[0].start, d = f; function h(g, v, x, m) { const p = a ? -1 : 1; if (g !== v) { for (g += l; n[g % l].skip;)g -= p; for (; n[v % l].skip;)v += p; g % l !== v % l && (u.push({ start: g % l, end: v % l, loop: x, style: m }), c = m, f = v % l) } } for (const g of e) { f = a ? f : g.start; let v = n[f % l], x; for (d = f + 1; d <= g.end; d++) { const m = n[d % l]; x = fh(i.setContext(Ln(r, { type: "segment", p0: v, p1: m, p0DataIndex: (d - 1) % l, p1DataIndex: d % l, datasetIndex: o }))), nw(x, c) && h(f, d - 1, g.loop, c), v = m, c = x } f < d - 1 && h(f, d - 1, g.loop, c) } return u } function fh(t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function nw(t, e) { return e && JSON.stringify(t) !== JSON.stringify(e) } class iw { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, i, r) { const s = n.listeners[r], o = n.duration; s.forEach(a => a({ chart: e, initial: n.initial, numSteps: o, currentStep: Math.min(i - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = Jg.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((i, r) => { if (!i.running || !i.items.length) return; const s = i.items; let o = s.length - 1, a = !1, l; for (; o >= 0; --o)l = s[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(e), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (r.draw(), this._notify(r, i, e, "progress")), s.length || (i.running = !1, this._notify(r, i, e, "complete"), i.initial = !1), n += s.length }), this._lastDate = e, n === 0 && (this._running = !1) } _getAnims(e) { const n = this._charts; let i = n.get(e); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, i)), i } listen(e, n, i) { this._getAnims(e).listeners[n].push(i) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); !n || (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const i = n.items; let r = i.length - 1; for (; r >= 0; --r)i[r].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var Ne = new iw; const dh = "transparent", rw = { boolean(t, e, n) { return n > .5 ? e : t }, color(t, e, n) { const i = nh(t || dh), r = i.valid && nh(e || dh); return r && r.valid ? r.mix(i, n).hexString() : e }, number(t, e, n) { return t + (e - t) * n } }; class sw { constructor(e, n, i, r) { const s = n[i]; r = Ys([e.to, r, s, e.from]); const o = Ys([e.from, s, r]); this._active = !0, this._fn = e.fn || rw[e.type || typeof o], this._easing = Zd[e.easing] || Zd.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = i, this._from = o, this._to = r, this._promises = void 0 } active() { return this._active } update(e, n, i) { if (this._active) { this._notify(!1); const r = this._target[this._prop], s = i - this._start, o = this._duration - s; this._start = i, this._duration = Math.floor(Math.max(o, e.duration)), this._total += s, this._loop = !!e.loop, this._to = Ys([e.to, n, r, e.from]), this._from = Ys([e.from, r, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, i = this._duration, r = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < i), !this._active) { this._target[r] = a, this._notify(!0); return } if (n < 0) { this._target[r] = s; return } l = n / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(s, a, l) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, i) => { e.push({ res: n, rej: i }) }) } _notify(e) { const n = e ? "res" : "rej", i = this._promises || []; for (let r = 0; r < i.length; r++)i[r][n]() } } class _0 { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!W(e)) return; const n = Object.keys(mt.animation), i = this._properties; Object.getOwnPropertyNames(e).forEach(r => { const s = e[r]; if (!W(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (st(s.properties) && s.properties || [r]).forEach(a => { (a === r || !i.has(a)) && i.set(a, o) }) }) } _animateOptions(e, n) { const i = n.options, r = aw(e, i); if (!r) return []; const s = this._createAnimations(r, i); return i.$shared && ow(e.options.$animations, i).then(() => { e.options = i }, () => { }), s } _createAnimations(e, n) { const i = this._properties, r = [], s = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const u = o[l]; if (u.charAt(0) === "$") continue; if (u === "options") { r.push(...this._animateOptions(e, n)); continue } const c = n[u]; let f = s[u]; const d = i.get(u); if (f) if (d && f.active()) { f.update(d, c, a); continue } else f.cancel(); if (!d || !d.duration) { e[u] = c; continue } s[u] = f = new sw(d, e, u, c), r.push(f) } return r } update(e, n) { if (this._properties.size === 0) { Object.assign(e, n); return } const i = this._createAnimations(e, n); if (i.length) return Ne.add(this._chart, i), !0 } } function ow(t, e) { const n = [], i = Object.keys(e); for (let r = 0; r < i.length; r++) { const s = t[i[r]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) } function aw(t, e) { if (!e) return; let n = t.options; if (!n) { t.options = e; return } return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function hh(t, e) { const n = t && t.options || {}, i = n.reverse, r = n.min === void 0 ? e : 0, s = n.max === void 0 ? e : 0; return { start: i ? s : r, end: i ? r : s } } function lw(t, e, n) { if (n === !1) return !1; const i = hh(t, n), r = hh(e, n); return { top: r.end, right: i.end, bottom: r.start, left: i.start } } function uw(t) { let e, n, i, r; return W(t) ? (e = t.top, n = t.right, i = t.bottom, r = t.left) : e = n = i = r = t, { top: e, right: n, bottom: i, left: r, disabled: t === !1 } } function b0(t, e) { const n = [], i = t._getSortedDatasetMetas(e); let r, s; for (r = 0, s = i.length; r < s; ++r)n.push(i[r].index); return n } function ph(t, e, n, i = {}) { const r = t.keys, s = i.mode === "single"; let o, a, l, u; if (e !== null) { for (o = 0, a = r.length; o < a; ++o) { if (l = +r[o], l === n) { if (i.all) continue; break } u = t.values[l], ht(u) && (s || e === 0 || Wi(e) === Wi(u)) && (e += u) } return e } } function cw(t) { const e = Object.keys(t), n = new Array(e.length); let i, r, s; for (i = 0, r = e.length; i < r; ++i)s = e[i], n[i] = { x: s, y: t[s] }; return n } function mh(t, e) { const n = t && t.options.stacked; return n || n === void 0 && e.stack !== void 0 } function fw(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` } function dw(t) { const { min: e, max: n, minDefined: i, maxDefined: r } = t.getUserBounds(); return { min: i ? e : Number.NEGATIVE_INFINITY, max: r ? n : Number.POSITIVE_INFINITY } } function hw(t, e, n) { const i = t[e] || (t[e] = {}); return i[n] || (i[n] = {}) } function gh(t, e, n, i) { for (const r of e.getMatchingVisibleMetas(i).reverse()) { const s = t[r.index]; if (n && s > 0 || !n && s < 0) return r.index } return null } function vh(t, e) { const { chart: n, _cachedMeta: i } = t, r = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = i, l = s.axis, u = o.axis, c = fw(s, o, i), f = e.length; let d; for (let h = 0; h < f; ++h) { const g = e[h], { [l]: v, [u]: x } = g, m = g._stacks || (g._stacks = {}); d = m[u] = hw(r, c, v), d[a] = x, d._top = gh(d, o, !0, i.type), d._bottom = gh(d, o, !1, i.type) } } function hl(t, e) { const n = t.scales; return Object.keys(n).filter(i => n[i].axis === e).shift() } function pw(t, e) { return Ln(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) } function mw(t, e, n) { return Ln(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) } function ir(t, e) { const n = t.controller.index, i = t.vScale && t.vScale.axis; if (!!i) { e = e || t._parsed; for (const r of e) { const s = r._stacks; if (!s || s[i] === void 0 || s[i][n] === void 0) return; delete s[i][n] } } } const pl = t => t === "reset" || t === "none", yh = (t, e) => e ? t : Object.assign({}, t), gw = (t, e, n) => t && !e.hidden && e._stacked && { keys: b0(n, !0), values: null }; class Tr { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = mh(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && ir(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, i = this.getDataset(), r = (f, d, h, g) => f === "x" ? d : f === "r" ? g : h, s = n.xAxisID = j(i.xAxisID, hl(e, "x")), o = n.yAxisID = j(i.yAxisID, hl(e, "y")), a = n.rAxisID = j(i.rAxisID, hl(e, "r")), l = n.indexAxis, u = n.iAxisID = r(l, s, o, a), c = n.vAxisID = r(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && Kd(this._data, this), e._stacked && ir(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), i = this._data; if (W(n)) this._data = cw(n); else if (i !== n) { if (i) { Kd(i, this); const r = this._cachedMeta; ir(r), r._parsed = [] } n && Object.isExtensible(n) && O_(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, i = this.getDataset(); let r = !1; this._dataCheck(); const s = n._stacked; n._stacked = mh(n.vScale, n), n.stack !== i.stack && (r = !0, ir(n), n.stack = i.stack), this._resyncElements(e), (r || s !== n._stacked) && vh(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), i = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: i, _data: r } = this, { iScale: s, _stacked: o } = i, a = s.axis; let l = e === 0 && n === r.length ? !0 : i._sorted, u = e > 0 && i._parsed[e - 1], c, f, d; if (this._parsing === !1) i._parsed = r, i._sorted = !0, d = r; else { st(r[e]) ? d = this.parseArrayData(i, r, e, n) : W(r[e]) ? d = this.parseObjectData(i, r, e, n) : d = this.parsePrimitiveData(i, r, e, n); const h = () => f[a] === null || u && f[a] < u[a]; for (c = 0; c < n; ++c)i._parsed[c + e] = f = d[c], l && (h() && (l = !1), u = f); i._sorted = l } o && vh(this, d) } parsePrimitiveData(e, n, i, r) { const { iScale: s, vScale: o } = e, a = s.axis, l = o.axis, u = s.getLabels(), c = s === o, f = new Array(r); let d, h, g; for (d = 0, h = r; d < h; ++d)g = d + i, f[d] = { [a]: c || s.parse(u[g], g), [l]: o.parse(n[g], g) }; return f } parseArrayData(e, n, i, r) { const { xScale: s, yScale: o } = e, a = new Array(r); let l, u, c, f; for (l = 0, u = r; l < u; ++l)c = l + i, f = n[c], a[l] = { x: s.parse(f[0], c), y: o.parse(f[1], c) }; return a } parseObjectData(e, n, i, r) { const { xScale: s, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r); let c, f, d, h; for (c = 0, f = r; c < f; ++c)d = c + i, h = n[d], u[c] = { x: s.parse(qo(h, a), d), y: o.parse(qo(h, l), d) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, i) { const r = this.chart, s = this._cachedMeta, o = n[e.axis], a = { keys: b0(r, !0), values: n._stacks[e.axis] }; return ph(a, o, s.index, { mode: i }) } updateRangeFromParsed(e, n, i, r) { const s = i[n.axis]; let o = s === null ? NaN : s; const a = r && i._stacks[n.axis]; r && a && (r.values = a, o = ph(r, s, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, n) { const i = this._cachedMeta, r = i._parsed, s = i._sorted && e === i.iScale, o = r.length, a = this._getOtherScale(e), l = gw(n, i, this.chart), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: f } = dw(a); let d, h; function g() { h = r[d]; const v = h[a.axis]; return !ht(h[e.axis]) || c > v || f < v } for (d = 0; d < o && !(!g() && (this.updateRangeFromParsed(u, e, h, l), s)); ++d); if (s) { for (d = o - 1; d >= 0; --d)if (!g()) { this.updateRangeFromParsed(u, e, h, l); break } } return u } getAllParsedValues(e) { const n = this._cachedMeta._parsed, i = []; let r, s, o; for (r = 0, s = n.length; r < s; ++r)o = n[r][e.axis], ht(o) && i.push(o); return i } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, i = n.iScale, r = n.vScale, s = this.getParsed(e); return { label: i ? "" + i.getLabelForValue(s[i.axis]) : "", value: r ? "" + r.getLabelForValue(s[r.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = uw(j(this.options.clip, lw(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, n = this.chart, i = this._cachedMeta, r = i.data || [], s = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || r.length - a, u = this.options.drawActiveElementsOnTop; let c; for (i.dataset && i.dataset.draw(e, s, a, l), c = a; c < a + l; ++c) { const f = r[c]; f.hidden || (f.active && u ? o.push(f) : f.draw(e, s)) } for (c = 0; c < o.length; ++c)o[c].draw(e, s) } getStyle(e, n) { const i = n ? "active" : "default"; return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(e || 0, i) } getContext(e, n, i) { const r = this.getDataset(); let s; if (e >= 0 && e < this._cachedMeta.data.length) { const o = this._cachedMeta.data[e]; s = o.$context || (o.$context = mw(this.getContext(), e, o)), s.parsed = this.getParsed(e), s.raw = r.data[e], s.index = s.dataIndex = e } else s = this.$context || (this.$context = pw(this.chart.getContext(), this.index)), s.dataset = r, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = i, s } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", i) { const r = n === "active", s = this._cachedDataOpts, o = e + "-" + n, a = s[o], l = this.enableOptionSharing && be(i); if (a) return yh(a, l); const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, e), f = r ? [`${e}Hover`, "hover", e, ""] : [e, ""], d = u.getOptionScopes(this.getDataset(), c), h = Object.keys(mt.elements[e]), g = () => this.getContext(i, r), v = u.resolveNamedOptions(d, h, g, f); return v.$shared && (v.$shared = l, s[o] = Object.freeze(yh(v, l))), v } _resolveAnimations(e, n, i) { const r = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (r.options.animation !== !1) { const c = this.chart.config, f = c.datasetAnimationScopeKeys(this._type, n), d = c.getOptionScopes(this.getDataset(), f); l = c.createResolver(d, this.getContext(e, i, n)) } const u = new _0(r, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(u)), u } getSharedOptions(e) { if (!!e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || pl(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const i = this.resolveDataElementOptions(e, n), r = this._sharedOptions, s = this.getSharedOptions(i), o = this.includeOptions(n, s) || s !== r; return this.updateSharedOptions(s, n, i), { sharedOptions: s, includeOptions: o } } updateElement(e, n, i, r) { pl(r) ? Object.assign(e, i) : this._resolveAnimations(n, r).update(e, i) } updateSharedOptions(e, n, i) { e && !pl(n) && this._resolveAnimations(void 0, n).update(e, i) } _setStyle(e, n, i, r) { e.active = r; const s = this.getStyle(n, r); this._resolveAnimations(n, i, r).update(e, { options: !r && this.getSharedOptions(s) || s }) } removeHoverStyle(e, n, i) { this._setStyle(e, i, "active", !1) } setHoverStyle(e, n, i) { this._setStyle(e, i, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, i = this._cachedMeta.data; for (const [a, l, u] of this._syncList) this[a](l, u); this._syncList = []; const r = i.length, s = n.length, o = Math.min(s, r); o && this.parse(0, o), s > r ? this._insertElements(r, s - r, e) : s < r && this._removeElements(s, r - s) } _insertElements(e, n, i = !0) { const r = this._cachedMeta, s = r.data, o = e + n; let a; const l = u => { for (u.length += n, a = u.length - 1; a >= o; a--)u[a] = u[a - n] }; for (l(s), a = e; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(r._parsed), this.parse(e, n), i && this.updateElements(s, e, n, "reset") } updateElements(e, n, i, r) { } _removeElements(e, n) { const i = this._cachedMeta; if (this._parsing) { const r = i._parsed.splice(e, n); i._stacked && ir(i, r) } i.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, i, r] = e; this[n](i, r) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const i = arguments.length - 2; i && this._sync(["_insertElements", e, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } z(Tr, "defaults", {}), z(Tr, "datasetElementType", null), z(Tr, "dataElementType", null); class yo extends Tr { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(e) { const n = this._cachedMeta, { dataset: i, data: r = [], _dataset: s } = n, o = this.chart._animationsDisabled; let { start: a, count: l } = D_(n, r, o); this._drawStart = a, this._drawCount = l, N_(n) && (a = 0, l = r.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = r; const u = this.resolveDatasetElementOptions(e); this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(i, void 0, { animated: !o, options: u }, e), this.updateElements(r, a, l, e) } updateElements(e, n, i, r) { const s = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: f } = this._getSharedOptions(n, r), d = o.axis, h = a.axis, { spanGaps: g, segment: v } = this.options, x = ts(g) ? g : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || s || r === "none", p = n + i, y = e.length; let _ = n > 0 && this.getParsed(n - 1); for (let b = 0; b < y; ++b) { const w = e[b], k = m ? w : {}; if (b < n || b >= p) { k.skip = !0; continue } const S = this.getParsed(b), P = et(S[h]), M = k[d] = o.getPixelForValue(S[d], b), D = k[h] = s || P ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, S, l) : S[h], b); k.skip = isNaN(M) || isNaN(D) || P, k.stop = b > 0 && Math.abs(S[d] - _[d]) > x, v && (k.parsed = S, k.raw = u.data[b]), f && (k.options = c || this.resolveDataElementOptions(b, w.active ? "active" : r)), m || this.updateElement(w, b, k, r), _ = S } } getMaxOverflow() { const e = this._cachedMeta, n = e.dataset, i = n.options && n.options.borderWidth || 0, r = e.data || []; if (!r.length) return i; const s = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1)); return Math.max(i, s, o) / 2 } draw() { const e = this._cachedMeta; e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw() } } z(yo, "id", "line"), z(yo, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), z(yo, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); function Nn() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class rf { static override(e) { Object.assign(rf.prototype, e) } constructor(e) { this.options = e || {} } init() { } formats() { return Nn() } parse() { return Nn() } format() { return Nn() } add() { return Nn() } diff() { return Nn() } startOf() { return Nn() } endOf() { return Nn() } } var vw = { _date: rf }; function yw(t, e, n, i) { const { controller: r, data: s, _sorted: o } = t, a = r._cachedMeta.iScale; if (a && e === a.axis && e !== "r" && o && s.length) { const l = a._reversePixels ? M_ : Un; if (i) { if (r._sharedOptions) { const u = s[0], c = typeof u.getRange == "function" && u.getRange(e); if (c) { const f = l(s, e, n - c), d = l(s, e, n + c); return { lo: f.lo, hi: d.hi } } } } else return l(s, e, n) } return { lo: 0, hi: s.length - 1 } } function ps(t, e, n, i, r) { const s = t.getSortedVisibleDatasetMetas(), o = n[e]; for (let a = 0, l = s.length; a < l; ++a) { const { index: u, data: c } = s[a], { lo: f, hi: d } = yw(s[a], e, o, r); for (let h = f; h <= d; ++h) { const g = c[h]; g.skip || i(g, u, h) } } } function xw(t) { const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1; return function (i, r) { const s = e ? Math.abs(i.x - r.x) : 0, o = n ? Math.abs(i.y - r.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } } function ml(t, e, n, i, r) { const s = []; return !r && !t.isPointInArea(e) || ps(t, n, e, function (a, l, u) { !r && !es(a, t.chartArea, 0) || a.inRange(e.x, e.y, i) && s.push({ element: a, datasetIndex: l, index: u }) }, !0), s } function _w(t, e, n, i) { let r = []; function s(o, a, l) { const { startAngle: u, endAngle: c } = o.getProps(["startAngle", "endAngle"], i), { angle: f } = S_(o, { x: e.x, y: e.y }); Zg(f, u, c) && r.push({ element: o, datasetIndex: a, index: l }) } return ps(t, n, e, s), r } function bw(t, e, n, i, r, s) { let o = []; const a = xw(n); let l = Number.POSITIVE_INFINITY; function u(c, f, d) { const h = c.inRange(e.x, e.y, r); if (i && !h) return; const g = c.getCenterPoint(r); if (!(!!s || t.isPointInArea(g)) && !h) return; const x = a(e, g); x < l ? (o = [{ element: c, datasetIndex: f, index: d }], l = x) : x === l && o.push({ element: c, datasetIndex: f, index: d }) } return ps(t, n, e, u), o } function gl(t, e, n, i, r, s) { return !s && !t.isPointInArea(e) ? [] : n === "r" && !i ? _w(t, e, n, r) : bw(t, e, n, i, r, s) } function xh(t, e, n, i, r) { const s = [], o = n === "x" ? "inXRange" : "inYRange"; let a = !1; return ps(t, n, e, (l, u, c) => { l[o](e[n], r) && (s.push({ element: l, datasetIndex: u, index: c }), a = a || l.inRange(e.x, e.y, r)) }), i && !a ? [] : s } var ww = { evaluateInteractionItems: ps, modes: { index(t, e, n, i) { const r = Fn(e, t), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? ml(t, r, s, i, o) : gl(t, r, s, !1, i, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(u => { const c = a[0].index, f = u.data[c]; f && !f.skip && l.push({ element: f, datasetIndex: u.index, index: c }) }), l) : [] }, dataset(t, e, n, i) { const r = Fn(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? ml(t, r, s, i, o) : gl(t, r, s, !1, i, o); if (a.length > 0) { const l = a[0].datasetIndex, u = t.getDatasetMeta(l).data; a = []; for (let c = 0; c < u.length; ++c)a.push({ element: u[c], datasetIndex: l, index: c }) } return a }, point(t, e, n, i) { const r = Fn(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return ml(t, r, s, i, o) }, nearest(t, e, n, i) { const r = Fn(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return gl(t, r, s, n.intersect, i, o) }, x(t, e, n, i) { const r = Fn(e, t); return xh(t, r, "x", n.intersect, i) }, y(t, e, n, i) { const r = Fn(e, t); return xh(t, r, "y", n.intersect, i) } } }; const w0 = ["left", "top", "right", "bottom"]; function rr(t, e) { return t.filter(n => n.pos === e) } function _h(t, e) { return t.filter(n => w0.indexOf(n.pos) === -1 && n.box.axis === e) } function sr(t, e) { return t.sort((n, i) => { const r = e ? i : n, s = e ? n : i; return r.weight === s.weight ? r.index - s.index : r.weight - s.weight }) } function kw(t) { const e = []; let n, i, r, s, o, a; for (n = 0, i = (t || []).length; n < i; ++n)r = t[n], { position: s, options: { stack: o, stackWeight: a = 1 } } = r, e.push({ index: n, box: r, pos: s, horizontal: r.isHorizontal(), weight: r.weight, stack: o && s + o, stackWeight: a }); return e } function Sw(t) { const e = {}; for (const n of t) { const { stack: i, pos: r, stackWeight: s } = n; if (!i || !w0.includes(r)) continue; const o = e[i] || (e[i] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return e } function Cw(t, e) { const n = Sw(t), { vBoxMaxWidth: i, hBoxMaxHeight: r } = e; let s, o, a; for (s = 0, o = t.length; s < o; ++s) { a = t[s]; const { fullSize: l } = a.box, u = n[a.stack], c = u && a.stackWeight / u.weight; a.horizontal ? (a.width = c ? c * i : l && e.availableWidth, a.height = r) : (a.width = i, a.height = c ? c * r : l && e.availableHeight) } return n } function Pw(t) { const e = kw(t), n = sr(e.filter(u => u.box.fullSize), !0), i = sr(rr(e, "left"), !0), r = sr(rr(e, "right")), s = sr(rr(e, "top"), !0), o = sr(rr(e, "bottom")), a = _h(e, "x"), l = _h(e, "y"); return { fullSize: n, leftAndTop: i.concat(s), rightAndBottom: r.concat(l).concat(o).concat(a), chartArea: rr(e, "chartArea"), vertical: i.concat(r).concat(l), horizontal: s.concat(o).concat(a) } } function bh(t, e, n, i) { return Math.max(t[n], e[n]) + Math.max(t[i], e[i]) } function k0(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function Mw(t, e, n, i) { const { pos: r, box: s } = n, o = t.maxPadding; if (!W(r)) { n.size && (t[r] -= n.size); const f = i[n.stack] || { size: 0, count: 1 }; f.size = Math.max(f.size, n.horizontal ? s.height : s.width), n.size = f.size / f.count, t[r] += n.size } s.getPadding && k0(o, s.getPadding()); const a = Math.max(0, e.outerWidth - bh(o, t, "left", "right")), l = Math.max(0, e.outerHeight - bh(o, t, "top", "bottom")), u = a !== t.w, c = l !== t.h; return t.w = a, t.h = l, n.horizontal ? { same: u, other: c } : { same: c, other: u } } function Ew(t) { const e = t.maxPadding; function n(i) { const r = Math.max(e[i] - t[i], 0); return t[i] += r, r } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") } function Ow(t, e) { const n = e.maxPadding; function i(r) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return r.forEach(o => { s[o] = Math.max(e[o], n[o]) }), s } return i(t ? ["left", "right"] : ["top", "bottom"]) } function pr(t, e, n, i) { const r = []; let s, o, a, l, u, c; for (s = 0, o = t.length, u = 0; s < o; ++s) { a = t[s], l = a.box, l.update(a.width || e.w, a.height || e.h, Ow(a.horizontal, e)); const { same: f, other: d } = Mw(e, n, a, i); u |= f && r.length, c = c || d, l.fullSize || r.push(a) } return u && pr(r, e, n, i) || c } function Qs(t, e, n, i, r) { t.top = n, t.left = e, t.right = e + i, t.bottom = n + r, t.width = i, t.height = r } function wh(t, e, n, i) { const r = n.padding; let { x: s, y: o } = e; for (const a of t) { const l = a.box, u = i[a.stack] || { count: 1, placed: 0, weight: 1 }, c = a.stackWeight / u.weight || 1; if (a.horizontal) { const f = e.w * c, d = u.size || l.height; be(u.start) && (o = u.start), l.fullSize ? Qs(l, r.left, o, n.outerWidth - r.right - r.left, d) : Qs(l, e.left + u.placed, o, f, d), u.start = o, u.placed += f, o = l.bottom } else { const f = e.h * c, d = u.size || l.width; be(u.start) && (s = u.start), l.fullSize ? Qs(l, s, r.top, d, n.outerHeight - r.bottom - r.top) : Qs(l, s, e.top + u.placed, d, f), u.start = s, u.placed += f, s = l.right } } e.x = s, e.y = o } var ue = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, i) { if (!t) return; const r = Dt(t.options.layout.padding), s = Math.max(e - r.width, 0), o = Math.max(n - r.height, 0), a = Pw(t.boxes), l = a.vertical, u = a.horizontal; V(t.boxes, v => { typeof v.beforeLayout == "function" && v.beforeLayout() }); const c = l.reduce((v, x) => x.box.options && x.box.options.display === !1 ? v : v + 1, 0) || 1, f = Object.freeze({ outerWidth: e, outerHeight: n, padding: r, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / c, hBoxMaxHeight: o / 2 }), d = Object.assign({}, r); k0(d, Dt(i)); const h = Object.assign({ maxPadding: d, w: s, h: o, x: r.left, y: r.top }, r), g = Cw(l.concat(u), f); pr(a.fullSize, h, f, g), pr(l, h, f, g), pr(u, h, f, g) && pr(l, h, f, g), Ew(h), wh(a.leftAndTop, h, f, g), h.x += h.w, h.y += h.h, wh(a.rightAndBottom, h, f, g), t.chartArea = { left: h.left, top: h.top, right: h.left + h.w, bottom: h.top + h.h, height: h.h, width: h.w }, V(a.chartArea, v => { const x = v.box; Object.assign(x, t.chartArea), x.update(h.w, h.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class S0 { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, i) { } removeEventListener(e, n, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, i, r) { return n = Math.max(0, n || e.width), i = i || e.height, { width: n, height: Math.max(0, r ? Math.floor(n / r) : i) } } isAttached(e) { return !0 } updateConfig(e) { } } class Tw extends S0 { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const xo = "$chartjs", Lw = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, kh = t => t === null || t === ""; function Aw(t, e) { const n = t.style, i = t.getAttribute("height"), r = t.getAttribute("width"); if (t[xo] = { initial: { height: i, width: r, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", kh(r)) { const s = lh(t, "width"); s !== void 0 && (t.width = s) } if (kh(i)) if (t.style.height === "") t.height = t.width / (e || 2); else { const s = lh(t, "height"); s !== void 0 && (t.height = s) } return t } const C0 = Yb ? { passive: !0 } : !1; function Dw(t, e, n) { t.addEventListener(e, n, C0) } function Nw(t, e, n) { t.canvas.removeEventListener(e, n, C0) } function Iw(t, e) { const n = Lw[t.type] || t.type, { x: i, y: r } = Fn(t, e); return { type: n, chart: e, native: t, x: i !== void 0 ? i : null, y: r !== void 0 ? r : null } } function ra(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function zw(t, e, n) { const i = t.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || ra(a.addedNodes, i), o = o && !ra(a.removedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } function Rw(t, e, n) { const i = t.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || ra(a.removedNodes, i), o = o && !ra(a.addedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } const ns = new Map; let Sh = 0; function P0() { const t = window.devicePixelRatio; t !== Sh && (Sh = t, ns.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function Fw(t, e) { ns.size || window.addEventListener("resize", P0), ns.set(t, e) } function jw(t) { ns.delete(t), ns.size || window.removeEventListener("resize", P0) } function Bw(t, e, n) { const i = t.canvas, r = i && nf(i); if (!r) return; const s = t0((a, l) => { const u = r.clientWidth; n(a, l), u < r.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], u = l.contentRect.width, c = l.contentRect.height; u === 0 && c === 0 || s(u, c) }); return o.observe(r), Fw(t, s), o } function vl(t, e, n) { n && n.disconnect(), e === "resize" && jw(t) } function Hw(t, e, n) { const i = t.canvas, r = t0(s => { t.ctx !== null && n(Iw(s, t)) }, t); return Dw(i, e, r), r } class Ww extends S0 { acquireContext(e, n) { const i = e && e.getContext && e.getContext("2d"); return i && i.canvas === e ? (Aw(e, n), i) : null } releaseContext(e) { const n = e.canvas; if (!n[xo]) return !1; const i = n[xo].initial;["height", "width"].forEach(s => { const o = i[s]; et(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const r = i.style || {}; return Object.keys(r).forEach(s => { n.style[s] = r[s] }), n.width = n.width, delete n[xo], !0 } addEventListener(e, n, i) { this.removeEventListener(e, n); const r = e.$proxies || (e.$proxies = {}), o = { attach: zw, detach: Rw, resize: Bw }[n] || Hw; r[n] = o(e, n, i) } removeEventListener(e, n) { const i = e.$proxies || (e.$proxies = {}), r = i[n]; if (!r) return; ({ attach: vl, detach: vl, resize: vl }[n] || Nw)(e, n, r), i[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, i, r) { return Ub(e, n, i, r) } isAttached(e) { const n = nf(e); return !!(n && n.isConnected) } } function $w(t) { return !p0() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? Tw : Ww } class Qe { constructor() { z(this, "active", !1) } tooltipPosition(e) { const { x: n, y: i } = this.getProps(["x", "y"], e); return { x: n, y: i } } hasValue() { return ts(this.x) && ts(this.y) } getProps(e, n) { const i = this.$animations; if (!n || !i) return this; const r = {}; return e.forEach(s => { r[s] = i[s] && i[s].active() ? i[s]._to : this[s] }), r } } z(Qe, "defaults", {}), z(Qe, "defaultRoutes"); function Vw(t, e) { const n = t.options.ticks, i = Uw(t), r = Math.min(n.maxTicksLimit || i, i), s = n.major.enabled ? Xw(e) : [], o = s.length, a = s[0], l = s[o - 1], u = []; if (o > r) return Kw(e, u, s, o / r), u; const c = Yw(s, e, r); if (o > 0) { let f, d; const h = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (Gs(e, u, c, et(h) ? 0 : a - h, a), f = 0, d = o - 1; f < d; f++)Gs(e, u, c, s[f], s[f + 1]); return Gs(e, u, c, l, et(h) ? e.length : l + h), u } return Gs(e, u, c), u } function Uw(t) { const e = t.options.offset, n = t._tickSize(), i = t._length / n + (e ? 0 : 1), r = t._maxLength / n; return Math.floor(Math.min(i, r)) } function Yw(t, e, n) { const i = Qw(t), r = e.length / n; if (!i) return Math.max(r, 1); const s = w_(i); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > r) return l } return Math.max(r, 1) } function Xw(t) { const e = []; let n, i; for (n = 0, i = t.length; n < i; n++)t[n].major && e.push(n); return e } function Kw(t, e, n, i) { let r = 0, s = n[0], o; for (i = Math.ceil(i), o = 0; o < t.length; o++)o === s && (e.push(t[o]), r++, s = n[r * i]) } function Gs(t, e, n, i, r) { const s = j(i, 0), o = Math.min(j(r, t.length), t.length); let a = 0, l, u, c; for (n = Math.ceil(n), r && (l = r - i, n = l / Math.floor(l / n)), c = s; c < 0;)a++, c = Math.round(s + a * n); for (u = Math.max(s, 0); u < o; u++)u === c && (e.push(t[u]), a++, c = Math.round(s + a * n)) } function Qw(t) { const e = t.length; let n, i; if (e < 2) return !1; for (i = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== i) return !1; return i } const Gw = t => t === "left" ? "right" : t === "right" ? "left" : t, Ch = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n; function Ph(t, e) { const n = [], i = t.length / e, r = t.length; let s = 0; for (; s < r; s += i)n.push(t[Math.floor(s)]); return n } function Zw(t, e, n) { const i = t.ticks.length, r = Math.min(e, i - 1), s = t._startPixel, o = t._endPixel, a = 1e-6; let l = t.getPixelForTick(r), u; if (!(n && (i === 1 ? u = Math.max(l - s, o - l) : e === 0 ? u = (t.getPixelForTick(1) - l) / 2 : u = (l - t.getPixelForTick(r - 1)) / 2, l += r < e ? u : -u, l < s - a || l > o + a))) return l } function qw(t, e) { V(t, n => { const i = n.gc, r = i.length / 2; let s; if (r > e) { for (s = 0; s < r; ++s)delete n.data[i[s]]; i.splice(0, r) } }) } function or(t) { return t.drawTicks ? t.tickLength : 0 } function Mh(t, e) { if (!t.display) return 0; const n = xt(t.font, e), i = Dt(t.padding); return (st(t.text) ? t.text.length : 1) * n.lineHeight + i.height } function Jw(t, e) { return Ln(t, { scale: e, type: "scale" }) } function tk(t, e, n) { return Ln(t, { tick: n, index: e, type: "tick" }) } function ek(t, e, n) { let i = Kc(t); return (n && e !== "right" || !n && e === "right") && (i = Gw(i)), i } function nk(t, e, n, i) { const { top: r, left: s, bottom: o, right: a, chart: l } = t, { chartArea: u, scales: c } = l; let f = 0, d, h, g; const v = o - r, x = a - s; if (t.isHorizontal()) { if (h = Tt(i, s, a), W(n)) { const m = Object.keys(n)[0], p = n[m]; g = c[m].getPixelForValue(p) + v - e } else n === "center" ? g = (u.bottom + u.top) / 2 + v - e : g = Ch(t, n, e); d = a - s } else { if (W(n)) { const m = Object.keys(n)[0], p = n[m]; h = c[m].getPixelForValue(p) - x + e } else n === "center" ? h = (u.left + u.right) / 2 - x + e : h = Ch(t, n, e); g = Tt(i, o, r), f = n === "left" ? -Wt : Wt } return { titleX: h, titleY: g, maxWidth: d, rotation: f } } class oi extends Qe { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: i, _suggestedMax: r } = this; return e = Kt(e, Number.POSITIVE_INFINITY), n = Kt(n, Number.NEGATIVE_INFINITY), i = Kt(i, Number.POSITIVE_INFINITY), r = Kt(r, Number.NEGATIVE_INFINITY), { min: Kt(e, i), max: Kt(n, r), minDefined: ht(e), maxDefined: ht(n) } } getMinMax(e) { let { min: n, max: i, minDefined: r, maxDefined: s } = this.getUserBounds(), o; if (r && s) return { min: n, max: i }; const a = this.getMatchingVisibleMetas(); for (let l = 0, u = a.length; l < u; ++l)o = a[l].controller.getMinMax(this, e), r || (n = Math.min(n, o.min)), s || (i = Math.max(i, o.max)); return n = s && n > i ? i : n, i = r && n > i ? n : i, { min: Kt(n, Kt(i, n)), max: Kt(i, Kt(n, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { Q(this.options.beforeUpdate, [this]) } update(e, n, i) { const { beginAtZero: r, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = kb(this, s, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? Ph(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = Vw(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e = this.options.reverse, n, i; this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, e = !e), this._startPixel = n, this._endPixel = i, this._reversePixels = e, this._length = i - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { Q(this.options.afterUpdate, [this]) } beforeSetDimensions() { Q(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { Q(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), Q(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { Q(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let i, r, s; for (i = 0, r = e.length; i < r; i++)s = e[i], s.label = Q(n.callback, [s.value, i, e], this) } afterTickToLabelConversion() { Q(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { Q(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, i = this.ticks.length, r = n.minRotation || 0, s = n.maxRotation; let o = r, a, l, u; if (!this._isVisible() || !n.display || r >= s || i <= 1 || !this.isHorizontal()) { this.labelRotation = r; return } const c = this._getLabelSizes(), f = c.widest.width, d = c.highest.height, h = le(this.chart.width - f, 0, this.maxWidth); a = e.offset ? this.maxWidth / i : h / (i - 1), f + 6 > a && (a = h / (i - (e.offset ? .5 : 1)), l = this.maxHeight - or(e.grid) - n.padding - Mh(e.title, this.chart.options.font), u = Math.sqrt(f * f + d * d), o = Yc(Math.min(Math.asin(le((c.highest.height + 6) / a, -1, 1)), Math.asin(le(l / u, -1, 1)) - Math.asin(le(d / u, -1, 1)))), o = Math.max(r, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { Q(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { Q(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: i, title: r, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = Mh(r, n.options.font); if (a ? (e.width = this.maxWidth, e.height = or(s) + l) : (e.height = this.maxHeight, e.width = or(s) + l), i.display && this.ticks.length) { const { first: u, last: c, widest: f, highest: d } = this._getLabelSizes(), h = i.padding * 2, g = cn(this.labelRotation), v = Math.cos(g), x = Math.sin(g); if (a) { const m = i.mirror ? 0 : x * f.width + v * d.height; e.height = Math.min(this.maxHeight, e.height + m + h) } else { const m = i.mirror ? 0 : v * f.width + x * d.height; e.width = Math.min(this.maxWidth, e.width + m + h) } this._calculatePadding(u, c, x, v) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, i, r) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, u = a !== "top" && this.axis === "x"; if (this.isHorizontal()) { const c = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1); let d = 0, h = 0; l ? u ? (d = r * e.width, h = i * n.height) : (d = i * e.height, h = r * n.width) : s === "start" ? h = n.width : s === "end" ? d = e.width : s !== "inner" && (d = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((d - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((h - f + o) * this.width / (this.width - f), 0) } else { let c = n.height / 2, f = e.height / 2; s === "start" ? (c = 0, f = e.height) : s === "end" && (c = n.height, f = 0), this.paddingTop = c + o, this.paddingBottom = f + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { Q(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return n === "top" || n === "bottom" || e === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { this.beforeTickToLabelConversion(), this.generateTickLabels(e); let n, i; for (n = 0, i = e.length; n < i; n++)et(e[n].label) && (e.splice(n, 1), i--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let i = this.ticks; n < i.length && (i = Ph(i, n)), this._labelSizes = e = this._computeLabelSizes(i, i.length) } return e } _computeLabelSizes(e, n) { const { ctx: i, _longestTextCache: r } = this, s = [], o = []; let a = 0, l = 0, u, c, f, d, h, g, v, x, m, p, y; for (u = 0; u < n; ++u) { if (d = e[u].label, h = this._resolveTickFontOptions(u), i.font = g = h.string, v = r[g] = r[g] || { data: {}, gc: [] }, x = h.lineHeight, m = p = 0, !et(d) && !st(d)) m = ea(i, v.data, v.gc, m, d), p = x; else if (st(d)) for (c = 0, f = d.length; c < f; ++c)y = d[c], !et(y) && !st(y) && (m = ea(i, v.data, v.gc, m, y), p += x); s.push(m), o.push(p), a = Math.max(m, a), l = Math.max(p, l) } qw(r, n); const _ = s.indexOf(a), b = o.indexOf(l), w = k => ({ width: s[k] || 0, height: o[k] || 0 }); return { first: w(0), last: w(n - 1), widest: w(_), highest: w(b), widths: s, heights: o } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return P_(this._alignToPixels ? Dn(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const i = n[e]; return i.$context || (i.$context = tk(this.getContext(), e, i)) } return this.$context || (this.$context = Jw(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = cn(this.labelRotation), i = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * i > a * r ? a / i : l / r : l * r < a * i ? l / i : a / r } _isVisible() { const e = this.options.display; return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, i = this.chart, r = this.options, { grid: s, position: o, border: a } = r, l = s.offset, u = this.isHorizontal(), f = this.ticks.length + (l ? 1 : 0), d = or(s), h = [], g = a.setContext(this.getContext()), v = g.display ? g.width : 0, x = v / 2, m = function (X) { return Dn(i, X, v) }; let p, y, _, b, w, k, S, P, M, D, F, A; if (o === "top") p = m(this.bottom), k = this.bottom - d, P = p - x, D = m(e.top) + x, A = e.bottom; else if (o === "bottom") p = m(this.top), D = e.top, A = m(e.bottom) - x, k = p + x, P = this.top + d; else if (o === "left") p = m(this.right), w = this.right - d, S = p - x, M = m(e.left) + x, F = e.right; else if (o === "right") p = m(this.left), M = e.left, F = m(e.right) - x, w = p + x, S = this.left + d; else if (n === "x") { if (o === "center") p = m((e.top + e.bottom) / 2 + .5); else if (W(o)) { const X = Object.keys(o)[0], Mt = o[X]; p = m(this.chart.scales[X].getPixelForValue(Mt)) } D = e.top, A = e.bottom, k = p + x, P = k + d } else if (n === "y") { if (o === "center") p = m((e.left + e.right) / 2); else if (W(o)) { const X = Object.keys(o)[0], Mt = o[X]; p = m(this.chart.scales[X].getPixelForValue(Mt)) } w = p - x, S = w - d, M = e.left, F = e.right } const ut = j(r.ticks.maxTicksLimit, f), Y = Math.max(1, Math.ceil(f / ut)); for (y = 0; y < f; y += Y) { const X = this.getContext(y), Mt = s.setContext(X), E = a.setContext(X), N = Mt.lineWidth, I = Mt.color, K = E.dash || [], Z = E.dashOffset, we = Mt.tickWidth, Yt = Mt.tickColor, Ae = Mt.tickBorderDash || [], Xt = Mt.tickBorderDashOffset; _ = Zw(this, y, l), _ !== void 0 && (b = Dn(i, _, N), u ? w = S = M = F = b : k = P = D = A = b, h.push({ tx1: w, ty1: k, tx2: S, ty2: P, x1: M, y1: D, x2: F, y2: A, width: N, color: I, borderDash: K, borderDashOffset: Z, tickWidth: we, tickColor: Yt, tickBorderDash: Ae, tickBorderDashOffset: Xt })) } return this._ticksLength = f, this._borderValue = p, h } _computeLabelItems(e) { const n = this.axis, i = this.options, { position: r, ticks: s } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: u, padding: c, mirror: f } = s, d = or(i.grid), h = d + c, g = f ? -c : h, v = -cn(this.labelRotation), x = []; let m, p, y, _, b, w, k, S, P, M, D, F, A = "middle"; if (r === "top") w = this.bottom - g, k = this._getXAxisLabelAlignment(); else if (r === "bottom") w = this.top + g, k = this._getXAxisLabelAlignment(); else if (r === "left") { const Y = this._getYAxisLabelAlignment(d); k = Y.textAlign, b = Y.x } else if (r === "right") { const Y = this._getYAxisLabelAlignment(d); k = Y.textAlign, b = Y.x } else if (n === "x") { if (r === "center") w = (e.top + e.bottom) / 2 + h; else if (W(r)) { const Y = Object.keys(r)[0], X = r[Y]; w = this.chart.scales[Y].getPixelForValue(X) + h } k = this._getXAxisLabelAlignment() } else if (n === "y") { if (r === "center") b = (e.left + e.right) / 2 - h; else if (W(r)) { const Y = Object.keys(r)[0], X = r[Y]; b = this.chart.scales[Y].getPixelForValue(X) } k = this._getYAxisLabelAlignment(d).textAlign } n === "y" && (l === "start" ? A = "top" : l === "end" && (A = "bottom")); const ut = this._getLabelSizes(); for (m = 0, p = a.length; m < p; ++m) { y = a[m], _ = y.label; const Y = s.setContext(this.getContext(m)); S = this.getPixelForTick(m) + s.labelOffset, P = this._resolveTickFontOptions(m), M = P.lineHeight, D = st(_) ? _.length : 1; const X = D / 2, Mt = Y.color, E = Y.textStrokeColor, N = Y.textStrokeWidth; let I = k; o ? (b = S, k === "inner" && (m === p - 1 ? I = this.options.reverse ? "left" : "right" : m === 0 ? I = this.options.reverse ? "right" : "left" : I = "center"), r === "top" ? u === "near" || v !== 0 ? F = -D * M + M / 2 : u === "center" ? F = -ut.highest.height / 2 - X * M + M : F = -ut.highest.height + M / 2 : u === "near" || v !== 0 ? F = M / 2 : u === "center" ? F = ut.highest.height / 2 - X * M : F = ut.highest.height - D * M, f && (F *= -1), v !== 0 && !Y.showLabelBackdrop && (b += M / 2 * Math.sin(v))) : (w = S, F = (1 - D) * M / 2); let K; if (Y.showLabelBackdrop) { const Z = Dt(Y.backdropPadding), we = ut.heights[m], Yt = ut.widths[m]; let Ae = F - Z.top, Xt = 0 - Z.left; switch (A) { case "middle": Ae -= we / 2; break; case "bottom": Ae -= we; break }switch (k) { case "center": Xt -= Yt / 2; break; case "right": Xt -= Yt; break }K = { left: Xt, top: Ae, width: Yt + Z.width, height: we + Z.height, color: Y.backdropColor } } x.push({ rotation: v, label: _, font: P, color: Mt, strokeColor: E, strokeWidth: N, textOffset: F, textAlign: I, textBaseline: A, translation: [b, w], backdrop: K }) } return x } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-cn(this.labelRotation)) return e === "top" ? "left" : "right"; let r = "center"; return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: i, mirror: r, padding: s } } = this.options, o = this._getLabelSizes(), a = e + s, l = o.widest.width; let u, c; return n === "left" ? r ? (c = this.right + s, i === "near" ? u = "left" : i === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - a, i === "near" ? u = "right" : i === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : n === "right" ? r ? (c = this.left + s, i === "near" ? u = "right" : i === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + a, i === "near" ? u = "left" : i === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", { textAlign: u, x: c } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: e.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: e.width } } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: i, top: r, width: s, height: o } = this; n && (e.save(), e.fillStyle = n, e.fillRect(i, r, s, o), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const r = this.ticks.findIndex(s => s.value === e); return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let s, o; const a = (l, u, c) => { !c.width || !c.color || (i.save(), i.lineWidth = c.width, i.strokeStyle = c.color, i.setLineDash(c.borderDash || []), i.lineDashOffset = c.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(u.x, u.y), i.stroke(), i.restore()) }; if (n.display) for (s = 0, o = r.length; s < o; ++s) { const l = r[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: i, grid: r } } = this, s = i.setContext(this.getContext()), o = i.display ? s.width : 0; if (!o) return; const a = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let u, c, f, d; this.isHorizontal() ? (u = Dn(e, this.left, o) - o / 2, c = Dn(e, this.right, a) + a / 2, f = d = l) : (f = Dn(e, this.top, o) - o / 2, d = Dn(e, this.bottom, a) + a / 2, u = c = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(u, f), n.lineTo(c, d), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const i = this.ctx, r = this._computeLabelArea(); r && Oa(i, r); const s = this._labelItems || (this._labelItems = this._computeLabelItems(e)); let o, a; for (o = 0, a = s.length; o < a; ++o) { const l = s[o], u = l.font, c = l.label; let f = l.textOffset; ii(i, c, 0, f, u, l) } r && Ta(i) } drawTitle() { const { ctx: e, options: { position: n, title: i, reverse: r } } = this; if (!i.display) return; const s = xt(i.font), o = Dt(i.padding), a = i.align; let l = s.lineHeight / 2; n === "bottom" || n === "center" || W(n) ? (l += o.bottom, st(i.text) && (l += s.lineHeight * (i.text.length - 1))) : l += o.top; const { titleX: u, titleY: c, maxWidth: f, rotation: d } = nk(this, l, n, a); ii(e, i.text, 0, 0, s, { color: i.color, maxWidth: f, rotation: d, textAlign: ek(a, n, r), textBaseline: "middle", translation: [u, c] }) } draw(e) { !this._isVisible() || (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, i = j(e.grid && e.grid.z, -1), r = j(e.border && e.border.z, 0); return !this._isVisible() || this.draw !== oi.prototype.draw ? [{ z: n, draw: s => { this.draw(s) } }] : [{ z: i, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: r, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[i] === this.id && (!e || a.type === e) && r.push(a) } return r } _resolveTickFontOptions(e) { const n = this.options.ticks.setContext(this.getContext(e)); return xt(n.font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class Zs { constructor(e, n, i) { this.type = e, this.scope = n, this.override = i, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let i; sk(n) && (i = this.register(n)); const r = this.items, s = e.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + e); return s in r || (r[s] = e, ik(e, o, i), this.override && mt.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const n = this.items, i = e.id, r = this.scope; i in n && delete n[i], r && i in mt[r] && (delete mt[r][i], this.override && delete ni[i]) } } function ik(t, e, n) { const i = Jr(Object.create(null), [n ? mt.get(n) : {}, mt.get(e), t.defaults]); mt.set(e, i), t.defaultRoutes && rk(e, t.defaultRoutes), t.descriptors && mt.describe(e, t.descriptors) } function rk(t, e) { Object.keys(e).forEach(n => { const i = n.split("."), r = i.pop(), s = [t].concat(i).join("."), o = e[n].split("."), a = o.pop(), l = o.join("."); mt.route(s, r, l, a) }) } function sk(t) { return "id" in t && "defaults" in t } class ok { constructor() { this.controllers = new Zs(Tr, "datasets", !0), this.elements = new Zs(Qe, "elements"), this.plugins = new Zs(Object, "plugins"), this.scales = new Zs(oi, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, i) { [...n].forEach(r => { const s = i || this._getRegistryForType(r); i || s.isForType(r) || s === this.plugins && r.id ? this._exec(e, s, r) : V(r, o => { const a = i || this._getRegistryForType(o); this._exec(e, a, o) }) }) } _exec(e, n, i) { const r = Uc(e); Q(i["before" + r], [], i), n[e](i), Q(i["after" + r], [], i) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const i = this._typedRegistries[n]; if (i.isForType(e)) return i } return this.plugins } _get(e, n, i) { const r = n.get(e); if (r === void 0) throw new Error('"' + e + '" is not a registered ' + i + "."); return r } } var Pe = new ok; class ak { constructor() { this._init = [] } notify(e, n, i, r) { n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const s = r ? this._descriptors(e).filter(r) : this._descriptors(e), o = this._notify(s, e, n, i); return n === "afterDestroy" && (this._notify(s, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, n, i, r) { r = r || {}; for (const s of e) { const o = s.plugin, a = o[i], l = [n, r, s.options]; if (Q(a, l, o) === !1 && r.cancelable) return !1 } return !0 } invalidate() { et(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const i = e && e.config, r = j(i.options && i.options.plugins, {}), s = lk(i); return r === !1 && !n ? [] : ck(e, s, r, n) } _notifyStateChanges(e) { const n = this._oldCache || [], i = this._cache, r = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(r(n, i), e, "stop"), this._notify(r(i, n), e, "start") } } function lk(t) { const e = {}, n = [], i = Object.keys(Pe.plugins.items); for (let s = 0; s < i.length; s++)n.push(Pe.getPlugin(i[s])); const r = t.plugins || []; for (let s = 0; s < r.length; s++) { const o = r[s]; n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0) } return { plugins: n, localIds: e } } function uk(t, e) { return !e && t === !1 ? null : t === !0 ? {} : t } function ck(t, { plugins: e, localIds: n }, i, r) { const s = [], o = t.getContext(); for (const a of e) { const l = a.id, u = uk(i[l], r); u !== null && s.push({ plugin: a, options: fk(t.config, { plugin: a, local: n[l] }, u, o) }) } return s } function fk(t, { plugin: e, local: n }, i, r) { const s = t.pluginScopeKeys(e), o = t.getOptionScopes(i, s); return n && e.defaults && o.push(e.defaults), t.createResolver(o, r, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Tu(t, e) { const n = mt.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x" } function dk(t, e) { let n = t; return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n } function hk(t, e) { return t === e ? "_index_" : "_value_" } function pk(t) { if (t === "top" || t === "bottom") return "x"; if (t === "left" || t === "right") return "y" } function sa(t, e) { if (t === "x" || t === "y" || t === "r" || (t = e.axis || pk(e.position) || t.length > 1 && sa(t[0].toLowerCase(), e), t)) return t; throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`) } function mk(t, e) { const n = ni[t.type] || { scales: {} }, i = e.scales || {}, r = Tu(t.type, e), s = Object.create(null); return Object.keys(i).forEach(o => { const a = i[o]; if (!W(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = sa(o, a), u = hk(l, r), c = n.scales || {}; s[o] = Mr(Object.create(null), [{ axis: l }, a, c[l], c[u]]) }), t.data.datasets.forEach(o => { const a = o.type || t.type, l = o.indexAxis || Tu(a, e), c = (ni[a] || {}).scales || {}; Object.keys(c).forEach(f => { const d = dk(f, l), h = o[d + "AxisID"] || d; s[h] = s[h] || Object.create(null), Mr(s[h], [{ axis: d }, i[h], c[f]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; Mr(a, [mt.scales[a.type], mt.scale]) }), s } function M0(t) { const e = t.options || (t.options = {}); e.plugins = j(e.plugins, {}), e.scales = mk(t, e) } function E0(t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function gk(t) { return t = t || {}, t.data = E0(t.data), M0(t), t } const Eh = new Map, O0 = new Set; function qs(t, e) { let n = Eh.get(t); return n || (n = e(), Eh.set(t, n), O0.add(n)), n } const ar = (t, e, n) => { const i = qo(e, n); i !== void 0 && t.add(i) }; class vk { constructor(e) { this._config = gk(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = E0(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), M0(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return qs(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return qs(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return qs(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id, i = this.type; return qs(`${i}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const i = this._scopeCache; let r = i.get(e); return (!r || n) && (r = new Map, i.set(e, r)), r } getOptionScopes(e, n, i) { const { options: r, type: s } = this, o = this._cachedScopes(e, i), a = o.get(n); if (a) return a; const l = new Set; n.forEach(c => { e && (l.add(e), c.forEach(f => ar(l, e, f))), c.forEach(f => ar(l, r, f)), c.forEach(f => ar(l, ni[s] || {}, f)), c.forEach(f => ar(l, mt, f)), c.forEach(f => ar(l, Eu, f)) }); const u = Array.from(l); return u.length === 0 && u.push(Object.create(null)), O0.has(n) && o.set(n, u), u } chartOptionScopes() { const { options: e, type: n } = this; return [e, ni[n] || {}, mt.datasets[n] || {}, { type: n }, mt, Eu] } resolveNamedOptions(e, n, i, r = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = Oh(this._resolverCache, e, r); let l = o; if (xk(o, n)) { s.$shared = !1, i = Mn(i) ? i() : i; const u = this.createResolver(e, i, a); l = $i(o, i, u) } for (const u of n) s[u] = l[u]; return s } createResolver(e, n, i = [""], r) { const { resolver: s } = Oh(this._resolverCache, e, i); return W(n) ? $i(s, n, void 0, r) : s } } function Oh(t, e, n) { let i = t.get(e); i || (i = new Map, t.set(e, i)); const r = n.join(); let s = i.get(r); return s || (s = { resolver: Jc(e, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, i.set(r, s)), s } const yk = t => W(t) && Object.getOwnPropertyNames(t).reduce((e, n) => e || Mn(t[n]), !1); function xk(t, e) { const { isScriptable: n, isIndexable: i } = u0(t); for (const r of e) { const s = n(r), o = i(r), a = (o || s) && t[r]; if (s && (Mn(a) || yk(a)) || o && st(a)) return !0 } return !1 } var _k = "4.0.1"; const bk = ["top", "bottom", "left", "right", "chartArea"]; function Th(t, e) { return t === "top" || t === "bottom" || bk.indexOf(t) === -1 && e === "x" } function Lh(t, e) { return function (n, i) { return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t] } } function Ah(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), Q(n && n.onComplete, [t], e) } function wk(t) { const e = t.chart, n = e.options.animation; Q(n && n.onProgress, [t], e) } function T0(t) { return p0() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const _o = {}, Dh = t => { const e = T0(t); return Object.values(_o).filter(n => n.canvas === e).pop() }; function kk(t, e, n) { const i = Object.keys(t); for (const r of i) { const s = +r; if (s >= e) { const o = t[r]; delete t[r], (n > 0 || s > e) && (t[s + n] = o) } } } function Sk(t, e, n, i) { return !n || t.type === "mouseout" ? null : i ? e : t } function Ck(t) { const { xScale: e, yScale: n } = t; if (e && n) return { left: e.left, right: e.right, top: n.top, bottom: n.bottom } } var tn; let L0 = (tn = class { static register(...e) { Pe.add(...e), Nh() } static unregister(...e) { Pe.remove(...e), Nh() } constructor(e, n) { const i = this.config = new vk(n), r = T0(e), s = Dh(r); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || $w(r)), this.platform.updateConfig(i); const a = this.platform.acquireContext(r, o.aspectRatio), l = a && a.canvas, u = l && l.height, c = l && l.width; if (this.id = h_(), this.ctx = a, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new ak, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = L_(f => this.update(f), o.resizeDelay || 0), this._dataChanges = [], _o[this.id] = this, !a || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } Ne.listen(this, "complete", Ah), Ne.listen(this, "progress", wk), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: i, height: r, _aspectRatio: s } = this; return et(e) ? n && s ? s : r ? i / r : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return Pe } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : ah(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return rh(this.canvas, this.ctx), this } stop() { return Ne.stop(this), this } resize(e, n) { Ne.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const i = this.options, r = this.canvas, s = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, e, n, s), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ah(this, a, !0) && (this.notifyPlugins("resize", { size: o }), Q(i.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; V(n, (i, r) => { i.id = r }) } buildOrUpdateScales() { const e = this.options, n = e.scales, i = this.scales, r = Object.keys(i).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = sa(o, a), u = l === "r", c = l === "x"; return { options: a, dposition: u ? "chartArea" : c ? "bottom" : "left", dtype: u ? "radialLinear" : c ? "category" : "linear" } }))), V(s, o => { const a = o.options, l = a.id, u = sa(l, a), c = j(a.type, o.dtype); (a.position === void 0 || Th(a.position, u) !== Th(o.dposition)) && (a.position = o.dposition), r[l] = !0; let f = null; if (l in i && i[l].type === c) f = i[l]; else { const d = Pe.getScale(c); f = new d({ id: l, type: c, ctx: this.ctx, chart: this }), i[f.id] = f } f.init(a, e) }), V(r, (o, a) => { o || delete i[a] }), V(i, o => { ue.configure(this, o, o.options), ue.addBox(this, o) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, i = e.length; if (e.sort((r, s) => r.index - s.index), i > n) { for (let r = n; r < i; ++r)this._destroyDatasetMeta(r); e.splice(n, i - n) } this._sortedMetasets = e.slice(0).sort(Lh("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((i, r) => { n.filter(s => s === i._dataset).length === 0 && this._destroyDatasetMeta(r) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let i, r; for (this._removeUnreferencedMetasets(), i = 0, r = n.length; i < r; i++) { const s = n[i]; let o = this.getDatasetMeta(i); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = s.indexAxis || Tu(a, this.options), o.order = s.order || 0, o.index = i, o.label = "" + s.label, o.visible = this.isDatasetVisible(i), o.controller) o.controller.updateIndex(i), o.controller.linkScales(); else { const l = Pe.getController(a), { datasetElementType: u, dataElementType: c } = mt.datasets[a]; Object.assign(l, { dataElementType: Pe.getElement(c), datasetElementType: u && Pe.getElement(u) }), o.controller = new l(this, i), e.push(o.controller) } } return this._updateMetasets(), e } _resetElements() { V(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 }) === !1) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let u = 0, c = this.data.datasets.length; u < c; u++) { const { controller: f } = this.getDatasetMeta(u), d = !r && s.indexOf(f) === -1; f.buildOrUpdateElements(d), o = Math.max(+f.getMaxOverflow(), o) } o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), r || V(s, u => { u.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(Lh("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { V(this.scales, e => { ue.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(e.events); (!Vd(n, i) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: i, start: r, count: s } of n) { const o = i === "_removeElements" ? -s : s; kk(e, r, o) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, i = s => new Set(e.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), r = i(0); for (let s = 1; s < n; s++)if (!Vd(r, i(s))) return; return Array.from(r).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(e) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; ue.update(this, this.width, this.height, e); const n = this.chartArea, i = n.width <= 0 || n.height <= 0; this._layers = [], V(this.boxes, r => { i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers())) }, this), this._layers.forEach((r, s) => { r._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 }) !== !1) { for (let n = 0, i = this.data.datasets.length; n < i; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, i = this.data.datasets.length; n < i; ++n)this._updateDataset(n, Mn(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const i = this.getDatasetMeta(e), r = { meta: i, index: e, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (Ne.has(this) ? this.attached && !Ne.running(this) && Ne.start(this) : (this.draw(), Ah({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: i, height: r } = this._resizeBeforeDraw; this._resize(i, r), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, i = []; let r, s; for (r = 0, s = n.length; r < s; ++r) { const o = n[r]; (!e || o.visible) && i.push(o) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, i = e._clip, r = !i.disabled, s = Ck(e) || this.chartArea, o = { meta: e, index: e.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (r && Oa(n, { left: i.left === !1 ? 0 : s.left - i.left, right: i.right === !1 ? this.width : s.right + i.right, top: i.top === !1 ? 0 : s.top - i.top, bottom: i.bottom === !1 ? this.height : s.bottom + i.bottom }), e.controller.draw(), r && Ta(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return es(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, i, r) { const s = ww.modes[n]; return typeof s == "function" ? s(this, e, i, r) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], i = this._metasets; let r = i.filter(s => s && s._dataset === n).pop(); return r || (r = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, i.push(r)), r } getContext() { return this.$context || (this.$context = Ln(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const i = this.getDatasetMeta(e); return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden } setDatasetVisibility(e, n) { const i = this.getDatasetMeta(e); i.hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, i) { const r = i ? "show" : "hide", s = this.getDatasetMeta(e), o = s.controller._resolveAnimations(void 0, r); be(n) ? (s.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(s, { visible: i }), this.update(a => a.datasetIndex === e ? r : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), Ne.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), rh(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete _o[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, i = (s, o) => { n.addEventListener(this, s, o), e[s] = o }, r = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; V(this.options.events, s => i(s, r)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, i = (l, u) => { n.addEventListener(this, l, u), e[l] = u }, r = (l, u) => { e[l] && (n.removeEventListener(this, l, u), delete e[l]) }, s = (l, u) => { this.canvas && this.resize(l, u) }; let o; const a = () => { r("attach", a), this.attached = !0, this.resize(), i("resize", s), i("detach", o) }; o = () => { this.attached = !1, r("resize", s), this._stop(), this._resize(0, 0), i("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { V(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, V(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, i) { const r = i ? "set" : "remove"; let s, o, a, l; for (n === "dataset" && (s = this.getDatasetMeta(e[0].datasetIndex), s.controller["_" + r + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) { o = e[a]; const u = o && this.getDatasetMeta(o.datasetIndex).controller; u && u[r + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], i = e.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !Go(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n)) } notifyPlugins(e, n, i) { return this._plugins.notify(this, e, n, i) } isPluginEnabled(e) { return this._plugins._cache.filter(n => n.plugin.id === e).length === 1 } _updateHoverStyles(e, n, i) { const r = this.options.hover, s = (l, u) => l.filter(c => !u.some(f => c.datasetIndex === f.datasetIndex && c.index === f.index)), o = s(n, e), a = i ? e : s(e, n); o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0) } _eventHandler(e, n) { const i = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, r = o => (o.options.events || this.options.events).includes(e.native.type); if (this.notifyPlugins("beforeEvent", i, r) === !1) return; const s = this._handleEvent(e, n, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (s || i.changed) && this.render(), this } _handleEvent(e, n, i) { const { _active: r = [], options: s } = this, o = n, a = this._getActiveElements(e, r, i, o), l = x_(e), u = Sk(e, this._lastEvent, i, l); i && (this._lastEvent = null, Q(s.onHover, [e, a, this], this), l && Q(s.onClick, [e, a, this], this)); const c = !Go(a, r); return (c || n) && (this._active = a, this._updateHoverStyles(a, r, n)), this._lastEvent = u, c } _getActiveElements(e, n, i, r) { if (e.type === "mouseout") return []; if (!i) return n; const s = this.options.hover; return this.getElementsAtEventForMode(e, s.mode, s, r) } }, z(tn, "defaults", mt), z(tn, "instances", _o), z(tn, "overrides", ni), z(tn, "registry", Pe), z(tn, "version", _k), z(tn, "getChart", Dh), tn); function Nh() { return V(L0.instances, t => t._plugins.invalidate()) } var sf = L0; function A0(t, e, n = e) { t.lineCap = j(n.borderCapStyle, e.borderCapStyle), t.setLineDash(j(n.borderDash, e.borderDash)), t.lineDashOffset = j(n.borderDashOffset, e.borderDashOffset), t.lineJoin = j(n.borderJoinStyle, e.borderJoinStyle), t.lineWidth = j(n.borderWidth, e.borderWidth), t.strokeStyle = j(n.borderColor, e.borderColor) } function Pk(t, e, n) { t.lineTo(n.x, n.y) } function Mk(t) { return t.stepped ? hb : t.tension || t.cubicInterpolationMode === "monotone" ? pb : Pk } function D0(t, e, n = {}) { const i = t.length, { start: r = 0, end: s = i - 1 } = n, { start: o, end: a } = e, l = Math.max(r, o), u = Math.min(s, a), c = r < o && s < o || r > a && s > a; return { count: i, start: l, loop: e.loop, ilen: u < l && !c ? i + u - l : u - l } } function Ek(t, e, n, i) { const { points: r, options: s } = e, { count: o, start: a, loop: l, ilen: u } = D0(r, n, i), c = Mk(s); let { move: f = !0, reverse: d } = i || {}, h, g, v; for (h = 0; h <= u; ++h)g = r[(a + (d ? u - h : h)) % o], !g.skip && (f ? (t.moveTo(g.x, g.y), f = !1) : c(t, v, g, d, s.stepped), v = g); return l && (g = r[(a + (d ? u : 0)) % o], c(t, v, g, d, s.stepped)), !!l } function Ok(t, e, n, i) { const r = e.points, { count: s, start: o, ilen: a } = D0(r, n, i), { move: l = !0, reverse: u } = i || {}; let c = 0, f = 0, d, h, g, v, x, m; const p = _ => (o + (u ? a - _ : _)) % s, y = () => { v !== x && (t.lineTo(c, x), t.lineTo(c, v), t.lineTo(c, m)) }; for (l && (h = r[p(0)], t.moveTo(h.x, h.y)), d = 0; d <= a; ++d) { if (h = r[p(d)], h.skip) continue; const _ = h.x, b = h.y, w = _ | 0; w === g ? (b < v ? v = b : b > x && (x = b), c = (f * c + _) / ++f) : (y(), t.lineTo(_, b), g = w, f = 0, v = x = b), m = b } y() } function Lu(t) { const e = t.options, n = e.borderDash && e.borderDash.length; return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !n ? Ok : Ek } function Tk(t) { return t.stepped ? Xb : t.tension || t.cubicInterpolationMode === "monotone" ? Kb : jn } function Lk(t, e, n, i) { let r = e._path; r || (r = e._path = new Path2D, e.path(r, n, i) && r.closePath()), A0(t, e.options), t.stroke(r) } function Ak(t, e, n, i) { const { segments: r, options: s } = e, o = Lu(e); for (const a of r) A0(t, s, a.style), t.beginPath(), o(t, e, a, { start: n, end: n + i - 1 }) && t.closePath(), t.stroke() } const Dk = typeof Path2D == "function"; function Nk(t, e, n, i) { Dk && !e.options.segment ? Lk(t, e, n, i) : Ak(t, e, n, i) } class dn extends Qe { constructor(e) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e) } updateControlPoints(e, n) { const i = this.options; if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) { const r = i.spanGaps ? this._loop : this._fullLoop; jb(this._points, i, e, r, n), this._pointsUpdated = !0 } } set points(e) { this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = tw(this, this.options.segment)) } first() { const e = this.segments, n = this.points; return e.length && n[e[0].start] } last() { const e = this.segments, n = this.points, i = e.length; return i && n[e[i - 1].end] } interpolate(e, n) { const i = this.options, r = e[n], s = this.points, o = x0(this, { property: n, start: r, end: r }); if (!o.length) return; const a = [], l = Tk(i); let u, c; for (u = 0, c = o.length; u < c; ++u) { const { start: f, end: d } = o[u], h = s[f], g = s[d]; if (h === g) { a.push(h); continue } const v = Math.abs((r - h[n]) / (g[n] - h[n])), x = l(h, g, v, i.stepped); x[n] = e[n], a.push(x) } return a.length === 1 ? a[0] : a } pathSegment(e, n, i) { return Lu(this)(e, this, n, i) } path(e, n, i) { const r = this.segments, s = Lu(this); let o = this._loop; n = n || 0, i = i || this.points.length - n; for (const a of r) o &= s(e, this, a, { start: n, end: n + i - 1 }); return !!o } draw(e, n, i, r) { const s = this.options || {}; (this.points || []).length && s.borderWidth && (e.save(), Nk(e, this, i, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } z(dn, "id", "line"), z(dn, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), z(dn, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), z(dn, "descriptors", { _scriptable: !0, _indexable: e => e !== "borderDash" && e !== "fill" }); function Ih(t, e, n, i) { const r = t.options, { [n]: s } = t.getProps([n], i); return Math.abs(e - s) < r.radius + r.hitRadius } class bo extends Qe { constructor(e) { super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange(e, n, i) { const r = this.options, { x: s, y: o } = this.getProps(["x", "y"], i); return Math.pow(e - s, 2) + Math.pow(n - o, 2) < Math.pow(r.hitRadius + r.radius, 2) } inXRange(e, n) { return Ih(this, e, "x", n) } inYRange(e, n) { return Ih(this, e, "y", n) } getCenterPoint(e) { const { x: n, y: i } = this.getProps(["x", "y"], e); return { x: n, y: i } } size(e) { e = e || this.options || {}; let n = e.radius || 0; n = Math.max(n, n && e.hoverRadius || 0); const i = n && e.borderWidth || 0; return (n + i) * 2 } draw(e, n) { const i = this.options; this.skip || i.radius < .1 || !es(this, n, this.size(i) / 2) || (e.strokeStyle = i.borderColor, e.lineWidth = i.borderWidth, e.fillStyle = i.backgroundColor, Ou(e, i, this.x, this.y)) } getRange() { const e = this.options || {}; return e.radius + e.hitRadius } } z(bo, "id", "point"), z(bo, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), z(bo, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); function Ik(t, e, n) { const i = t.segments, r = t.points, s = e.points, o = []; for (const a of i) { let { start: l, end: u } = a; u = of(l, u, r); const c = Au(n, r[l], r[u], a.loop); if (!e.segments) { o.push({ source: a, target: c, start: r[l], end: r[u] }); continue } const f = x0(e, c); for (const d of f) { const h = Au(n, s[d.start], s[d.end], d.loop), g = y0(a, r, h); for (const v of g) o.push({ source: v, target: d, start: { [n]: zh(c, h, "start", Math.max) }, end: { [n]: zh(c, h, "end", Math.min) } }) } } return o } function Au(t, e, n, i) { if (i) return; let r = e[t], s = n[t]; return t === "angle" && (r = Gt(r), s = Gt(s)), { property: t, start: r, end: s } } function zk(t, e) { const { x: n = null, y: i = null } = t || {}, r = e.points, s = []; return e.segments.forEach(({ start: o, end: a }) => { a = of(o, a, r); const l = r[o], u = r[a]; i !== null ? (s.push({ x: l.x, y: i }), s.push({ x: u.x, y: i })) : n !== null && (s.push({ x: n, y: l.y }), s.push({ x: n, y: u.y })) }), s } function of(t, e, n) { for (; e > t; e--) { const i = n[e]; if (!isNaN(i.x) && !isNaN(i.y)) break } return e } function zh(t, e, n, i) { return t && e ? i(t[n], e[n]) : t ? t[n] : e ? e[n] : 0 } function N0(t, e) { let n = [], i = !1; return st(t) ? (i = !0, n = t) : n = zk(t, e), n.length ? new dn({ points: n, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function Rh(t) { return t && t.fill !== !1 } function Rk(t, e, n) { let r = t[e].fill; const s = [e]; let o; if (!n) return r; for (; r !== !1 && s.indexOf(r) === -1;) { if (!ht(r)) return r; if (o = t[r], !o) return !1; if (o.visible) return r; s.push(r), r = o.fill } return !1 } function Fk(t, e, n) { const i = Wk(t); if (W(i)) return isNaN(i.value) ? !1 : i; let r = parseFloat(i); return ht(r) && Math.floor(r) === r ? jk(i[0], e, r, n) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i } function jk(t, e, n, i) { return (t === "-" || t === "+") && (n = e + n), n === e || n < 0 || n >= i ? !1 : n } function Bk(t, e) { let n = null; return t === "start" ? n = e.bottom : t === "end" ? n = e.top : W(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()), n } function Hk(t, e, n) { let i; return t === "start" ? i = n : t === "end" ? i = e.options.reverse ? e.min : e.max : W(t) ? i = t.value : i = e.getBaseValue(), i } function Wk(t) { const e = t.options, n = e.fill; let i = j(n && n.target, n); return i === void 0 && (i = !!e.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? "origin" : i } function $k(t) { const { scale: e, index: n, line: i } = t, r = [], s = i.segments, o = i.points, a = Vk(e, n); a.push(N0({ x: null, y: e.bottom }, i)); for (let l = 0; l < s.length; l++) { const u = s[l]; for (let c = u.start; c <= u.end; c++)Uk(r, o[c], a) } return new dn({ points: r, options: {} }) } function Vk(t, e) { const n = [], i = t.getMatchingVisibleMetas("line"); for (let r = 0; r < i.length; r++) { const s = i[r]; if (s.index === e) break; s.hidden || n.unshift(s.dataset) } return n } function Uk(t, e, n) { const i = []; for (let r = 0; r < n.length; r++) { const s = n[r], { first: o, last: a, point: l } = Yk(s, e, "x"); if (!(!l || o && a)) { if (o) i.unshift(l); else if (t.push(l), !a) break } } t.push(...i) } function Yk(t, e, n) { const i = t.interpolate(e, n); if (!i) return {}; const r = i[n], s = t.segments, o = t.points; let a = !1, l = !1; for (let u = 0; u < s.length; u++) { const c = s[u], f = o[c.start][n], d = o[c.end][n]; if (Si(r, f, d)) { a = r === f, l = r === d; break } } return { first: a, last: l, point: i } } class I0 { constructor(e) { this.x = e.x, this.y = e.y, this.radius = e.radius } pathSegment(e, n, i) { const { x: r, y: s, radius: o } = this; return n = n || { start: 0, end: Jt }, e.arc(r, s, o, n.end, n.start, !0), !i.bounds } interpolate(e) { const { x: n, y: i, radius: r } = this, s = e.angle; return { x: n + Math.cos(s) * r, y: i + Math.sin(s) * r, angle: s } } } function Xk(t) { const { chart: e, fill: n, line: i } = t; if (ht(n)) return Kk(e, n); if (n === "stack") return $k(t); if (n === "shape") return !0; const r = Qk(t); return r instanceof I0 ? r : N0(r, i) } function Kk(t, e) { const n = t.getDatasetMeta(e); return n && t.isDatasetVisible(e) ? n.dataset : null } function Qk(t) { return (t.scale || {}).getPointPositionForValue ? Zk(t) : Gk(t) } function Gk(t) { const { scale: e = {}, fill: n } = t, i = Bk(n, e); if (ht(i)) { const r = e.isHorizontal(); return { x: r ? i : null, y: r ? null : i } } return null } function Zk(t) { const { scale: e, fill: n } = t, i = e.options, r = e.getLabels().length, s = i.reverse ? e.max : e.min, o = Hk(n, e, s), a = []; if (i.grid.circular) { const l = e.getPointPositionForValue(0, s); return new I0({ x: l.x, y: l.y, radius: e.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < r; ++l)a.push(e.getPointPositionForValue(l, o)); return a } function yl(t, e, n) { const i = Xk(e), { line: r, scale: s, axis: o } = e, a = r.options, l = a.fill, u = a.backgroundColor, { above: c = u, below: f = u } = l || {}; i && r.points.length && (Oa(t, n), qk(t, { line: r, target: i, above: c, below: f, area: n, scale: s, axis: o }), Ta(t)) } function qk(t, e) { const { line: n, target: i, above: r, below: s, area: o, scale: a } = e, l = n._loop ? "angle" : e.axis; t.save(), l === "x" && s !== r && (Fh(t, i, o.top), jh(t, { line: n, target: i, color: r, scale: a, property: l }), t.restore(), t.save(), Fh(t, i, o.bottom)), jh(t, { line: n, target: i, color: s, scale: a, property: l }), t.restore() } function Fh(t, e, n) { const { segments: i, points: r } = e; let s = !0, o = !1; t.beginPath(); for (const a of i) { const { start: l, end: u } = a, c = r[l], f = r[of(l, u, r)]; s ? (t.moveTo(c.x, c.y), s = !1) : (t.lineTo(c.x, n), t.lineTo(c.x, c.y)), o = !!e.pathSegment(t, a, { move: o }), o ? t.closePath() : t.lineTo(f.x, n) } t.lineTo(e.first().x, n), t.closePath(), t.clip() } function jh(t, e) { const { line: n, target: i, property: r, color: s, scale: o } = e, a = Ik(n, i, r); for (const { source: l, target: u, start: c, end: f } of a) { const { style: { backgroundColor: d = s } = {} } = l, h = i !== !0; t.save(), t.fillStyle = d, Jk(t, o, h && Au(r, c, f)), t.beginPath(); const g = !!n.pathSegment(t, l); let v; if (h) { g ? t.closePath() : Bh(t, i, f, r); const x = !!i.pathSegment(t, u, { move: g, reverse: !0 }); v = g && x, v || Bh(t, i, c, r) } t.closePath(), t.fill(v ? "evenodd" : "nonzero"), t.restore() } } function Jk(t, e, n) { const { top: i, bottom: r } = e.chart.chartArea, { property: s, start: o, end: a } = n || {}; s === "x" && (t.beginPath(), t.rect(o, i, a - o, r - i), t.clip()) } function Bh(t, e, n, i) { const r = e.interpolate(n, i); r && t.lineTo(r.x, r.y) } var t2 = { id: "filler", afterDatasetsUpdate(t, e, n) { const i = (t.data.datasets || []).length, r = []; let s, o, a, l; for (o = 0; o < i; ++o)s = t.getDatasetMeta(o), a = s.dataset, l = null, a && a.options && a instanceof dn && (l = { visible: t.isDatasetVisible(o), index: o, fill: Fk(a, o, i), chart: t, axis: s.controller.options.indexAxis, scale: s.vScale, line: a }), s.$filler = l, r.push(l); for (o = 0; o < i; ++o)l = r[o], !(!l || l.fill === !1) && (l.fill = Rk(r, o, n.propagate)) }, beforeDraw(t, e, n) { const i = n.drawTime === "beforeDraw", r = t.getSortedVisibleDatasetMetas(), s = t.chartArea; for (let o = r.length - 1; o >= 0; --o) { const a = r[o].$filler; !a || (a.line.updateControlPoints(s, a.axis), i && a.fill && yl(t.ctx, a, s)) } }, beforeDatasetsDraw(t, e, n) { if (n.drawTime !== "beforeDatasetsDraw") return; const i = t.getSortedVisibleDatasetMetas(); for (let r = i.length - 1; r >= 0; --r) { const s = i[r].$filler; Rh(s) && yl(t.ctx, s, t.chartArea) } }, beforeDatasetDraw(t, e, n) { const i = e.meta.$filler; !Rh(i) || n.drawTime !== "beforeDatasetDraw" || yl(t.ctx, i, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const Hh = (t, e) => { let { boxHeight: n = e, boxWidth: i = e } = t; return t.usePointStyle && (n = Math.min(n, e), i = t.pointStyleWidth || Math.min(i, e)), { boxWidth: i, boxHeight: n, itemHeight: Math.max(e, n) } }, e2 = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index; class Wh extends Qe { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, i) { this.maxWidth = e, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = Q(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(i => e.filter(i, this.chart.data))), e.sort && (n = n.sort((i, r) => e.sort(i, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) { this.width = this.height = 0; return } const i = e.labels, r = xt(i.font), s = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Hh(i, s); let u, c; n.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, s, a, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, r, a, l) + 10), this.width = Math.min(u, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight) } _fitRows(e, n, i, r) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [0], c = r + a; let f = e; s.textAlign = "left", s.textBaseline = "middle"; let d = -1, h = -c; return this.legendItems.forEach((g, v) => { const x = i + n / 2 + s.measureText(g.text).width; (v === 0 || u[u.length - 1] + x + 2 * a > o) && (f += c, u[u.length - (v > 0 ? 0 : 1)] = 0, h += c, d++), l[v] = { left: 0, top: h, row: d, width: x, height: r }, u[u.length - 1] += x + a }), f } _fitCols(e, n, i, r) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - e; let f = a, d = 0, h = 0, g = 0, v = 0; return this.legendItems.forEach((x, m) => { const { itemWidth: p, itemHeight: y } = n2(i, n, s, x, r); m > 0 && h + y + 2 * a > c && (f += d + a, u.push({ width: d, height: h }), g += d + a, v++, d = h = 0), l[m] = { left: g, top: h, col: v, width: p, height: y }, d = Math.max(d, p), h += y + a }), f += d, u.push({ width: d, height: h }), f } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: r }, rtl: s } } = this, o = Di(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = Tt(i, this.left + r, this.right - this.lineWidths[a]); for (const u of n) a !== u.row && (a = u.row, l = Tt(i, this.left + r, this.right - this.lineWidths[a])), u.top += this.top + e + r, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + r } else { let a = 0, l = Tt(i, this.top + e + r, this.bottom - this.columnSizes[a].height); for (const u of n) u.col !== a && (a = u.col, l = Tt(i, this.top + e + r, this.bottom - this.columnSizes[a].height)), u.top = l, u.left += this.left + r, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + r } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const e = this.ctx; Oa(e, this), this._draw(), Ta(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: i, ctx: r } = this, { align: s, labels: o } = e, a = mt.color, l = Di(e.rtl, this.left, this.width), u = xt(o.font), { padding: c } = o, f = u.size, d = f / 2; let h; this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = u.string; const { boxWidth: g, boxHeight: v, itemHeight: x } = Hh(o, f), m = function (w, k, S) { if (isNaN(g) || g <= 0 || isNaN(v) || v < 0) return; r.save(); const P = j(S.lineWidth, 1); if (r.fillStyle = j(S.fillStyle, a), r.lineCap = j(S.lineCap, "butt"), r.lineDashOffset = j(S.lineDashOffset, 0), r.lineJoin = j(S.lineJoin, "miter"), r.lineWidth = P, r.strokeStyle = j(S.strokeStyle, a), r.setLineDash(j(S.lineDash, [])), o.usePointStyle) { const M = { radius: v * Math.SQRT2 / 2, pointStyle: S.pointStyle, rotation: S.rotation, borderWidth: P }, D = l.xPlus(w, g / 2), F = k + d; a0(r, M, D, F, o.pointStyleWidth && g) } else { const M = k + Math.max((f - v) / 2, 0), D = l.leftForLtr(w, g), F = Ai(S.borderRadius); r.beginPath(), Object.values(F).some(A => A !== 0) ? na(r, { x: D, y: M, w: g, h: v, radius: F }) : r.rect(D, M, g, v), r.fill(), P !== 0 && r.stroke() } r.restore() }, p = function (w, k, S) { ii(r, S.text, w, k + x / 2, u, { strikethrough: S.hidden, textAlign: l.textAlign(S.textAlign) }) }, y = this.isHorizontal(), _ = this._computeTitleHeight(); y ? h = { x: Tt(s, this.left + c, this.right - i[0]), y: this.top + c + _, line: 0 } : h = { x: this.left + c, y: Tt(s, this.top + _ + c, this.bottom - n[0].height), line: 0 }, m0(this.ctx, e.textDirection); const b = x + c; this.legendItems.forEach((w, k) => { r.strokeStyle = w.fontColor, r.fillStyle = w.fontColor; const S = r.measureText(w.text).width, P = l.textAlign(w.textAlign || (w.textAlign = o.textAlign)), M = g + d + S; let D = h.x, F = h.y; l.setWidth(this.width), y ? k > 0 && D + M + c > this.right && (F = h.y += b, h.line++, D = h.x = Tt(s, this.left + c, this.right - i[h.line])) : k > 0 && F + b > this.bottom && (D = h.x = D + n[h.line].width + c, h.line++, F = h.y = Tt(s, this.top + _ + c, this.bottom - n[h.line].height)); const A = l.x(D); if (m(A, F, w), D = A_(P, D + g + d, y ? D + M : this.right, e.rtl), p(l.x(D), F, w), y) h.x += M + c; else if (typeof w.text != "string") { const ut = u.lineHeight; h.y += z0(w, ut) } else h.y += b }), g0(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, i = xt(n.font), r = Dt(n.padding); if (!n.display) return; const s = Di(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = i.size / 2, u = r.top + l; let c, f = this.left, d = this.width; if (this.isHorizontal()) d = Math.max(...this.lineWidths), c = this.top + u, f = Tt(e.align, f, this.right - d); else { const g = this.columnSizes.reduce((v, x) => Math.max(v, x.height), 0); c = u + Tt(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight()) } const h = Tt(a, f, f + d); o.textAlign = s.textAlign(Kc(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = i.string, ii(o, n.text, h, c, i) } _computeTitleHeight() { const e = this.options.title, n = xt(e.font), i = Dt(e.padding); return e.display ? n.lineHeight + i.height : 0 } _getLegendItemAt(e, n) { let i, r, s; if (Si(e, this.left, this.right) && Si(n, this.top, this.bottom)) { for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)if (r = s[i], Si(e, r.left, r.left + r.width) && Si(n, r.top, r.top + r.height)) return this.legendItems[i] } return null } handleEvent(e) { const n = this.options; if (!s2(e.type, n)) return; const i = this._getLegendItemAt(e.x, e.y); if (e.type === "mousemove" || e.type === "mouseout") { const r = this._hoveredItem, s = e2(r, i); r && !s && Q(n.onLeave, [e, r, this], this), this._hoveredItem = i, i && !s && Q(n.onHover, [e, i, this], this) } else i && Q(n.onClick, [e, i, this], this) } } function n2(t, e, n, i, r) { const s = i2(i, t, e, n), o = r2(r, i, e.lineHeight); return { itemWidth: s, itemHeight: o } } function i2(t, e, n, i) { let r = t.text; return r && typeof r != "string" && (r = r.reduce((s, o) => s.length > o.length ? s : o)), e + n.size / 2 + i.measureText(r).width } function r2(t, e, n) { let i = t; return typeof e.text != "string" && (i = z0(e, n)), i } function z0(t, e) { const n = t.text ? t.text.length + .5 : 0; return e * n } function s2(t, e) { return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup")) } var o2 = { id: "legend", _element: Wh, start(t, e, n) { const i = t.legend = new Wh({ ctx: t.ctx, options: n, chart: t }); ue.configure(t, i, n), ue.addBox(t, i) }, stop(t) { ue.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const i = t.legend; ue.configure(t, i, n), i.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const i = e.datasetIndex, r = n.chart; r.isDatasetVisible(i) ? (r.hide(i), e.hidden = !0) : (r.show(i), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: r, color: s, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(l => { const u = l.controller.getStyle(n ? 0 : void 0), c = Dt(u.borderWidth); return { text: e[l.index].label, fillStyle: u.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: u.borderCapStyle, lineDash: u.borderDash, lineDashOffset: u.borderDashOffset, lineJoin: u.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: u.borderColor, pointStyle: i || u.pointStyle, rotation: u.rotation, textAlign: r || u.textAlign, borderRadius: o && (a || u.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class R0 extends Qe { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = e, this.height = this.bottom = n; const r = st(i.text) ? i.text.length : 1; this._padding = Dt(i.padding); const s = r * xt(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const e = this.options.position; return e === "top" || e === "bottom" } _drawArgs(e) { const { top: n, left: i, bottom: r, right: s, options: o } = this, a = o.align; let l = 0, u, c, f; return this.isHorizontal() ? (c = Tt(a, i, s), f = n + e, u = s - i) : (o.position === "left" ? (c = i + e, f = Tt(a, r, n), l = bt * -.5) : (c = s - e, f = Tt(a, n, r), l = bt * .5), u = r - n), { titleX: c, titleY: f, maxWidth: u, rotation: l } } draw() { const e = this.ctx, n = this.options; if (!n.display) return; const i = xt(n.font), s = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: u } = this._drawArgs(s); ii(e, n.text, 0, 0, i, { color: n.color, maxWidth: l, rotation: u, textAlign: Kc(n.align), textBaseline: "middle", translation: [o, a] }) } } function a2(t, e) { const n = new R0({ ctx: t.ctx, options: e, chart: t }); ue.configure(t, n, e), ue.addBox(t, n), t.titleBlock = n } var l2 = { id: "title", _element: R0, start(t, e, n) { a2(t, n) }, stop(t) { const e = t.titleBlock; ue.removeBox(t, e), delete t.titleBlock }, beforeUpdate(t, e, n) { const i = t.titleBlock; ue.configure(t, i, n), i.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const mr = { average(t) { if (!t.length) return !1; let e, n, i = 0, r = 0, s = 0; for (e = 0, n = t.length; e < n; ++e) { const o = t[e].element; if (o && o.hasValue()) { const a = o.tooltipPosition(); i += a.x, r += a.y, ++s } } return { x: i / s, y: r / s } }, nearest(t, e) { if (!t.length) return !1; let n = e.x, i = e.y, r = Number.POSITIVE_INFINITY, s, o, a; for (s = 0, o = t.length; s < o; ++s) { const l = t[s].element; if (l && l.hasValue()) { const u = l.getCenterPoint(), c = Pu(e, u); c < r && (r = c, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, i = l.y } return { x: n, y: i } } }; function Se(t, e) { return e && (st(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function Ie(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t
} function u2(t, e) { const { element: n, datasetIndex: i, index: r } = e, s = t.getDatasetMeta(i).controller, { label: o, value: a } = s.getLabelAndValue(r); return { chart: t, label: o, parsed: s.getParsed(r), raw: t.data.datasets[i].data[r], formattedValue: a, dataset: s.getDataset(), dataIndex: r, datasetIndex: i, element: n } } function $h(t, e) { const n = t.chart.ctx, { body: i, footer: r, title: s } = t, { boxWidth: o, boxHeight: a } = e, l = xt(e.bodyFont), u = xt(e.titleFont), c = xt(e.footerFont), f = s.length, d = r.length, h = i.length, g = Dt(e.padding); let v = g.height, x = 0, m = i.reduce((_, b) => _ + b.before.length + b.lines.length + b.after.length, 0); if (m += t.beforeBody.length + t.afterBody.length, f && (v += f * u.lineHeight + (f - 1) * e.titleSpacing + e.titleMarginBottom), m) { const _ = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight; v += h * _ + (m - h) * l.lineHeight + (m - 1) * e.bodySpacing } d && (v += e.footerMarginTop + d * c.lineHeight + (d - 1) * e.footerSpacing); let p = 0; const y = function (_) { x = Math.max(x, n.measureText(_).width + p) }; return n.save(), n.font = u.string, V(t.title, y), n.font = l.string, V(t.beforeBody.concat(t.afterBody), y), p = e.displayColors ? o + 2 + e.boxPadding : 0, V(i, _ => { V(_.before, y), V(_.lines, y), V(_.after, y) }), p = 0, n.font = c.string, V(t.footer, y), n.restore(), x += g.width, { width: x, height: v } } function c2(t, e) { const { y: n, height: i } = e; return n < i / 2 ? "top" : n > t.height - i / 2 ? "bottom" : "center" } function f2(t, e, n, i) { const { x: r, width: s } = i, o = n.caretSize + n.caretPadding; if (t === "left" && r + s + o > e.width || t === "right" && r - s - o < 0) return !0 } function d2(t, e, n, i) { const { x: r, width: s } = n, { width: o, chartArea: { left: a, right: l } } = t; let u = "center"; return i === "center" ? u = r <= (a + l) / 2 ? "left" : "right" : r <= s / 2 ? u = "left" : r >= o - s / 2 && (u = "right"), f2(u, t, e, n) && (u = "center"), u } function Vh(t, e, n) { const i = n.yAlign || e.yAlign || c2(t, n); return { xAlign: n.xAlign || e.xAlign || d2(t, e, n, i), yAlign: i } } function h2(t, e) { let { x: n, width: i } = t; return e === "right" ? n -= i : e === "center" && (n -= i / 2), n } function p2(t, e, n) { let { y: i, height: r } = t; return e === "top" ? i += n : e === "bottom" ? i -= r + n : i -= r / 2, i } function Uh(t, e, n, i) { const { caretSize: r, caretPadding: s, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, u = r + s, { topLeft: c, topRight: f, bottomLeft: d, bottomRight: h } = Ai(o); let g = h2(e, a); const v = p2(e, l, u); return l === "center" ? a === "left" ? g += u : a === "right" && (g -= u) : a === "left" ? g -= Math.max(c, d) + r : a === "right" && (g += Math.max(f, h) + r), { x: le(g, 0, i.width - e.width), y: le(v, 0, i.height - e.height) } } function Js(t, e, n) { const i = Dt(n.padding); return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - i.right : t.x + i.left } function Yh(t) { return Se([], Ie(t)) } function m2(t, e, n) { return Ln(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) } function Xh(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const F0 = { beforeTitle: De, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, i = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return e.dataset.label || ""; if (e.label) return e.label; if (i > 0 && e.dataIndex < i) return n[e.dataIndex] } return "" }, afterTitle: De, beforeBody: De, beforeLabel: De, label(t) { if (this && this.options && this.options.mode === "dataset") return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return et(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: De, afterBody: De, beforeFooter: De, footer: De, afterFooter: De }; function Ft(t, e, n, i) { const r = t[e].call(n, i); return typeof r > "u" ? F0[e].call(n, i) : r } class Du extends Qe { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && n.options.animation && i.animations, s = new _0(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = m2(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: i } = n, r = Ft(i, "beforeTitle", this, e), s = Ft(i, "title", this, e), o = Ft(i, "afterTitle", this, e); let a = []; return a = Se(a, Ie(r)), a = Se(a, Ie(s)), a = Se(a, Ie(o)), a } getBeforeBody(e, n) { return Yh(Ft(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: i } = n, r = []; return V(e, s => { const o = { before: [], lines: [], after: [] }, a = Xh(i, s); Se(o.before, Ie(Ft(a, "beforeLabel", this, s))), Se(o.lines, Ft(a, "label", this, s)), Se(o.after, Ie(Ft(a, "afterLabel", this, s))), r.push(o) }), r } getAfterBody(e, n) { return Yh(Ft(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: i } = n, r = Ft(i, "beforeFooter", this, e), s = Ft(i, "footer", this, e), o = Ft(i, "afterFooter", this, e); let a = []; return a = Se(a, Ie(r)), a = Se(a, Ie(s)), a = Se(a, Ie(o)), a } _createItems(e) { const n = this._active, i = this.chart.data, r = [], s = [], o = []; let a = [], l, u; for (l = 0, u = n.length; l < u; ++l)a.push(u2(this.chart, n[l])); return e.filter && (a = a.filter((c, f, d) => e.filter(c, f, d, i))), e.itemSort && (a = a.sort((c, f) => e.itemSort(c, f, i))), V(a, c => { const f = Xh(e.callbacks, c); r.push(Ft(f, "labelColor", this, c)), s.push(Ft(f, "labelPointStyle", this, c)), o.push(Ft(f, "labelTextColor", this, c)) }), this.labelColors = r, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(e, n) { const i = this.options.setContext(this.getContext()), r = this._active; let s, o = []; if (!r.length) this.opacity !== 0 && (s = { opacity: 0 }); else { const a = mr[i.position].call(this, r, this._eventPosition); o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i); const l = this._size = $h(this, i), u = Object.assign({}, a, l), c = Vh(this.chart, i, u), f = Uh(i, u, c, this.chart); this.xAlign = c.xAlign, this.yAlign = c.yAlign, s = { opacity: 1, x: f.x, y: f.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), e && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, i, r) { const s = this.getCaretPosition(e, i, r); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(e, n, i) { const { xAlign: r, yAlign: s } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: f } = Ai(a), { x: d, y: h } = e, { width: g, height: v } = n; let x, m, p, y, _, b; return s === "center" ? (_ = h + v / 2, r === "left" ? (x = d, m = x - o, y = _ + o, b = _ - o) : (x = d + g, m = x + o, y = _ - o, b = _ + o), p = x) : (r === "left" ? m = d + Math.max(l, c) + o : r === "right" ? m = d + g - Math.max(u, f) - o : m = this.caretX, s === "top" ? (y = h, _ = y - o, x = m - o, p = m + o) : (y = h + v, _ = y + o, x = m + o, p = m - o), b = y), { x1: x, x2: m, x3: p, y1: y, y2: _, y3: b } } drawTitle(e, n, i) { const r = this.title, s = r.length; let o, a, l; if (s) { const u = Di(i.rtl, this.x, this.width); for (e.x = Js(this, i.titleAlign, i), n.textAlign = u.textAlign(i.titleAlign), n.textBaseline = "middle", o = xt(i.titleFont), a = i.titleSpacing, n.fillStyle = i.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(r[l], u.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === s && (e.y += i.titleMarginBottom - a) } } _drawColorBox(e, n, i, r, s) { const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: u, boxPadding: c } = s, f = xt(s.bodyFont), d = Js(this, "left", s), h = r.x(d), g = l < f.lineHeight ? (f.lineHeight - l) / 2 : 0, v = n.y + g; if (s.usePointStyle) { const x = { radius: Math.min(u, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, m = r.leftForLtr(h, u) + u / 2, p = v + l / 2; e.strokeStyle = s.multiKeyBackground, e.fillStyle = s.multiKeyBackground, Ou(e, x, m, p), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Ou(e, x, m, p) } else { e.lineWidth = W(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const x = r.leftForLtr(h, u - c), m = r.leftForLtr(r.xPlus(h, 1), u - c - 2), p = Ai(o.borderRadius); Object.values(p).some(y => y !== 0) ? (e.beginPath(), e.fillStyle = s.multiKeyBackground, na(e, { x, y: v, w: u, h: l, radius: p }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), na(e, { x: m, y: v + 1, w: u - 2, h: l - 2, radius: p }), e.fill()) : (e.fillStyle = s.multiKeyBackground, e.fillRect(x, v, u, l), e.strokeRect(x, v, u, l), e.fillStyle = o.backgroundColor, e.fillRect(m, v + 1, u - 2, l - 2)) } e.fillStyle = this.labelTextColors[i] } drawBody(e, n, i) { const { body: r } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: u, boxPadding: c } = i, f = xt(i.bodyFont); let d = f.lineHeight, h = 0; const g = Di(i.rtl, this.x, this.width), v = function (S) { n.fillText(S, g.x(e.x + h), e.y + d / 2), e.y += d + s }, x = g.textAlign(o); let m, p, y, _, b, w, k; for (n.textAlign = o, n.textBaseline = "middle", n.font = f.string, e.x = Js(this, x, i), n.fillStyle = i.bodyColor, V(this.beforeBody, v), h = a && x !== "right" ? o === "center" ? u / 2 + c : u + 2 + c : 0, _ = 0, w = r.length; _ < w; ++_) { for (m = r[_], p = this.labelTextColors[_], n.fillStyle = p, V(m.before, v), y = m.lines, a && y.length && (this._drawColorBox(n, e, _, g, i), d = Math.max(f.lineHeight, l)), b = 0, k = y.length; b < k; ++b)v(y[b]), d = f.lineHeight; V(m.after, v) } h = 0, d = f.lineHeight, V(this.afterBody, v), e.y -= s } drawFooter(e, n, i) { const r = this.footer, s = r.length; let o, a; if (s) { const l = Di(i.rtl, this.x, this.width); for (e.x = Js(this, i.footerAlign, i), e.y += i.footerMarginTop, n.textAlign = l.textAlign(i.footerAlign), n.textBaseline = "middle", o = xt(i.footerFont), n.fillStyle = i.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(r[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + i.footerSpacing } } drawBackground(e, n, i, r) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = e, { width: u, height: c } = i, { topLeft: f, topRight: d, bottomLeft: h, bottomRight: g } = Ai(r.cornerRadius); n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(a + f, l), o === "top" && this.drawCaret(e, n, i, r), n.lineTo(a + u - d, l), n.quadraticCurveTo(a + u, l, a + u, l + d), o === "center" && s === "right" && this.drawCaret(e, n, i, r), n.lineTo(a + u, l + c - g), n.quadraticCurveTo(a + u, l + c, a + u - g, l + c), o === "bottom" && this.drawCaret(e, n, i, r), n.lineTo(a + h, l + c), n.quadraticCurveTo(a, l + c, a, l + c - h), o === "center" && s === "left" && this.drawCaret(e, n, i, r), n.lineTo(a, l + f), n.quadraticCurveTo(a, l, a + f, l), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, i = this.$animations, r = i && i.x, s = i && i.y; if (r || s) { const o = mr[e.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = $h(this, e), l = Object.assign({}, o, this._size), u = Vh(n, e, l), c = Uh(e, l, u, n); (r._to !== c.x || s._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(n); const r = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const o = Dt(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && a && (e.save(), e.globalAlpha = i, this.drawBackground(s, e, r, n), m0(e, n.textDirection), s.y += o.top, this.drawTitle(s, e, n), this.drawBody(s, e, n), this.drawFooter(s, e, n), g0(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const i = this._active, r = e.map(({ datasetIndex: a, index: l }) => { const u = this.chart.getDatasetMeta(a); if (!u) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: u.data[l], index: l } }), s = !Go(i, r), o = this._positionChanged(r, n); (s || o) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, i = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, s = this._active || [], o = this._getActiveElements(e, s, n, i), a = this._positionChanged(o, e), l = n || !Go(o, s) || a; return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), l } _getActiveElements(e, n, i, r) { const s = this.options; if (e.type === "mouseout") return []; if (!r) return n; const o = this.chart.getElementsAtEventForMode(e, s.mode, s, i); return s.reverse && o.reverse(), o } _positionChanged(e, n) { const { caretX: i, caretY: r, options: s } = this, o = mr[s.position].call(this, e, n); return o !== !1 && (i !== o.x || r !== o.y) } } z(Du, "positioners", mr); var g2 = { id: "tooltip", _element: Du, positioners: mr, afterInit(t, e, n) { n && (t.tooltip = new Du({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (t.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { if (t.tooltip) { const n = e.replay; t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: F0 }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => t !== "filter" && t !== "itemSort" && t !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }; const v2 = (t, e, n, i) => (typeof e == "string" ? (n = t.push(e) - 1, i.unshift({ index: n, label: e })) : isNaN(e) && (n = null), n); function y2(t, e, n, i) { const r = t.indexOf(e); if (r === -1) return v2(t, e, n, i); const s = t.lastIndexOf(e); return r !== s ? n : r } const x2 = (t, e) => t === null ? null : le(Math.round(t), 0, e); function Kh(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } class Nu extends oi { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const n = this._addedLabels; if (n.length) { const i = this.getLabels(); for (const { index: r, label: s } of n) i[r] === s && i.splice(r, 1); this._addedLabels = [] } super.init(e) } parse(e, n) { if (et(e)) return null; const i = this.getLabels(); return n = isFinite(n) && i[n] === e ? n : y2(i, e, j(n, e), this._addedLabels), x2(n, i.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let { min: i, max: r } = this.getMinMax(!0); this.options.bounds === "ticks" && (e || (i = 0), n || (r = this.getLabels().length - 1)), this.min = i, this.max = r } buildTicks() { const e = this.min, n = this.max, i = this.options.offset, r = []; let s = this.getLabels(); s = e === 0 && n === s.length - 1 ? s : s.slice(e, n + 1), this._valueRange = Math.max(s.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let o = e; o <= n; o++)r.push({ value: o }); return r } getLabelForValue(e) { return Kh.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } z(Nu, "id", "category"), z(Nu, "defaults", { ticks: { callback: Kh } }); function _2(t, e) { const n = [], { bounds: r, step: s, min: o, max: a, precision: l, count: u, maxTicks: c, maxDigits: f, includeBounds: d } = t, h = s || 1, g = c - 1, { min: v, max: x } = e, m = !et(o), p = !et(a), y = !et(u), _ = (x - v) / (f + 1); let b = Yd((x - v) / g / h) * h, w, k, S, P; if (b < 1e-14 && !m && !p) return [{ value: v }, { value: x }]; P = Math.ceil(x / b) - Math.floor(v / b), P > g && (b = Yd(P * b / g / h) * h), et(l) || (w = Math.pow(10, l), b = Math.ceil(b * w) / w), r === "ticks" ? (k = Math.floor(v / b) * b, S = Math.ceil(x / b) * b) : (k = v, S = x), m && p && s && k_((a - o) / s, b / 1e3) ? (P = Math.round(Math.min((a - o) / b, c)), b = (a - o) / P, k = o, S = a) : y ? (k = m ? o : k, S = p ? a : S, P = u - 1, b = (S - k) / P) : (P = (S - k) / b, Er(P, Math.round(P), b / 1e3) ? P = Math.round(P) : P = Math.ceil(P)); const M = Math.max(Xd(b), Xd(k)); w = Math.pow(10, et(l) ? M : l), k = Math.round(k * w) / w, S = Math.round(S * w) / w; let D = 0; for (m && (d && k !== o ? (n.push({ value: o }), k < o && D++, Er(Math.round((k + D * b) * w) / w, o, Qh(o, _, t)) && D++) : k < o && D++); D < P; ++D)n.push({ value: Math.round((k + D * b) * w) / w }); return p && d && S !== a ? n.length && Er(n[n.length - 1].value, a, Qh(a, _, t)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!p || S === a) && n.push({ value: S }), n } function Qh(t, e, { horizontal: n, minRotation: i }) { const r = cn(i), s = (n ? Math.sin(r) : Math.cos(r)) || .001, o = .75 * e * ("" + t).length; return Math.min(e / s, o) } class oa extends oi { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return et(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds(); let { min: r, max: s } = this; const o = l => r = n ? r : l, a = l => s = i ? s : l; if (e) { const l = Wi(r), u = Wi(s); l < 0 && u < 0 ? a(0) : l > 0 && u > 0 && o(0) } if (r === s) { let l = s === 0 ? 1 : Math.abs(s * .05); a(s + l), e || o(r - l) } this.min = r, this.max = s } getTickLimit() { const e = this.options.ticks; let { maxTicksLimit: n, stepSize: i } = e, r; return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const r = { maxTicks: i, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, s = this._range || this, o = _2(r, s); return e.bounds === "ticks" && Gg(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const e = this.ticks; let n = this.min, i = this.max; if (super.configure(), this.options.offset && e.length) { const r = (i - n) / Math.max(e.length - 1, 1) / 2; n -= r, i += r } this._startValue = n, this._endValue = i, this._valueRange = i - n } getLabelForValue(e) { return qc(e, this.chart.options.locale, this.options.ticks.format) } } class Iu extends oa { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = ht(e) ? e : 0, this.max = ht(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, i = cn(this.options.ticks.minRotation), r = (e ? Math.sin(i) : Math.cos(i)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / r)) } getPixelForValue(e) { return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } z(Iu, "id", "linear"), z(Iu, "defaults", { ticks: { callback: Ea.formatters.numeric } }); const is = t => Math.floor(un(t)), In = (t, e) => Math.pow(10, is(t) + e); function Gh(t) { return t / Math.pow(10, is(t)) === 1 } function Zh(t, e, n) { const i = Math.pow(10, n), r = Math.floor(t / i); return Math.ceil(e / i) - r } function b2(t, e) { const n = e - t; let i = is(n); for (; Zh(t, e, i) > 10;)i++; for (; Zh(t, e, i) < 10;)i--; return Math.min(i, is(t)) } function w2(t, { min: e, max: n }) { e = Kt(t.min, e); const i = [], r = is(e); let s = b2(e, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = r > s ? Math.pow(10, r) : 0, u = Math.round((e - l) * o) / o, c = Math.floor((e - l) / a / 10) * a * 10; let f = Math.floor((u - c) / Math.pow(10, s)), d = Kt(t.min, Math.round((l + c + f * Math.pow(10, s)) * o) / o); for (; d < n;)i.push({ value: d, major: Gh(d), significand: f }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (s++, f = 2, o = s >= 0 ? 1 : o), d = Math.round((l + c + f * Math.pow(10, s)) * o) / o; const h = Kt(t.max, d); return i.push({ value: h, major: Gh(h), significand: f }), i } class qh extends oi { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const i = oa.prototype.parse.apply(this, [e, n]); if (i === 0) { this._zero = !0; return } return ht(i) && i > 0 ? i : null } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = ht(e) ? Math.max(0, e) : null, this.max = ht(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !ht(this._userMin) && (this.min = e === In(this.min, 0) ? In(this.min, -1) : In(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let i = this.min, r = this.max; const s = a => i = e ? i : a, o = a => r = n ? r : a; i === r && (i <= 0 ? (s(1), o(10)) : (s(In(i, -1)), o(In(r, 1)))), i <= 0 && s(In(r, -1)), r <= 0 && o(In(i, 1)), this.min = i, this.max = r } buildTicks() { const e = this.options, n = { min: this._userMin, max: this._userMax }, i = w2(n, this); return e.bounds === "ticks" && Gg(i, this, "value"), e.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(e) { return e === void 0 ? "0" : qc(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = un(e), this._valueRange = un(this.max) - un(e) } getPixelForValue(e) { return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (un(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } z(qh, "id", "logarithmic"), z(qh, "defaults", { ticks: { callback: Ea.formatters.logarithmic, major: { enabled: !0 } } }); function zu(t) { const e = t.ticks; if (e.display && t.display) { const n = Dt(e.backdropPadding); return j(e.font && e.font.size, mt.font.size) + n.height } return 0 } function k2(t, e, n) { return n = st(n) ? n : [n], { w: db(t, e.string, n), h: n.length * e.lineHeight } } function Jh(t, e, n, i, r) { return t === i || t === r ? { start: e - n / 2, end: e + n / 2 } : t < i || t > r ? { start: e - n, end: e } : { start: e, end: e + n } } function S2(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), i = [], r = [], s = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? bt / s : 0; for (let l = 0; l < s; l++) { const u = o.setContext(t.getPointLabelContext(l)); r[l] = u.padding; const c = t.getPointPosition(l, t.drawingArea + r[l], a), f = xt(u.font), d = k2(t.ctx, f, t._pointLabels[l]); i[l] = d; const h = Gt(t.getIndexAngle(l) + a), g = Math.round(Yc(h)), v = Jh(g, c.x, d.w, 0, 180), x = Jh(g, c.y, d.h, 90, 270); C2(n, e, h, v, x) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = P2(t, i, r) } function C2(t, e, n, i, r) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; i.start < e.l ? (a = (e.l - i.start) / s, t.l = Math.min(t.l, e.l - a)) : i.end > e.r && (a = (i.end - e.r) / s, t.r = Math.max(t.r, e.r + a)), r.start < e.t ? (l = (e.t - r.start) / o, t.t = Math.min(t.t, e.t - l)) : r.end > e.b && (l = (r.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function P2(t, e, n) { const i = [], r = t._pointLabels.length, s = t.options, o = zu(s) / 2, a = t.drawingArea, l = s.pointLabels.centerPointLabels ? bt / r : 0; for (let u = 0; u < r; u++) { const c = t.getPointPosition(u, a + o + n[u], l), f = Math.round(Yc(Gt(c.angle + Wt))), d = e[u], h = O2(c.y, d.h, f), g = M2(f), v = E2(c.x, d.w, g); i.push({ x: c.x, y: h, textAlign: g, left: v, top: h, right: v + d.w, bottom: h + d.h }) } return i } function M2(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right" } function E2(t, e, n) { return n === "right" ? t -= e : n === "center" && (t -= e / 2), t } function O2(t, e, n) { return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t } function T2(t, e) { const { ctx: n, options: { pointLabels: i } } = t; for (let r = e - 1; r >= 0; r--) { const s = i.setContext(t.getPointLabelContext(r)), o = xt(s.font), { x: a, y: l, textAlign: u, left: c, top: f, right: d, bottom: h } = t._pointLabelItems[r], { backdropColor: g } = s; if (!et(g)) { const v = Ai(s.borderRadius), x = Dt(s.backdropPadding); n.fillStyle = g; const m = c - x.left, p = f - x.top, y = d - c + x.width, _ = h - f + x.height; Object.values(v).some(b => b !== 0) ? (n.beginPath(), na(n, { x: m, y: p, w: y, h: _, radius: v }), n.fill()) : n.fillRect(m, p, y, _) } ii(n, t._pointLabels[r], a, l + o.lineHeight / 2, o, { color: s.color, textAlign: u, textBaseline: "middle" }) } } function j0(t, e, n, i) { const { ctx: r } = t; if (n) r.arc(t.xCenter, t.yCenter, e, 0, Jt); else { let s = t.getPointPosition(0, e); r.moveTo(s.x, s.y); for (let o = 1; o < i; o++)s = t.getPointPosition(o, e), r.lineTo(s.x, s.y) } } function L2(t, e, n, i, r) { const s = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !i || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(r.dash), s.lineDashOffset = r.dashOffset, s.beginPath(), j0(t, n, o, i), s.closePath(), s.stroke(), s.restore()) } function A2(t, e, n) { return Ln(t, { label: n, index: e, type: "pointLabel" }) } class to extends oa { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = Dt(zu(this.options) / 2), n = this.width = this.maxWidth - e.width, i = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + i / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, i) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = ht(e) && !isNaN(e) ? e : 0, this.max = ht(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / zu(this.options)) } generateTickLabels(e) { oa.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, i) => { const r = Q(this.options.pointLabels.callback, [n, i], this); return r || r === 0 ? r : "" }).filter((n, i) => this.chart.getDataVisibility(i)) } fit() { const e = this.options; e.display && e.pointLabels.display ? S2(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, i, r) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((i - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, i, r)) } getIndexAngle(e) { const n = Jt / (this._pointLabels.length || 1), i = this.options.startAngle || 0; return Gt(e * n + cn(i)) } getDistanceFromCenterForValue(e) { if (et(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (et(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const i = n[e]; return A2(this.getContext(), e, i) } } getPointPosition(e, n, i = 0) { const r = this.getIndexAngle(e) - Wt + i; return { x: Math.cos(r) * n + this.xCenter, y: Math.sin(r) * n + this.yCenter, angle: r } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: i, right: r, bottom: s } = this._pointLabelItems[e]; return { left: n, top: i, right: r, bottom: s } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const i = this.ctx; i.save(), i.beginPath(), j0(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), i.closePath(), i.fillStyle = e, i.fill(), i.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: i, grid: r, border: s } = n, o = this._pointLabels.length; let a, l, u; if (n.pointLabels.display && T2(this, o), r.display && this.ticks.forEach((c, f) => { if (f !== 0) { l = this.getDistanceFromCenterForValue(c.value); const d = this.getContext(f), h = r.setContext(d), g = s.setContext(d); L2(this, h, l, o, g) } }), i.display) { for (e.save(), a = o - 1; a >= 0; a--) { const c = i.setContext(this.getPointLabelContext(a)), { color: f, lineWidth: d } = c; !d || !f || (e.lineWidth = d, e.strokeStyle = f, e.setLineDash(c.borderDash), e.lineDashOffset = c.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), u = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(u.x, u.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, i = n.ticks; if (!i.display) return; const r = this.getIndexAngle(0); let s, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => { if (l === 0 && !n.reverse) return; const u = i.setContext(this.getContext(l)), c = xt(u.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), u.showLabelBackdrop) { e.font = c.string, o = e.measureText(a.label).width, e.fillStyle = u.backdropColor; const f = Dt(u.backdropPadding); e.fillRect(-o / 2 - f.left, -s - c.size / 2 - f.top, o + f.width, c.size + f.height) } ii(e, a.label, 0, -s, c, { color: u.color }) }), e.restore() } drawTitle() { } } z(to, "id", "radialLinear"), z(to, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Ea.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(e) { return e }, padding: 5, centerPointLabels: !1 } }), z(to, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), z(to, "descriptors", { angleLines: { _fallback: "grid" } }); const Aa = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Bt = Object.keys(Aa); function D2(t, e) { return t - e } function tp(t, e) { if (et(e)) return null; const n = t._adapter, { parser: i, round: r, isoWeekday: s } = t._parseOpts; let o = e; return typeof i == "function" && (o = i(o)), ht(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)), o === null ? null : (r && (o = r === "week" && (ts(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, r)), +o) } function ep(t, e, n, i) { const r = Bt.length; for (let s = Bt.indexOf(t); s < r - 1; ++s) { const o = Aa[Bt[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - e) / (a * o.size)) <= i) return Bt[s] } return Bt[r - 1] } function N2(t, e, n, i, r) { for (let s = Bt.length - 1; s >= Bt.indexOf(n); s--) { const o = Bt[s]; if (Aa[o].common && t._adapter.diff(r, i, o) >= e - 1) return o } return Bt[n ? Bt.indexOf(n) : 0] } function I2(t) { for (let e = Bt.indexOf(t) + 1, n = Bt.length; e < n; ++e)if (Aa[Bt[e]].common) return Bt[e] } function np(t, e, n) { if (!n) t[e] = !0; else if (n.length) { const { lo: i, hi: r } = Xc(n, e), s = n[i] >= e ? n[i] : n[r]; t[s] = !0 } } function z2(t, e, n, i) { const r = t._adapter, s = +r.startOf(e[0].value, i), o = e[e.length - 1].value; let a, l; for (a = s; a <= o; a = +r.add(a, 1, i))l = n[a], l >= 0 && (e[l].major = !0); return e } function ip(t, e, n) { const i = [], r = {}, s = e.length; let o, a; for (o = 0; o < s; ++o)a = e[o], r[a] = o, i.push({ value: a, major: !1 }); return s === 0 || !n ? i : z2(t, i, r, n) } class aa extends oi { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const i = e.time || (e.time = {}), r = this._adapter = new vw._date(e.adapters.date); r.init(n), Mr(i.displayFormats, r.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return e === void 0 ? null : tp(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, i = e.time.unit || "day"; let { min: r, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(u) { !o && !isNaN(u.min) && (r = Math.min(r, u.min)), !a && !isNaN(u.max) && (s = Math.max(s, u.max)) } (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), r = ht(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i), s = ht(s) && !isNaN(s) ? s : +n.endOf(Date.now(), i) + 1, this.min = Math.min(r, s - 1), this.max = Math.max(r + 1, s) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], i = e[e.length - 1]), { min: n, max: i } } buildTicks() { const e = this.options, n = e.time, i = e.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate(); e.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const s = this.min, o = this.max, a = E_(r, s, o); return this._unit = n.unit || (i.autoSkip ? ep(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : N2(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : I2(this._unit), this.initOffsets(r), e.reverse && a.reverse(), ip(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let n = 0, i = 0, r, s; this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(e[1]) - r) / 2, s = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? i = s : i = (s - this.getDecimalForValue(e[e.length - 2])) / 2); const o = e.length < 3 ? .5 : .25; n = le(n, 0, o), i = le(i, 0, o), this._offsets = { start: n, end: i, factor: 1 / (n + 1 + i) } } _generate() { const e = this._adapter, n = this.min, i = this.max, r = this.options, s = r.time, o = s.unit || ep(s.minUnit, n, i, this._getLabelCapacity(n)), a = j(r.ticks.stepSize, 1), l = o === "week" ? s.isoWeekday : !1, u = ts(l) || l === !0, c = {}; let f = n, d, h; if (u && (f = +e.startOf(f, "isoWeek", l)), f = +e.startOf(f, u ? "day" : o), e.diff(i, n, o) > 1e5 * a) throw new Error(n + " and " + i + " are too far apart with stepSize of " + a + " " + o); const g = r.ticks.source === "data" && this.getDataTimestamps(); for (d = f, h = 0; d < i; d = +e.add(d, a, o), h++)np(c, d, g); return (d === i || r.bounds === "ticks" || h === 1) && np(c, d, g), Object.keys(c).sort((v, x) => v - x).map(v => +v) } getLabelForValue(e) { const n = this._adapter, i = this.options.time; return i.tooltipFormat ? n.format(e, i.tooltipFormat) : n.format(e, i.displayFormats.datetime) } _tickFormatFunction(e, n, i, r) { const s = this.options, o = s.ticks.callback; if (o) return Q(o, [e, n, i], this); const a = s.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && a[l], f = u && a[u], d = i[n], h = u && f && d && d.major; return this._adapter.format(e, r || (h ? f : c)) } generateTickLabels(e) { let n, i, r; for (n = 0, i = e.length; n < i; ++n)r = e[n], r.label = this._tickFormatFunction(r.value, n, e) } getDecimalForValue(e) { return e === null ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, i = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + i) * n.factor) } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + i * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, i = this.ctx.measureText(e).width, r = cn(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size; return { w: i * s + a * o, h: i * o + a * s } } _getLabelCapacity(e) { const n = this.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond, s = this._tickFormatFunction(e, 0, ip(this, [e], this._majorUnit), r), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let e = this._cache.data || [], n, i; if (e.length) return e; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (n = 0, i = r.length; n < i; ++n)e = e.concat(r[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, i; if (e.length) return e; const r = this.getLabels(); for (n = 0, i = r.length; n < i; ++n)e.push(tp(this, r[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return T_(e.sort(D2)) } } z(aa, "id", "time"), z(aa, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function eo(t, e, n) { let i = 0, r = t.length - 1, s, o, a, l; n ? (e >= t[i].pos && e <= t[r].pos && ({ lo: i, hi: r } = Un(t, "pos", e)), { pos: s, time: a } = t[i], { pos: o, time: l } = t[r]) : (e >= t[i].time && e <= t[r].time && ({ lo: i, hi: r } = Un(t, "time", e)), { time: s, pos: a } = t[i], { time: o, pos: l } = t[r]); const u = o - s; return u ? a + (l - a) * (e - s) / u : a } class rp extends aa { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = eo(n, this.min), this._tableRange = eo(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: i } = this, r = [], s = []; let o, a, l, u, c; for (o = 0, a = e.length; o < a; ++o)u = e[o], u >= n && u <= i && r.push(u); if (r.length < 2) return [{ time: n, pos: 0 }, { time: i, pos: 1 }]; for (o = 0, a = r.length; o < a; ++o)c = r[o + 1], l = r[o - 1], u = r[o], Math.round((c + l) / 2) !== u && s.push({ time: u, pos: o / (a - 1) }); return s } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), i = this.getLabelTimestamps(); return n.length && i.length ? e = this.normalize(n.concat(i)) : e = n.length ? n : i, e = this._cache.all = e, e } getDecimalForValue(e) { return (eo(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return eo(this._table, i * this._tableRange + this._minPos, !0) } } z(rp, "id", "timeseries"), z(rp, "defaults", aa.defaults); const B0 = "label"; function sp(t, e) { typeof t == "function" ? t(e) : t && (t.current = e) } function R2(t, e) { const n = t.options; n && e && Object.assign(n, e) } function H0(t, e) { t.labels = e } function W0(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : B0; const i = []; t.datasets = e.map(r => { const s = t.datasets.find(o => o[n] === r[n]); return !s || !r.data || i.includes(s) ? { ...r } : (i.push(s), Object.assign(s, r), s) }) } function F2(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : B0; const n = { labels: [], datasets: [] }; return H0(n, t.labels), W0(n, t.datasets, e), n } function j2(t, e) { let { height: n = 150, width: i = 300, redraw: r = !1, datasetIdKey: s, type: o, data: a, options: l, plugins: u = [], fallbackContent: c, updateMode: f, ...d } = t; const h = J.exports.useRef(null), g = J.exports.useRef(), v = () => { !h.current || (g.current = new sf(h.current, { type: o, data: F2(a, s), options: l && { ...l }, plugins: u }), sp(e, g.current)) }, x = () => { sp(e, null), g.current && (g.current.destroy(), g.current = null) }; return J.exports.useEffect(() => { !r && g.current && l && R2(g.current, l) }, [r, l]), J.exports.useEffect(() => { !r && g.current && H0(g.current.config.data, a.labels) }, [r, a.labels]), J.exports.useEffect(() => { !r && g.current && a.datasets && W0(g.current.config.data, a.datasets, s) }, [r, a.datasets]), J.exports.useEffect(() => { !g.current || (r ? (x(), setTimeout(v)) : g.current.update(f)) }, [r, l, a.labels, a.datasets, f]), J.exports.useEffect(() => { !g.current || (x(), setTimeout(v)) }, [o]), J.exports.useEffect(() => (v(), () => x()), []), ss.createElement("canvas", Object.assign({ ref: h, role: "img", height: n, width: i }, d), c) } const B2 = J.exports.forwardRef(j2); function H2(t, e) { return sf.register(e), J.exports.forwardRef((n, i) => ss.createElement(B2, Object.assign({}, n, { ref: i, type: t }))) } const W2 = H2("line", yo); sf.register(Nu, Iu, bo, dn, l2, g2, t2, o2); const $2 = { scales: { y: { display: !1, color: "#fff" }, x: { border: { display: !1, width: 10 }, grid: { display: !0, color: "rgba(255, 255, 255, 0.1)" }, ticks: { color: "#fff", font: { family: '"Fira Sans", sans-serif', weight: 600, size: 15 } } } }, responsive: !0, plugins: { tooltip: { enabled: !0, backgroundColor: "rgba(0, 0, 0, 0.8)", titleFont: { family: '"Fira Sans", sans-serif', size: 15 }, bodyFont: { family: '"Fira Sans", sans-serif', size: 15 }, padding: 20, caretSize: 10, displayColors: !1 }, legend: { display: !0, position: "bottom", title: { display: !1, text: "Yes", color: "#000" }, strokeStyle: "#000", labels: { color: "#fff", padding: 20, font: { family: '"Fira Sans", sans-serif', weight: 600, size: 25 }, pointStyle: "line", usePointStyle: !0, pointStyleWidth: .001 } }, title: { display: !1, text: "Weather Chart" } } }, V2 = ["00:00", "03:00", "06:00", "09:00", "12:00", "15:00", "18:00", "21:00", "24:00"], U2 = t => { const e = t.tempsData; return H("div", { className: "temp-chart", children: H(W2, { options: $2, data: { labels: V2, datasets: [{ fill: !0, tension: .35, label: "Temperature (C) ", data: e, borderColor: "rgba(73, 133, 224, 1)", backgroundColor: "rgba(73, 133, 224, 0.5)", borderWidth: 5, radius: 3, hoverRadius: 10, hitRadius: 100, pointStyle: "circle", color: "#fff" }] } }) }) }; const Y2 = ({ date: t, icon: e, value: n }) => dt("div", { className: "forecast", children: [H("h2", { className: "forecast-date", children: (s => new Date().toLocaleDateString("en-us", { weekday: "long", year: "numeric", month: "long", day: "numeric" }) === s)((s => { s = s.toString().split(" "); const a = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 }[s[0]], l = s[1]; return new Date(2022, a, l) })(t).toLocaleDateString("en-us", { weekday: "long", year: "numeric", month: "long", day: "numeric" })) ? "Today" : t }), dt("div", { className: "row", children: [H(Le, { icon: `fa-solid ${e}`, className: "forecast-weather__icon" }), dt("div", { className: "data", children: [H("h3", { className: "forecast-data", children: "Humidity" }), dt("h2", { className: "forecast-humidity", children: [n, "%"] })] })] })] }); const X2 = () => H("div", { className: "footer", children: dt("h3", { className: "footer__text", children: ["Designed and Built by", " ", H("a", { href: "https://github.com/SuproCodes", target: "_blank", children: "Supratik Dutta" }), " ", "with React, CSS, Chart.js, GeolocationAPI, and WeatherAPI."] }) }); const K2 = ({ extraData: t }) => dt("div", { className: "extra-container", children: [dt("div", { className: "extra-data", children: [H(Le, { icon: "fa-solid fa-weight-scale", className: "extra-data__icon" }), H("h3", { className: "data-type", children: "Pressure" }), dt("h2", { className: "pressure-data", children: [t == null ? void 0 : t.pressure, " mb"] })] }), dt("div", { className: "extra-data", children: [H(Le, { icon: "fa-solid fa-wind", className: "extra-data__icon" }), H("h3", { className: "data-type", children: "Wind" }), dt("h2", { className: "wind-data", children: [t == null ? void 0 : t.wind, " mph"] })] })] }), Q2 = "/assets/cloud-c301e49e.jpg", G2 = "/assets/night-86aa7a3d.jpg"; function Z2() { var p, y, _, b, w, k, S, P, M, D, F; const [t, e] = J.exports.useState({}), [n, i] = J.exports.useState(""), [r, s] = J.exports.useState(""), [o, a] = J.exports.useState(""), [l, u] = J.exports.useState(!0); J.exports.useEffect(() => { document.body.style = `background-image:  linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1)), url("assets/cloud.jpg");` }, [l]), J.exports.useEffect(() => { const A = new Date().getHours(), ut = A >= 6 && A < 18; u(ut) }, []); const c = "04c60fe1f2624fff885223022220912"; J.exports.useEffect(() => { navigator.geolocation.getCurrentPosition(A => { s(A.coords.latitude), a(A.coords.longitude) }, A => console.log(A)) }, []), J.exports.useEffect(() => { fetch(`https://api.weatherapi.com/v1/forecast.json?key=${c}&q=${r}, ${o}&days=3&aqi=no&alerts=yes`).then(A => A.json()).then(A => { e(A) }).catch(A => { console.log(A.message) }) }, [r]), J.exports.useEffect(() => { fetch(`https://api.weatherapi.com/v1/forecast.json?key=${c}&q=${n}&days=3&aqi=no&alerts=yes`).then(A => A.json()).then(A => { e(A) }).catch(A => { console.log(A.message) }) }, [n]); const f = { temp: (p = t == null ? void 0 : t.current) == null ? void 0 : p.temp_c, location: (y = t == null ? void 0 : t.location) == null ? void 0 : y.name, date: (_ = t == null ? void 0 : t.location) == null ? void 0 : _.localtime, icon: (w = (b = t == null ? void 0 : t.current) == null ? void 0 : b.condition) == null ? void 0 : w.icon, text: (S = (k = t == null ? void 0 : t.current) == null ? void 0 : k.condition) == null ? void 0 : S.text }, d = { pressure: (P = t == null ? void 0 : t.current) == null ? void 0 : P.pressure_mb, wind: (M = t == null ? void 0 : t.current) == null ? void 0 : M.wind_mph }, h = (D = t == null ? void 0 : t.forecast) == null ? void 0 : D.forecastday, g = []; (F = t == null ? void 0 : t.forecast) == null || F.forecastday[0].hour.map(A => { g.push(A.temp_c) }); const x = [...g.filter((A, ut) => ut % 3 === 0), g[g.length - 1]], m = A => { const ut = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; A = new Date(A); const Y = ut[A.getMonth()], X = A.getDate(); return `${Y} ${X}` }; return dt("div", { className: "App", children: [dt("nav", { className: "nav", children: [dt("div", { className: "logo", children: [H(Le, { icon: "fa-brands fa-skyatlas", className: "logo__icon" }), H("h1", { className: "logo__text", children: "What'sTheWeather!?" })] }), H(m1, { setCity: i, toggle: l }), H(Le, { icon: "fa-solid fa-circle-half-stroke", className: "switch-mode", onClick: () => { u(!l) }, style: { transform: l ? "scaleX(1)" : "scaleX(-1)" } })] }), dt("div", { className: "grid-two", children: [dt("div", { className: "grid-one", children: [H(d_, { weatherData: f }), H("div", { className: "grid-three", children: h == null ? void 0 : h.map(A => { var ut, Y, X; return H(Y2, { date: m(A.date), icon: Kg((Y = (ut = A.day) == null ? void 0 : ut.condition) == null ? void 0 : Y.text), value: (X = A.day) == null ? void 0 : X.avghumidity }, A.date) }) }), H("div", { className: "grid-three", children: H(K2, { extraData: d }) })] }), dt("div", { className: "grid-four", children: [H(U2, { tempsData: x }), H(X2, {})] })] })] }) } xl.createRoot(document.getElementById("root")).render(H(ss.StrictMode, { children: H(Z2, {}) }));